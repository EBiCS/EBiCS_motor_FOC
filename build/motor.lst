ARM GAS  /tmp/ccpEjOub.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"motor.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.clip_q63_to_q31,"ax",%progbits
  16              		.align	1
  17              		.arch armv7-m
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	clip_q63_to_q31:
  24              	.LFB44:
  25              		.file 1 "Core/Inc/arm_math.h"
   1:Core/Inc/arm_math.h **** /* ----------------------------------------------------------------------
   2:Core/Inc/arm_math.h **** * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
   3:Core/Inc/arm_math.h **** *
   4:Core/Inc/arm_math.h **** * $Date:        20. October 2015
   5:Core/Inc/arm_math.h **** * $Revision:    V1.4.5 b
   6:Core/Inc/arm_math.h **** *
   7:Core/Inc/arm_math.h **** * Project:      CMSIS DSP Library
   8:Core/Inc/arm_math.h **** * Title:        arm_math.h
   9:Core/Inc/arm_math.h **** *
  10:Core/Inc/arm_math.h **** * Description:  Public header file for CMSIS DSP Library
  11:Core/Inc/arm_math.h **** *
  12:Core/Inc/arm_math.h **** * Target Processor: Cortex-M7/Cortex-M4/Cortex-M3/Cortex-M0
  13:Core/Inc/arm_math.h **** *
  14:Core/Inc/arm_math.h **** * Redistribution and use in source and binary forms, with or without
  15:Core/Inc/arm_math.h **** * modification, are permitted provided that the following conditions
  16:Core/Inc/arm_math.h **** * are met:
  17:Core/Inc/arm_math.h **** *   - Redistributions of source code must retain the above copyright
  18:Core/Inc/arm_math.h **** *     notice, this list of conditions and the following disclaimer.
  19:Core/Inc/arm_math.h **** *   - Redistributions in binary form must reproduce the above copyright
  20:Core/Inc/arm_math.h **** *     notice, this list of conditions and the following disclaimer in
  21:Core/Inc/arm_math.h **** *     the documentation and/or other materials provided with the
  22:Core/Inc/arm_math.h **** *     distribution.
  23:Core/Inc/arm_math.h **** *   - Neither the name of ARM LIMITED nor the names of its contributors
  24:Core/Inc/arm_math.h **** *     may be used to endorse or promote products derived from this
  25:Core/Inc/arm_math.h **** *     software without specific prior written permission.
  26:Core/Inc/arm_math.h **** *
  27:Core/Inc/arm_math.h **** * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  28:Core/Inc/arm_math.h **** * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  29:Core/Inc/arm_math.h **** * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  30:Core/Inc/arm_math.h **** * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  31:Core/Inc/arm_math.h **** * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  32:Core/Inc/arm_math.h **** * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  33:Core/Inc/arm_math.h **** * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
ARM GAS  /tmp/ccpEjOub.s 			page 2


  34:Core/Inc/arm_math.h **** * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  35:Core/Inc/arm_math.h **** * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  36:Core/Inc/arm_math.h **** * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  37:Core/Inc/arm_math.h **** * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  38:Core/Inc/arm_math.h **** * POSSIBILITY OF SUCH DAMAGE.
  39:Core/Inc/arm_math.h ****  * -------------------------------------------------------------------- */
  40:Core/Inc/arm_math.h **** 
  41:Core/Inc/arm_math.h **** /**
  42:Core/Inc/arm_math.h ****    \mainpage CMSIS DSP Software Library
  43:Core/Inc/arm_math.h ****    *
  44:Core/Inc/arm_math.h ****    * Introduction
  45:Core/Inc/arm_math.h ****    * ------------
  46:Core/Inc/arm_math.h ****    *
  47:Core/Inc/arm_math.h ****    * This user manual describes the CMSIS DSP software library,
  48:Core/Inc/arm_math.h ****    * a suite of common signal processing functions for use on Cortex-M processor based devices.
  49:Core/Inc/arm_math.h ****    *
  50:Core/Inc/arm_math.h ****    * The library is divided into a number of functions each covering a specific category:
  51:Core/Inc/arm_math.h ****    * - Basic math functions
  52:Core/Inc/arm_math.h ****    * - Fast math functions
  53:Core/Inc/arm_math.h ****    * - Complex math functions
  54:Core/Inc/arm_math.h ****    * - Filters
  55:Core/Inc/arm_math.h ****    * - Matrix functions
  56:Core/Inc/arm_math.h ****    * - Transforms
  57:Core/Inc/arm_math.h ****    * - Motor control functions
  58:Core/Inc/arm_math.h ****    * - Statistical functions
  59:Core/Inc/arm_math.h ****    * - Support functions
  60:Core/Inc/arm_math.h ****    * - Interpolation functions
  61:Core/Inc/arm_math.h ****    *
  62:Core/Inc/arm_math.h ****    * The library has separate functions for operating on 8-bit integers, 16-bit integers,
  63:Core/Inc/arm_math.h ****    * 32-bit integer and 32-bit floating-point values.
  64:Core/Inc/arm_math.h ****    *
  65:Core/Inc/arm_math.h ****    * Using the Library
  66:Core/Inc/arm_math.h ****    * ------------
  67:Core/Inc/arm_math.h ****    *
  68:Core/Inc/arm_math.h ****    * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> fold
  69:Core/Inc/arm_math.h ****    * - arm_cortexM7lfdp_math.lib (Little endian and Double Precision Floating Point Unit on Cortex-
  70:Core/Inc/arm_math.h ****    * - arm_cortexM7bfdp_math.lib (Big endian and Double Precision Floating Point Unit on Cortex-M7)
  71:Core/Inc/arm_math.h ****    * - arm_cortexM7lfsp_math.lib (Little endian and Single Precision Floating Point Unit on Cortex-
  72:Core/Inc/arm_math.h ****    * - arm_cortexM7bfsp_math.lib (Big endian and Single Precision Floating Point Unit on Cortex-M7)
  73:Core/Inc/arm_math.h ****    * - arm_cortexM7l_math.lib (Little endian on Cortex-M7)
  74:Core/Inc/arm_math.h ****    * - arm_cortexM7b_math.lib (Big endian on Cortex-M7)
  75:Core/Inc/arm_math.h ****    * - arm_cortexM4lf_math.lib (Little endian and Floating Point Unit on Cortex-M4)
  76:Core/Inc/arm_math.h ****    * - arm_cortexM4bf_math.lib (Big endian and Floating Point Unit on Cortex-M4)
  77:Core/Inc/arm_math.h ****    * - arm_cortexM4l_math.lib (Little endian on Cortex-M4)
  78:Core/Inc/arm_math.h ****    * - arm_cortexM4b_math.lib (Big endian on Cortex-M4)
  79:Core/Inc/arm_math.h ****    * - arm_cortexM3l_math.lib (Little endian on Cortex-M3)
  80:Core/Inc/arm_math.h ****    * - arm_cortexM3b_math.lib (Big endian on Cortex-M3)
  81:Core/Inc/arm_math.h ****    * - arm_cortexM0l_math.lib (Little endian on Cortex-M0 / CortexM0+)
  82:Core/Inc/arm_math.h ****    * - arm_cortexM0b_math.lib (Big endian on Cortex-M0 / CortexM0+)
  83:Core/Inc/arm_math.h ****    *
  84:Core/Inc/arm_math.h ****    * The library functions are declared in the public file <code>arm_math.h</code> which is placed 
  85:Core/Inc/arm_math.h ****    * Simply include this file and link the appropriate library in the application and begin calling
  86:Core/Inc/arm_math.h ****    * public header file <code> arm_math.h</code> for Cortex-M7/M4/M3/M0/M0+ with little endian and 
  87:Core/Inc/arm_math.h ****    * Define the appropriate pre processor MACRO ARM_MATH_CM7 or ARM_MATH_CM4 or  ARM_MATH_CM3 or
  88:Core/Inc/arm_math.h ****    * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
  89:Core/Inc/arm_math.h ****    *
  90:Core/Inc/arm_math.h ****    * Examples
ARM GAS  /tmp/ccpEjOub.s 			page 3


  91:Core/Inc/arm_math.h ****    * --------
  92:Core/Inc/arm_math.h ****    *
  93:Core/Inc/arm_math.h ****    * The library ships with a number of examples which demonstrate how to use the library functions
  94:Core/Inc/arm_math.h ****    *
  95:Core/Inc/arm_math.h ****    * Toolchain Support
  96:Core/Inc/arm_math.h ****    * ------------
  97:Core/Inc/arm_math.h ****    *
  98:Core/Inc/arm_math.h ****    * The library has been developed and tested with MDK-ARM version 5.14.0.0
  99:Core/Inc/arm_math.h ****    * The library is being tested in GCC and IAR toolchains and updates on this activity will be mad
 100:Core/Inc/arm_math.h ****    *
 101:Core/Inc/arm_math.h ****    * Building the Library
 102:Core/Inc/arm_math.h ****    * ------------
 103:Core/Inc/arm_math.h ****    *
 104:Core/Inc/arm_math.h ****    * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in t
 105:Core/Inc/arm_math.h ****    * - arm_cortexM_math.uvprojx
 106:Core/Inc/arm_math.h ****    *
 107:Core/Inc/arm_math.h ****    *
 108:Core/Inc/arm_math.h ****    * The libraries can be built by opening the arm_cortexM_math.uvprojx project in MDK-ARM, selecti
 109:Core/Inc/arm_math.h ****    *
 110:Core/Inc/arm_math.h ****    * Pre-processor Macros
 111:Core/Inc/arm_math.h ****    * ------------
 112:Core/Inc/arm_math.h ****    *
 113:Core/Inc/arm_math.h ****    * Each library project have differant pre-processor macros.
 114:Core/Inc/arm_math.h ****    *
 115:Core/Inc/arm_math.h ****    * - UNALIGNED_SUPPORT_DISABLE:
 116:Core/Inc/arm_math.h ****    *
 117:Core/Inc/arm_math.h ****    * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory acces
 118:Core/Inc/arm_math.h ****    *
 119:Core/Inc/arm_math.h ****    * - ARM_MATH_BIG_ENDIAN:
 120:Core/Inc/arm_math.h ****    *
 121:Core/Inc/arm_math.h ****    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default libra
 122:Core/Inc/arm_math.h ****    *
 123:Core/Inc/arm_math.h ****    * - ARM_MATH_MATRIX_CHECK:
 124:Core/Inc/arm_math.h ****    *
 125:Core/Inc/arm_math.h ****    * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
 126:Core/Inc/arm_math.h ****    *
 127:Core/Inc/arm_math.h ****    * - ARM_MATH_ROUNDING:
 128:Core/Inc/arm_math.h ****    *
 129:Core/Inc/arm_math.h ****    * Define macro ARM_MATH_ROUNDING for rounding on support functions
 130:Core/Inc/arm_math.h ****    *
 131:Core/Inc/arm_math.h ****    * - ARM_MATH_CMx:
 132:Core/Inc/arm_math.h ****    *
 133:Core/Inc/arm_math.h ****    * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for build
 134:Core/Inc/arm_math.h ****    * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building libra
 135:Core/Inc/arm_math.h ****    * ARM_MATH_CM7 for building the library on cortex-M7.
 136:Core/Inc/arm_math.h ****    *
 137:Core/Inc/arm_math.h ****    * - __FPU_PRESENT:
 138:Core/Inc/arm_math.h ****    *
 139:Core/Inc/arm_math.h ****    * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro f
 140:Core/Inc/arm_math.h ****    *
 141:Core/Inc/arm_math.h ****    * <hr>
 142:Core/Inc/arm_math.h ****    * CMSIS-DSP in ARM::CMSIS Pack
 143:Core/Inc/arm_math.h ****    * -----------------------------
 144:Core/Inc/arm_math.h ****    *
 145:Core/Inc/arm_math.h ****    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directorie
 146:Core/Inc/arm_math.h ****    * |File/Folder                   |Content                                                       
 147:Core/Inc/arm_math.h ****    * |------------------------------|--------------------------------------------------------------
ARM GAS  /tmp/ccpEjOub.s 			page 4


 148:Core/Inc/arm_math.h ****    * |\b CMSIS\\Documentation\\DSP  | This documentation                                           
 149:Core/Inc/arm_math.h ****    * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                     
 150:Core/Inc/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library funct
 151:Core/Inc/arm_math.h ****    * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                      
 152:Core/Inc/arm_math.h ****    *
 153:Core/Inc/arm_math.h ****    * <hr>
 154:Core/Inc/arm_math.h ****    * Revision History of CMSIS-DSP
 155:Core/Inc/arm_math.h ****    * ------------
 156:Core/Inc/arm_math.h ****    * Please refer to \ref ChangeLog_pg.
 157:Core/Inc/arm_math.h ****    *
 158:Core/Inc/arm_math.h ****    * Copyright Notice
 159:Core/Inc/arm_math.h ****    * ------------
 160:Core/Inc/arm_math.h ****    *
 161:Core/Inc/arm_math.h ****    * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
 162:Core/Inc/arm_math.h ****    */
 163:Core/Inc/arm_math.h **** 
 164:Core/Inc/arm_math.h **** 
 165:Core/Inc/arm_math.h **** /**
 166:Core/Inc/arm_math.h ****  * @defgroup groupMath Basic Math Functions
 167:Core/Inc/arm_math.h ****  */
 168:Core/Inc/arm_math.h **** 
 169:Core/Inc/arm_math.h **** /**
 170:Core/Inc/arm_math.h ****  * @defgroup groupFastMath Fast Math Functions
 171:Core/Inc/arm_math.h ****  * This set of functions provides a fast approximation to sine, cosine, and square root.
 172:Core/Inc/arm_math.h ****  * As compared to most of the other functions in the CMSIS math library, the fast math functions
 173:Core/Inc/arm_math.h ****  * operate on individual values and not arrays.
 174:Core/Inc/arm_math.h ****  * There are separate functions for Q15, Q31, and floating-point data.
 175:Core/Inc/arm_math.h ****  *
 176:Core/Inc/arm_math.h ****  */
 177:Core/Inc/arm_math.h **** 
 178:Core/Inc/arm_math.h **** /**
 179:Core/Inc/arm_math.h ****  * @defgroup groupCmplxMath Complex Math Functions
 180:Core/Inc/arm_math.h ****  * This set of functions operates on complex data vectors.
 181:Core/Inc/arm_math.h ****  * The data in the complex arrays is stored in an interleaved fashion
 182:Core/Inc/arm_math.h ****  * (real, imag, real, imag, ...).
 183:Core/Inc/arm_math.h ****  * In the API functions, the number of samples in a complex array refers
 184:Core/Inc/arm_math.h ****  * to the number of complex values; the array contains twice this number of
 185:Core/Inc/arm_math.h ****  * real values.
 186:Core/Inc/arm_math.h ****  */
 187:Core/Inc/arm_math.h **** 
 188:Core/Inc/arm_math.h **** /**
 189:Core/Inc/arm_math.h ****  * @defgroup groupFilters Filtering Functions
 190:Core/Inc/arm_math.h ****  */
 191:Core/Inc/arm_math.h **** 
 192:Core/Inc/arm_math.h **** /**
 193:Core/Inc/arm_math.h ****  * @defgroup groupMatrix Matrix Functions
 194:Core/Inc/arm_math.h ****  *
 195:Core/Inc/arm_math.h ****  * This set of functions provides basic matrix math operations.
 196:Core/Inc/arm_math.h ****  * The functions operate on matrix data structures.  For example,
 197:Core/Inc/arm_math.h ****  * the type
 198:Core/Inc/arm_math.h ****  * definition for the floating-point matrix structure is shown
 199:Core/Inc/arm_math.h ****  * below:
 200:Core/Inc/arm_math.h ****  * <pre>
 201:Core/Inc/arm_math.h ****  *     typedef struct
 202:Core/Inc/arm_math.h ****  *     {
 203:Core/Inc/arm_math.h ****  *       uint16_t numRows;     // number of rows of the matrix.
 204:Core/Inc/arm_math.h ****  *       uint16_t numCols;     // number of columns of the matrix.
ARM GAS  /tmp/ccpEjOub.s 			page 5


 205:Core/Inc/arm_math.h ****  *       float32_t *pData;     // points to the data of the matrix.
 206:Core/Inc/arm_math.h ****  *     } arm_matrix_instance_f32;
 207:Core/Inc/arm_math.h ****  * </pre>
 208:Core/Inc/arm_math.h ****  * There are similar definitions for Q15 and Q31 data types.
 209:Core/Inc/arm_math.h ****  *
 210:Core/Inc/arm_math.h ****  * The structure specifies the size of the matrix and then points to
 211:Core/Inc/arm_math.h ****  * an array of data.  The array is of size <code>numRows X numCols</code>
 212:Core/Inc/arm_math.h ****  * and the values are arranged in row order.  That is, the
 213:Core/Inc/arm_math.h ****  * matrix element (i, j) is stored at:
 214:Core/Inc/arm_math.h ****  * <pre>
 215:Core/Inc/arm_math.h ****  *     pData[i*numCols + j]
 216:Core/Inc/arm_math.h ****  * </pre>
 217:Core/Inc/arm_math.h ****  *
 218:Core/Inc/arm_math.h ****  * \par Init Functions
 219:Core/Inc/arm_math.h ****  * There is an associated initialization function for each type of matrix
 220:Core/Inc/arm_math.h ****  * data structure.
 221:Core/Inc/arm_math.h ****  * The initialization function sets the values of the internal structure fields.
 222:Core/Inc/arm_math.h ****  * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
 223:Core/Inc/arm_math.h ****  * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
 224:Core/Inc/arm_math.h ****  *
 225:Core/Inc/arm_math.h ****  * \par
 226:Core/Inc/arm_math.h ****  * Use of the initialization function is optional. However, if initialization function is used
 227:Core/Inc/arm_math.h ****  * then the instance structure cannot be placed into a const data section.
 228:Core/Inc/arm_math.h ****  * To place the instance structure in a const data
 229:Core/Inc/arm_math.h ****  * section, manually initialize the data structure.  For example:
 230:Core/Inc/arm_math.h ****  * <pre>
 231:Core/Inc/arm_math.h ****  * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
 232:Core/Inc/arm_math.h ****  * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
 233:Core/Inc/arm_math.h ****  * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
 234:Core/Inc/arm_math.h ****  * </pre>
 235:Core/Inc/arm_math.h ****  * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
 236:Core/Inc/arm_math.h ****  * specifies the number of columns, and <code>pData</code> points to the
 237:Core/Inc/arm_math.h ****  * data array.
 238:Core/Inc/arm_math.h ****  *
 239:Core/Inc/arm_math.h ****  * \par Size Checking
 240:Core/Inc/arm_math.h ****  * By default all of the matrix functions perform size checking on the input and
 241:Core/Inc/arm_math.h ****  * output matrices.  For example, the matrix addition function verifies that the
 242:Core/Inc/arm_math.h ****  * two input matrices and the output matrix all have the same number of rows and
 243:Core/Inc/arm_math.h ****  * columns.  If the size check fails the functions return:
 244:Core/Inc/arm_math.h ****  * <pre>
 245:Core/Inc/arm_math.h ****  *     ARM_MATH_SIZE_MISMATCH
 246:Core/Inc/arm_math.h ****  * </pre>
 247:Core/Inc/arm_math.h ****  * Otherwise the functions return
 248:Core/Inc/arm_math.h ****  * <pre>
 249:Core/Inc/arm_math.h ****  *     ARM_MATH_SUCCESS
 250:Core/Inc/arm_math.h ****  * </pre>
 251:Core/Inc/arm_math.h ****  * There is some overhead associated with this matrix size checking.
 252:Core/Inc/arm_math.h ****  * The matrix size checking is enabled via the \#define
 253:Core/Inc/arm_math.h ****  * <pre>
 254:Core/Inc/arm_math.h ****  *     ARM_MATH_MATRIX_CHECK
 255:Core/Inc/arm_math.h ****  * </pre>
 256:Core/Inc/arm_math.h ****  * within the library project settings.  By default this macro is defined
 257:Core/Inc/arm_math.h ****  * and size checking is enabled.  By changing the project settings and
 258:Core/Inc/arm_math.h ****  * undefining this macro size checking is eliminated and the functions
 259:Core/Inc/arm_math.h ****  * run a bit faster.  With size checking disabled the functions always
 260:Core/Inc/arm_math.h ****  * return <code>ARM_MATH_SUCCESS</code>.
 261:Core/Inc/arm_math.h ****  */
ARM GAS  /tmp/ccpEjOub.s 			page 6


 262:Core/Inc/arm_math.h **** 
 263:Core/Inc/arm_math.h **** /**
 264:Core/Inc/arm_math.h ****  * @defgroup groupTransforms Transform Functions
 265:Core/Inc/arm_math.h ****  */
 266:Core/Inc/arm_math.h **** 
 267:Core/Inc/arm_math.h **** /**
 268:Core/Inc/arm_math.h ****  * @defgroup groupController Controller Functions
 269:Core/Inc/arm_math.h ****  */
 270:Core/Inc/arm_math.h **** 
 271:Core/Inc/arm_math.h **** /**
 272:Core/Inc/arm_math.h ****  * @defgroup groupStats Statistics Functions
 273:Core/Inc/arm_math.h ****  */
 274:Core/Inc/arm_math.h **** /**
 275:Core/Inc/arm_math.h ****  * @defgroup groupSupport Support Functions
 276:Core/Inc/arm_math.h ****  */
 277:Core/Inc/arm_math.h **** 
 278:Core/Inc/arm_math.h **** /**
 279:Core/Inc/arm_math.h ****  * @defgroup groupInterpolation Interpolation Functions
 280:Core/Inc/arm_math.h ****  * These functions perform 1- and 2-dimensional interpolation of data.
 281:Core/Inc/arm_math.h ****  * Linear interpolation is used for 1-dimensional data and
 282:Core/Inc/arm_math.h ****  * bilinear interpolation is used for 2-dimensional data.
 283:Core/Inc/arm_math.h ****  */
 284:Core/Inc/arm_math.h **** 
 285:Core/Inc/arm_math.h **** /**
 286:Core/Inc/arm_math.h ****  * @defgroup groupExamples Examples
 287:Core/Inc/arm_math.h ****  */
 288:Core/Inc/arm_math.h **** #ifndef _ARM_MATH_H
 289:Core/Inc/arm_math.h **** #define _ARM_MATH_H
 290:Core/Inc/arm_math.h **** 
 291:Core/Inc/arm_math.h **** /* ignore some GCC warnings */
 292:Core/Inc/arm_math.h **** #if defined ( __GNUC__ )
 293:Core/Inc/arm_math.h **** #pragma GCC diagnostic push
 294:Core/Inc/arm_math.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
 295:Core/Inc/arm_math.h **** #pragma GCC diagnostic ignored "-Wconversion"
 296:Core/Inc/arm_math.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
 297:Core/Inc/arm_math.h **** #endif
 298:Core/Inc/arm_math.h **** 
 299:Core/Inc/arm_math.h **** #define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
 300:Core/Inc/arm_math.h **** 
 301:Core/Inc/arm_math.h **** #if defined(ARM_MATH_CM7)
 302:Core/Inc/arm_math.h ****   #include "core_cm7.h"
 303:Core/Inc/arm_math.h **** #elif defined (ARM_MATH_CM4)
 304:Core/Inc/arm_math.h ****   #include "core_cm4.h"
 305:Core/Inc/arm_math.h **** #elif defined (ARM_MATH_CM3)
 306:Core/Inc/arm_math.h ****   #include "core_cm3.h"
 307:Core/Inc/arm_math.h **** #elif defined (ARM_MATH_CM0)
 308:Core/Inc/arm_math.h ****   #include "core_cm0.h"
 309:Core/Inc/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 310:Core/Inc/arm_math.h **** #elif defined (ARM_MATH_CM0PLUS)
 311:Core/Inc/arm_math.h ****   #include "core_cm0plus.h"
 312:Core/Inc/arm_math.h ****   #define ARM_MATH_CM0_FAMILY
 313:Core/Inc/arm_math.h **** #else
 314:Core/Inc/arm_math.h ****   #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_
 315:Core/Inc/arm_math.h **** #endif
 316:Core/Inc/arm_math.h **** 
 317:Core/Inc/arm_math.h **** #undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 318:Core/Inc/arm_math.h **** #include "string.h"
ARM GAS  /tmp/ccpEjOub.s 			page 7


 319:Core/Inc/arm_math.h **** #include "math.h"
 320:Core/Inc/arm_math.h **** #ifdef   __cplusplus
 321:Core/Inc/arm_math.h **** extern "C"
 322:Core/Inc/arm_math.h **** {
 323:Core/Inc/arm_math.h **** #endif
 324:Core/Inc/arm_math.h **** 
 325:Core/Inc/arm_math.h **** 
 326:Core/Inc/arm_math.h ****   /**
 327:Core/Inc/arm_math.h ****    * @brief Macros required for reciprocal calculation in Normalized LMS
 328:Core/Inc/arm_math.h ****    */
 329:Core/Inc/arm_math.h **** 
 330:Core/Inc/arm_math.h **** #define DELTA_Q31          (0x100)
 331:Core/Inc/arm_math.h **** #define DELTA_Q15          0x5
 332:Core/Inc/arm_math.h **** #define INDEX_MASK         0x0000003F
 333:Core/Inc/arm_math.h **** #ifndef PI
 334:Core/Inc/arm_math.h **** #define PI                 3.14159265358979f
 335:Core/Inc/arm_math.h **** #endif
 336:Core/Inc/arm_math.h **** 
 337:Core/Inc/arm_math.h ****   /**
 338:Core/Inc/arm_math.h ****    * @brief Macros required for SINE and COSINE Fast math approximations
 339:Core/Inc/arm_math.h ****    */
 340:Core/Inc/arm_math.h **** 
 341:Core/Inc/arm_math.h **** #define FAST_MATH_TABLE_SIZE  512
 342:Core/Inc/arm_math.h **** #define FAST_MATH_Q31_SHIFT   (32 - 10)
 343:Core/Inc/arm_math.h **** #define FAST_MATH_Q15_SHIFT   (16 - 10)
 344:Core/Inc/arm_math.h **** #define CONTROLLER_Q31_SHIFT  (32 - 9)
 345:Core/Inc/arm_math.h **** #define TABLE_SIZE  256
 346:Core/Inc/arm_math.h **** #define TABLE_SPACING_Q31     0x400000
 347:Core/Inc/arm_math.h **** #define TABLE_SPACING_Q15     0x80
 348:Core/Inc/arm_math.h **** 
 349:Core/Inc/arm_math.h ****   /**
 350:Core/Inc/arm_math.h ****    * @brief Macros required for SINE and COSINE Controller functions
 351:Core/Inc/arm_math.h ****    */
 352:Core/Inc/arm_math.h ****   /* 1.31(q31) Fixed value of 2/360 */
 353:Core/Inc/arm_math.h ****   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 354:Core/Inc/arm_math.h **** #define INPUT_SPACING         0xB60B61
 355:Core/Inc/arm_math.h **** 
 356:Core/Inc/arm_math.h ****   /**
 357:Core/Inc/arm_math.h ****    * @brief Macro for Unaligned Support
 358:Core/Inc/arm_math.h ****    */
 359:Core/Inc/arm_math.h **** #ifndef UNALIGNED_SUPPORT_DISABLE
 360:Core/Inc/arm_math.h ****     #define ALIGN4
 361:Core/Inc/arm_math.h **** #else
 362:Core/Inc/arm_math.h ****   #if defined  (__GNUC__)
 363:Core/Inc/arm_math.h ****     #define ALIGN4 __attribute__((aligned(4)))
 364:Core/Inc/arm_math.h ****   #else
 365:Core/Inc/arm_math.h ****     #define ALIGN4 __align(4)
 366:Core/Inc/arm_math.h ****   #endif
 367:Core/Inc/arm_math.h **** #endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 368:Core/Inc/arm_math.h **** 
 369:Core/Inc/arm_math.h ****   /**
 370:Core/Inc/arm_math.h ****    * @brief Error status returned by some functions in the library.
 371:Core/Inc/arm_math.h ****    */
 372:Core/Inc/arm_math.h **** 
 373:Core/Inc/arm_math.h ****   typedef enum
 374:Core/Inc/arm_math.h ****   {
 375:Core/Inc/arm_math.h ****     ARM_MATH_SUCCESS = 0,                /**< No error */
ARM GAS  /tmp/ccpEjOub.s 			page 8


 376:Core/Inc/arm_math.h ****     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
 377:Core/Inc/arm_math.h ****     ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
 378:Core/Inc/arm_math.h ****     ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation
 379:Core/Inc/arm_math.h ****     ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
 380:Core/Inc/arm_math.h ****     ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is 
 381:Core/Inc/arm_math.h ****     ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
 382:Core/Inc/arm_math.h ****   } arm_status;
 383:Core/Inc/arm_math.h **** 
 384:Core/Inc/arm_math.h ****   /**
 385:Core/Inc/arm_math.h ****    * @brief 8-bit fractional data type in 1.7 format.
 386:Core/Inc/arm_math.h ****    */
 387:Core/Inc/arm_math.h ****   typedef int8_t q7_t;
 388:Core/Inc/arm_math.h **** 
 389:Core/Inc/arm_math.h ****   /**
 390:Core/Inc/arm_math.h ****    * @brief 16-bit fractional data type in 1.15 format.
 391:Core/Inc/arm_math.h ****    */
 392:Core/Inc/arm_math.h ****   typedef int16_t q15_t;
 393:Core/Inc/arm_math.h **** 
 394:Core/Inc/arm_math.h ****   /**
 395:Core/Inc/arm_math.h ****    * @brief 32-bit fractional data type in 1.31 format.
 396:Core/Inc/arm_math.h ****    */
 397:Core/Inc/arm_math.h ****   typedef int32_t q31_t;
 398:Core/Inc/arm_math.h **** 
 399:Core/Inc/arm_math.h ****   /**
 400:Core/Inc/arm_math.h ****    * @brief 64-bit fractional data type in 1.63 format.
 401:Core/Inc/arm_math.h ****    */
 402:Core/Inc/arm_math.h ****   typedef int64_t q63_t;
 403:Core/Inc/arm_math.h **** 
 404:Core/Inc/arm_math.h ****   /**
 405:Core/Inc/arm_math.h ****    * @brief 32-bit floating-point type definition.
 406:Core/Inc/arm_math.h ****    */
 407:Core/Inc/arm_math.h ****   typedef float float32_t;
 408:Core/Inc/arm_math.h **** 
 409:Core/Inc/arm_math.h ****   /**
 410:Core/Inc/arm_math.h ****    * @brief 64-bit floating-point type definition.
 411:Core/Inc/arm_math.h ****    */
 412:Core/Inc/arm_math.h ****   typedef double float64_t;
 413:Core/Inc/arm_math.h **** 
 414:Core/Inc/arm_math.h ****   /**
 415:Core/Inc/arm_math.h ****    * @brief definition to read/write two 16 bit values.
 416:Core/Inc/arm_math.h ****    */
 417:Core/Inc/arm_math.h **** #if defined __CC_ARM
 418:Core/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 419:Core/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 420:Core/Inc/arm_math.h **** 
 421:Core/Inc/arm_math.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
 422:Core/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 423:Core/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 424:Core/Inc/arm_math.h **** 
 425:Core/Inc/arm_math.h **** #elif defined __GNUC__
 426:Core/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 427:Core/Inc/arm_math.h ****   #define CMSIS_UNUSED __attribute__((unused))
 428:Core/Inc/arm_math.h **** 
 429:Core/Inc/arm_math.h **** #elif defined __ICCARM__
 430:Core/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t __packed
 431:Core/Inc/arm_math.h ****   #define CMSIS_UNUSED
 432:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 9


 433:Core/Inc/arm_math.h **** #elif defined __CSMC__
 434:Core/Inc/arm_math.h ****   #define __SIMD32_TYPE int32_t
 435:Core/Inc/arm_math.h ****   #define CMSIS_UNUSED
 436:Core/Inc/arm_math.h **** 
 437:Core/Inc/arm_math.h **** #elif defined __TASKING__
 438:Core/Inc/arm_math.h ****   #define __SIMD32_TYPE __unaligned int32_t
 439:Core/Inc/arm_math.h ****   #define CMSIS_UNUSED
 440:Core/Inc/arm_math.h **** 
 441:Core/Inc/arm_math.h **** #else
 442:Core/Inc/arm_math.h ****   #error Unknown compiler
 443:Core/Inc/arm_math.h **** #endif
 444:Core/Inc/arm_math.h **** 
 445:Core/Inc/arm_math.h **** #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
 446:Core/Inc/arm_math.h **** #define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
 447:Core/Inc/arm_math.h **** #define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
 448:Core/Inc/arm_math.h **** #define __SIMD64(addr)        (*(int64_t **) & (addr))
 449:Core/Inc/arm_math.h **** 
 450:Core/Inc/arm_math.h **** #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
 451:Core/Inc/arm_math.h ****   /**
 452:Core/Inc/arm_math.h ****    * @brief definition to pack two 16 bit values.
 453:Core/Inc/arm_math.h ****    */
 454:Core/Inc/arm_math.h **** #define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) | \
 455:Core/Inc/arm_math.h ****                                          (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
 456:Core/Inc/arm_math.h **** #define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) | \
 457:Core/Inc/arm_math.h ****                                          (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
 458:Core/Inc/arm_math.h **** 
 459:Core/Inc/arm_math.h **** #endif
 460:Core/Inc/arm_math.h **** 
 461:Core/Inc/arm_math.h **** 
 462:Core/Inc/arm_math.h ****    /**
 463:Core/Inc/arm_math.h ****    * @brief definition to pack four 8 bit values.
 464:Core/Inc/arm_math.h ****    */
 465:Core/Inc/arm_math.h **** #ifndef ARM_MATH_BIG_ENDIAN
 466:Core/Inc/arm_math.h **** 
 467:Core/Inc/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
 468:Core/Inc/arm_math.h ****                                 (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
 469:Core/Inc/arm_math.h ****                                 (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
 470:Core/Inc/arm_math.h ****                                 (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 471:Core/Inc/arm_math.h **** #else
 472:Core/Inc/arm_math.h **** 
 473:Core/Inc/arm_math.h **** #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
 474:Core/Inc/arm_math.h ****                                 (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
 475:Core/Inc/arm_math.h ****                                 (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
 476:Core/Inc/arm_math.h ****                                 (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 477:Core/Inc/arm_math.h **** 
 478:Core/Inc/arm_math.h **** #endif
 479:Core/Inc/arm_math.h **** 
 480:Core/Inc/arm_math.h **** 
 481:Core/Inc/arm_math.h ****   /**
 482:Core/Inc/arm_math.h ****    * @brief Clips Q63 to Q31 values.
 483:Core/Inc/arm_math.h ****    */
 484:Core/Inc/arm_math.h ****   static __INLINE q31_t clip_q63_to_q31(
 485:Core/Inc/arm_math.h ****   q63_t x)
 486:Core/Inc/arm_math.h ****   {
  26              		.loc 1 486 3
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccpEjOub.s 			page 10


  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 80B4     		push	{r7}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 7, -4
  35 0002 83B0     		sub	sp, sp, #12
  36              	.LCFI1:
  37              		.cfi_def_cfa_offset 16
  38 0004 00AF     		add	r7, sp, #0
  39              	.LCFI2:
  40              		.cfi_def_cfa_register 7
  41 0006 C7E90001 		strd	r0, [r7]
 487:Core/Inc/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
  42              		.loc 1 487 24
  43 000a D7E90001 		ldrd	r0, [r7]
  44 000e 4FF00002 		mov	r2, #0
  45 0012 4FF00003 		mov	r3, #0
  46 0016 0A00     		movs	r2, r1
  47 0018 CB17     		asrs	r3, r1, #31
  48              		.loc 1 487 35
  49 001a 3B68     		ldr	r3, [r7]
  50              		.loc 1 487 45
  51 001c DB17     		asrs	r3, r3, #31
 488:Core/Inc/arm_math.h ****       ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
  52              		.loc 1 488 44
  53 001e 9A42     		cmp	r2, r3
  54 0020 0CD0     		beq	.L2
  55              		.loc 1 488 34 discriminator 1
  56 0022 D7E90001 		ldrd	r0, [r7]
  57 0026 4FF00002 		mov	r2, #0
  58 002a 4FF00003 		mov	r3, #0
  59 002e CA17     		asrs	r2, r1, #31
  60 0030 CB17     		asrs	r3, r1, #31
  61              		.loc 1 488 23 discriminator 1
  62 0032 1346     		mov	r3, r2
  63              		.loc 1 488 44 discriminator 1
  64 0034 83F00043 		eor	r3, r3, #-2147483648
  65 0038 DB43     		mvns	r3, r3
  66 003a 00E0     		b	.L4
  67              	.L2:
  68              		.loc 1 488 44 is_stmt 0 discriminator 2
  69 003c 3B68     		ldr	r3, [r7]
  70              	.L4:
 489:Core/Inc/arm_math.h ****   }
  71              		.loc 1 489 3 is_stmt 1 discriminator 5
  72 003e 1846     		mov	r0, r3
  73 0040 0C37     		adds	r7, r7, #12
  74              	.LCFI3:
  75              		.cfi_def_cfa_offset 4
  76 0042 BD46     		mov	sp, r7
  77              	.LCFI4:
  78              		.cfi_def_cfa_register 13
  79              		@ sp needed
  80 0044 80BC     		pop	{r7}
  81              	.LCFI5:
  82              		.cfi_restore 7
ARM GAS  /tmp/ccpEjOub.s 			page 11


  83              		.cfi_def_cfa_offset 0
  84 0046 7047     		bx	lr
  85              		.cfi_endproc
  86              	.LFE44:
  88              		.section	.text.__QADD,"ax",%progbits
  89              		.align	1
  90              		.syntax unified
  91              		.thumb
  92              		.thumb_func
  93              		.fpu softvfp
  95              	__QADD:
  96              	.LFB63:
 490:Core/Inc/arm_math.h **** 
 491:Core/Inc/arm_math.h ****   /**
 492:Core/Inc/arm_math.h ****    * @brief Clips Q63 to Q15 values.
 493:Core/Inc/arm_math.h ****    */
 494:Core/Inc/arm_math.h ****   static __INLINE q15_t clip_q63_to_q15(
 495:Core/Inc/arm_math.h ****   q63_t x)
 496:Core/Inc/arm_math.h ****   {
 497:Core/Inc/arm_math.h ****     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
 498:Core/Inc/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
 499:Core/Inc/arm_math.h ****   }
 500:Core/Inc/arm_math.h **** 
 501:Core/Inc/arm_math.h ****   /**
 502:Core/Inc/arm_math.h ****    * @brief Clips Q31 to Q7 values.
 503:Core/Inc/arm_math.h ****    */
 504:Core/Inc/arm_math.h ****   static __INLINE q7_t clip_q31_to_q7(
 505:Core/Inc/arm_math.h ****   q31_t x)
 506:Core/Inc/arm_math.h ****   {
 507:Core/Inc/arm_math.h ****     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
 508:Core/Inc/arm_math.h ****       ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
 509:Core/Inc/arm_math.h ****   }
 510:Core/Inc/arm_math.h **** 
 511:Core/Inc/arm_math.h ****   /**
 512:Core/Inc/arm_math.h ****    * @brief Clips Q31 to Q15 values.
 513:Core/Inc/arm_math.h ****    */
 514:Core/Inc/arm_math.h ****   static __INLINE q15_t clip_q31_to_q15(
 515:Core/Inc/arm_math.h ****   q31_t x)
 516:Core/Inc/arm_math.h ****   {
 517:Core/Inc/arm_math.h ****     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
 518:Core/Inc/arm_math.h ****       ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
 519:Core/Inc/arm_math.h ****   }
 520:Core/Inc/arm_math.h **** 
 521:Core/Inc/arm_math.h ****   /**
 522:Core/Inc/arm_math.h ****    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
 523:Core/Inc/arm_math.h ****    */
 524:Core/Inc/arm_math.h **** 
 525:Core/Inc/arm_math.h ****   static __INLINE q63_t mult32x64(
 526:Core/Inc/arm_math.h ****   q63_t x,
 527:Core/Inc/arm_math.h ****   q31_t y)
 528:Core/Inc/arm_math.h ****   {
 529:Core/Inc/arm_math.h ****     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
 530:Core/Inc/arm_math.h ****             (((q63_t) (x >> 32) * y)));
 531:Core/Inc/arm_math.h ****   }
 532:Core/Inc/arm_math.h **** 
 533:Core/Inc/arm_math.h **** /*
 534:Core/Inc/arm_math.h ****   #if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
ARM GAS  /tmp/ccpEjOub.s 			page 12


 535:Core/Inc/arm_math.h ****   #define __CLZ __clz
 536:Core/Inc/arm_math.h ****   #endif
 537:Core/Inc/arm_math.h ****  */
 538:Core/Inc/arm_math.h **** /* note: function can be removed when all toolchain support __CLZ for Cortex-M0 */
 539:Core/Inc/arm_math.h **** #if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__))  )
 540:Core/Inc/arm_math.h ****   static __INLINE uint32_t __CLZ(
 541:Core/Inc/arm_math.h ****   q31_t data);
 542:Core/Inc/arm_math.h **** 
 543:Core/Inc/arm_math.h ****   static __INLINE uint32_t __CLZ(
 544:Core/Inc/arm_math.h ****   q31_t data)
 545:Core/Inc/arm_math.h ****   {
 546:Core/Inc/arm_math.h ****     uint32_t count = 0;
 547:Core/Inc/arm_math.h ****     uint32_t mask = 0x80000000;
 548:Core/Inc/arm_math.h **** 
 549:Core/Inc/arm_math.h ****     while((data & mask) == 0)
 550:Core/Inc/arm_math.h ****     {
 551:Core/Inc/arm_math.h ****       count += 1u;
 552:Core/Inc/arm_math.h ****       mask = mask >> 1u;
 553:Core/Inc/arm_math.h ****     }
 554:Core/Inc/arm_math.h **** 
 555:Core/Inc/arm_math.h ****     return (count);
 556:Core/Inc/arm_math.h ****   }
 557:Core/Inc/arm_math.h **** #endif
 558:Core/Inc/arm_math.h **** 
 559:Core/Inc/arm_math.h ****   /**
 560:Core/Inc/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
 561:Core/Inc/arm_math.h ****    */
 562:Core/Inc/arm_math.h **** 
 563:Core/Inc/arm_math.h ****   static __INLINE uint32_t arm_recip_q31(
 564:Core/Inc/arm_math.h ****   q31_t in,
 565:Core/Inc/arm_math.h ****   q31_t * dst,
 566:Core/Inc/arm_math.h ****   q31_t * pRecipTable)
 567:Core/Inc/arm_math.h ****   {
 568:Core/Inc/arm_math.h ****     q31_t out;
 569:Core/Inc/arm_math.h ****     uint32_t tempVal;
 570:Core/Inc/arm_math.h ****     uint32_t index, i;
 571:Core/Inc/arm_math.h ****     uint32_t signBits;
 572:Core/Inc/arm_math.h **** 
 573:Core/Inc/arm_math.h ****     if(in > 0)
 574:Core/Inc/arm_math.h ****     {
 575:Core/Inc/arm_math.h ****       signBits = ((uint32_t) (__CLZ( in) - 1));
 576:Core/Inc/arm_math.h ****     }
 577:Core/Inc/arm_math.h ****     else
 578:Core/Inc/arm_math.h ****     {
 579:Core/Inc/arm_math.h ****       signBits = ((uint32_t) (__CLZ(-in) - 1));
 580:Core/Inc/arm_math.h ****     }
 581:Core/Inc/arm_math.h **** 
 582:Core/Inc/arm_math.h ****     /* Convert input sample to 1.31 format */
 583:Core/Inc/arm_math.h ****     in = (in << signBits);
 584:Core/Inc/arm_math.h **** 
 585:Core/Inc/arm_math.h ****     /* calculation of index for initial approximated Val */
 586:Core/Inc/arm_math.h ****     index = (uint32_t)(in >> 24);
 587:Core/Inc/arm_math.h ****     index = (index & INDEX_MASK);
 588:Core/Inc/arm_math.h **** 
 589:Core/Inc/arm_math.h ****     /* 1.31 with exp 1 */
 590:Core/Inc/arm_math.h ****     out = pRecipTable[index];
 591:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 13


 592:Core/Inc/arm_math.h ****     /* calculation of reciprocal value */
 593:Core/Inc/arm_math.h ****     /* running approximation for two iterations */
 594:Core/Inc/arm_math.h ****     for (i = 0u; i < 2u; i++)
 595:Core/Inc/arm_math.h ****     {
 596:Core/Inc/arm_math.h ****       tempVal = (uint32_t) (((q63_t) in * out) >> 31);
 597:Core/Inc/arm_math.h ****       tempVal = 0x7FFFFFFFu - tempVal;
 598:Core/Inc/arm_math.h ****       /*      1.31 with exp 1 */
 599:Core/Inc/arm_math.h ****       /* out = (q31_t) (((q63_t) out * tempVal) >> 30); */
 600:Core/Inc/arm_math.h ****       out = clip_q63_to_q31(((q63_t) out * tempVal) >> 30);
 601:Core/Inc/arm_math.h ****     }
 602:Core/Inc/arm_math.h **** 
 603:Core/Inc/arm_math.h ****     /* write output */
 604:Core/Inc/arm_math.h ****     *dst = out;
 605:Core/Inc/arm_math.h **** 
 606:Core/Inc/arm_math.h ****     /* return num of signbits of out = 1/in value */
 607:Core/Inc/arm_math.h ****     return (signBits + 1u);
 608:Core/Inc/arm_math.h ****   }
 609:Core/Inc/arm_math.h **** 
 610:Core/Inc/arm_math.h **** 
 611:Core/Inc/arm_math.h ****   /**
 612:Core/Inc/arm_math.h ****    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
 613:Core/Inc/arm_math.h ****    */
 614:Core/Inc/arm_math.h ****   static __INLINE uint32_t arm_recip_q15(
 615:Core/Inc/arm_math.h ****   q15_t in,
 616:Core/Inc/arm_math.h ****   q15_t * dst,
 617:Core/Inc/arm_math.h ****   q15_t * pRecipTable)
 618:Core/Inc/arm_math.h ****   {
 619:Core/Inc/arm_math.h ****     q15_t out = 0;
 620:Core/Inc/arm_math.h ****     uint32_t tempVal = 0;
 621:Core/Inc/arm_math.h ****     uint32_t index = 0, i = 0;
 622:Core/Inc/arm_math.h ****     uint32_t signBits = 0;
 623:Core/Inc/arm_math.h **** 
 624:Core/Inc/arm_math.h ****     if(in > 0)
 625:Core/Inc/arm_math.h ****     {
 626:Core/Inc/arm_math.h ****       signBits = ((uint32_t)(__CLZ( in) - 17));
 627:Core/Inc/arm_math.h ****     }
 628:Core/Inc/arm_math.h ****     else
 629:Core/Inc/arm_math.h ****     {
 630:Core/Inc/arm_math.h ****       signBits = ((uint32_t)(__CLZ(-in) - 17));
 631:Core/Inc/arm_math.h ****     }
 632:Core/Inc/arm_math.h **** 
 633:Core/Inc/arm_math.h ****     /* Convert input sample to 1.15 format */
 634:Core/Inc/arm_math.h ****     in = (in << signBits);
 635:Core/Inc/arm_math.h **** 
 636:Core/Inc/arm_math.h ****     /* calculation of index for initial approximated Val */
 637:Core/Inc/arm_math.h ****     index = (uint32_t)(in >>  8);
 638:Core/Inc/arm_math.h ****     index = (index & INDEX_MASK);
 639:Core/Inc/arm_math.h **** 
 640:Core/Inc/arm_math.h ****     /*      1.15 with exp 1  */
 641:Core/Inc/arm_math.h ****     out = pRecipTable[index];
 642:Core/Inc/arm_math.h **** 
 643:Core/Inc/arm_math.h ****     /* calculation of reciprocal value */
 644:Core/Inc/arm_math.h ****     /* running approximation for two iterations */
 645:Core/Inc/arm_math.h ****     for (i = 0u; i < 2u; i++)
 646:Core/Inc/arm_math.h ****     {
 647:Core/Inc/arm_math.h ****       tempVal = (uint32_t) (((q31_t) in * out) >> 15);
 648:Core/Inc/arm_math.h ****       tempVal = 0x7FFFu - tempVal;
ARM GAS  /tmp/ccpEjOub.s 			page 14


 649:Core/Inc/arm_math.h ****       /*      1.15 with exp 1 */
 650:Core/Inc/arm_math.h ****       out = (q15_t) (((q31_t) out * tempVal) >> 14);
 651:Core/Inc/arm_math.h ****       /* out = clip_q31_to_q15(((q31_t) out * tempVal) >> 14); */
 652:Core/Inc/arm_math.h ****     }
 653:Core/Inc/arm_math.h **** 
 654:Core/Inc/arm_math.h ****     /* write output */
 655:Core/Inc/arm_math.h ****     *dst = out;
 656:Core/Inc/arm_math.h **** 
 657:Core/Inc/arm_math.h ****     /* return num of signbits of out = 1/in value */
 658:Core/Inc/arm_math.h ****     return (signBits + 1);
 659:Core/Inc/arm_math.h ****   }
 660:Core/Inc/arm_math.h **** 
 661:Core/Inc/arm_math.h **** 
 662:Core/Inc/arm_math.h ****   /*
 663:Core/Inc/arm_math.h ****    * @brief C custom defined intrinisic function for only M0 processors
 664:Core/Inc/arm_math.h ****    */
 665:Core/Inc/arm_math.h **** #if defined(ARM_MATH_CM0_FAMILY)
 666:Core/Inc/arm_math.h ****   static __INLINE q31_t __SSAT(
 667:Core/Inc/arm_math.h ****   q31_t x,
 668:Core/Inc/arm_math.h ****   uint32_t y)
 669:Core/Inc/arm_math.h ****   {
 670:Core/Inc/arm_math.h ****     int32_t posMax, negMin;
 671:Core/Inc/arm_math.h ****     uint32_t i;
 672:Core/Inc/arm_math.h **** 
 673:Core/Inc/arm_math.h ****     posMax = 1;
 674:Core/Inc/arm_math.h ****     for (i = 0; i < (y - 1); i++)
 675:Core/Inc/arm_math.h ****     {
 676:Core/Inc/arm_math.h ****       posMax = posMax * 2;
 677:Core/Inc/arm_math.h ****     }
 678:Core/Inc/arm_math.h **** 
 679:Core/Inc/arm_math.h ****     if(x > 0)
 680:Core/Inc/arm_math.h ****     {
 681:Core/Inc/arm_math.h ****       posMax = (posMax - 1);
 682:Core/Inc/arm_math.h **** 
 683:Core/Inc/arm_math.h ****       if(x > posMax)
 684:Core/Inc/arm_math.h ****       {
 685:Core/Inc/arm_math.h ****         x = posMax;
 686:Core/Inc/arm_math.h ****       }
 687:Core/Inc/arm_math.h ****     }
 688:Core/Inc/arm_math.h ****     else
 689:Core/Inc/arm_math.h ****     {
 690:Core/Inc/arm_math.h ****       negMin = -posMax;
 691:Core/Inc/arm_math.h **** 
 692:Core/Inc/arm_math.h ****       if(x < negMin)
 693:Core/Inc/arm_math.h ****       {
 694:Core/Inc/arm_math.h ****         x = negMin;
 695:Core/Inc/arm_math.h ****       }
 696:Core/Inc/arm_math.h ****     }
 697:Core/Inc/arm_math.h ****     return (x);
 698:Core/Inc/arm_math.h ****   }
 699:Core/Inc/arm_math.h **** #endif /* end of ARM_MATH_CM0_FAMILY */
 700:Core/Inc/arm_math.h **** 
 701:Core/Inc/arm_math.h **** 
 702:Core/Inc/arm_math.h ****   /*
 703:Core/Inc/arm_math.h ****    * @brief C custom defined intrinsic function for M3 and M0 processors
 704:Core/Inc/arm_math.h ****    */
 705:Core/Inc/arm_math.h **** #if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
ARM GAS  /tmp/ccpEjOub.s 			page 15


 706:Core/Inc/arm_math.h **** 
 707:Core/Inc/arm_math.h ****   /*
 708:Core/Inc/arm_math.h ****    * @brief C custom defined QADD8 for M3 and M0 processors
 709:Core/Inc/arm_math.h ****    */
 710:Core/Inc/arm_math.h ****   static __INLINE uint32_t __QADD8(
 711:Core/Inc/arm_math.h ****   uint32_t x,
 712:Core/Inc/arm_math.h ****   uint32_t y)
 713:Core/Inc/arm_math.h ****   {
 714:Core/Inc/arm_math.h ****     q31_t r, s, t, u;
 715:Core/Inc/arm_math.h **** 
 716:Core/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) + (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 717:Core/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) + (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 718:Core/Inc/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) + (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 719:Core/Inc/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) + (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 720:Core/Inc/arm_math.h **** 
 721:Core/Inc/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 722:Core/Inc/arm_math.h ****   }
 723:Core/Inc/arm_math.h **** 
 724:Core/Inc/arm_math.h **** 
 725:Core/Inc/arm_math.h ****   /*
 726:Core/Inc/arm_math.h ****    * @brief C custom defined QSUB8 for M3 and M0 processors
 727:Core/Inc/arm_math.h ****    */
 728:Core/Inc/arm_math.h ****   static __INLINE uint32_t __QSUB8(
 729:Core/Inc/arm_math.h ****   uint32_t x,
 730:Core/Inc/arm_math.h ****   uint32_t y)
 731:Core/Inc/arm_math.h ****   {
 732:Core/Inc/arm_math.h ****     q31_t r, s, t, u;
 733:Core/Inc/arm_math.h **** 
 734:Core/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 24) >> 24) - (((q31_t)y << 24) >> 24)), 8) & (int32_t)0x000000FF;
 735:Core/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x << 16) >> 24) - (((q31_t)y << 16) >> 24)), 8) & (int32_t)0x000000FF;
 736:Core/Inc/arm_math.h ****     t = __SSAT(((((q31_t)x <<  8) >> 24) - (((q31_t)y <<  8) >> 24)), 8) & (int32_t)0x000000FF;
 737:Core/Inc/arm_math.h ****     u = __SSAT(((((q31_t)x      ) >> 24) - (((q31_t)y      ) >> 24)), 8) & (int32_t)0x000000FF;
 738:Core/Inc/arm_math.h **** 
 739:Core/Inc/arm_math.h ****     return ((uint32_t)((u << 24) | (t << 16) | (s <<  8) | (r      )));
 740:Core/Inc/arm_math.h ****   }
 741:Core/Inc/arm_math.h **** 
 742:Core/Inc/arm_math.h **** 
 743:Core/Inc/arm_math.h ****   /*
 744:Core/Inc/arm_math.h ****    * @brief C custom defined QADD16 for M3 and M0 processors
 745:Core/Inc/arm_math.h ****    */
 746:Core/Inc/arm_math.h ****   static __INLINE uint32_t __QADD16(
 747:Core/Inc/arm_math.h ****   uint32_t x,
 748:Core/Inc/arm_math.h ****   uint32_t y)
 749:Core/Inc/arm_math.h ****   {
 750:Core/Inc/arm_math.h **** /*  q31_t r,     s;  without initialisation 'arm_offset_q15 test' fails  but 'intrinsic' tests pass
 751:Core/Inc/arm_math.h ****     q31_t r = 0, s = 0;
 752:Core/Inc/arm_math.h **** 
 753:Core/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 754:Core/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 755:Core/Inc/arm_math.h **** 
 756:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 757:Core/Inc/arm_math.h ****   }
 758:Core/Inc/arm_math.h **** 
 759:Core/Inc/arm_math.h **** 
 760:Core/Inc/arm_math.h ****   /*
 761:Core/Inc/arm_math.h ****    * @brief C custom defined SHADD16 for M3 and M0 processors
 762:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 16


 763:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SHADD16(
 764:Core/Inc/arm_math.h ****   uint32_t x,
 765:Core/Inc/arm_math.h ****   uint32_t y)
 766:Core/Inc/arm_math.h ****   {
 767:Core/Inc/arm_math.h ****     q31_t r, s;
 768:Core/Inc/arm_math.h **** 
 769:Core/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 770:Core/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 771:Core/Inc/arm_math.h **** 
 772:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 773:Core/Inc/arm_math.h ****   }
 774:Core/Inc/arm_math.h **** 
 775:Core/Inc/arm_math.h **** 
 776:Core/Inc/arm_math.h ****   /*
 777:Core/Inc/arm_math.h ****    * @brief C custom defined QSUB16 for M3 and M0 processors
 778:Core/Inc/arm_math.h ****    */
 779:Core/Inc/arm_math.h ****   static __INLINE uint32_t __QSUB16(
 780:Core/Inc/arm_math.h ****   uint32_t x,
 781:Core/Inc/arm_math.h ****   uint32_t y)
 782:Core/Inc/arm_math.h ****   {
 783:Core/Inc/arm_math.h ****     q31_t r, s;
 784:Core/Inc/arm_math.h **** 
 785:Core/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 786:Core/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 787:Core/Inc/arm_math.h **** 
 788:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 789:Core/Inc/arm_math.h ****   }
 790:Core/Inc/arm_math.h **** 
 791:Core/Inc/arm_math.h **** 
 792:Core/Inc/arm_math.h ****   /*
 793:Core/Inc/arm_math.h ****    * @brief C custom defined SHSUB16 for M3 and M0 processors
 794:Core/Inc/arm_math.h ****    */
 795:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SHSUB16(
 796:Core/Inc/arm_math.h ****   uint32_t x,
 797:Core/Inc/arm_math.h ****   uint32_t y)
 798:Core/Inc/arm_math.h ****   {
 799:Core/Inc/arm_math.h ****     q31_t r, s;
 800:Core/Inc/arm_math.h **** 
 801:Core/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 802:Core/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 803:Core/Inc/arm_math.h **** 
 804:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 805:Core/Inc/arm_math.h ****   }
 806:Core/Inc/arm_math.h **** 
 807:Core/Inc/arm_math.h **** 
 808:Core/Inc/arm_math.h ****   /*
 809:Core/Inc/arm_math.h ****    * @brief C custom defined QASX for M3 and M0 processors
 810:Core/Inc/arm_math.h ****    */
 811:Core/Inc/arm_math.h ****   static __INLINE uint32_t __QASX(
 812:Core/Inc/arm_math.h ****   uint32_t x,
 813:Core/Inc/arm_math.h ****   uint32_t y)
 814:Core/Inc/arm_math.h ****   {
 815:Core/Inc/arm_math.h ****     q31_t r, s;
 816:Core/Inc/arm_math.h **** 
 817:Core/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 818:Core/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 819:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 17


 820:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 821:Core/Inc/arm_math.h ****   }
 822:Core/Inc/arm_math.h **** 
 823:Core/Inc/arm_math.h **** 
 824:Core/Inc/arm_math.h ****   /*
 825:Core/Inc/arm_math.h ****    * @brief C custom defined SHASX for M3 and M0 processors
 826:Core/Inc/arm_math.h ****    */
 827:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SHASX(
 828:Core/Inc/arm_math.h ****   uint32_t x,
 829:Core/Inc/arm_math.h ****   uint32_t y)
 830:Core/Inc/arm_math.h ****   {
 831:Core/Inc/arm_math.h ****     q31_t r, s;
 832:Core/Inc/arm_math.h **** 
 833:Core/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) - (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 834:Core/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) + (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 835:Core/Inc/arm_math.h **** 
 836:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 837:Core/Inc/arm_math.h ****   }
 838:Core/Inc/arm_math.h **** 
 839:Core/Inc/arm_math.h **** 
 840:Core/Inc/arm_math.h ****   /*
 841:Core/Inc/arm_math.h ****    * @brief C custom defined QSAX for M3 and M0 processors
 842:Core/Inc/arm_math.h ****    */
 843:Core/Inc/arm_math.h ****   static __INLINE uint32_t __QSAX(
 844:Core/Inc/arm_math.h ****   uint32_t x,
 845:Core/Inc/arm_math.h ****   uint32_t y)
 846:Core/Inc/arm_math.h ****   {
 847:Core/Inc/arm_math.h ****     q31_t r, s;
 848:Core/Inc/arm_math.h **** 
 849:Core/Inc/arm_math.h ****     r = __SSAT(((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)), 16) & (int32_t)0x0000FFFF;
 850:Core/Inc/arm_math.h ****     s = __SSAT(((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)), 16) & (int32_t)0x0000FFFF;
 851:Core/Inc/arm_math.h **** 
 852:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 853:Core/Inc/arm_math.h ****   }
 854:Core/Inc/arm_math.h **** 
 855:Core/Inc/arm_math.h **** 
 856:Core/Inc/arm_math.h ****   /*
 857:Core/Inc/arm_math.h ****    * @brief C custom defined SHSAX for M3 and M0 processors
 858:Core/Inc/arm_math.h ****    */
 859:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SHSAX(
 860:Core/Inc/arm_math.h ****   uint32_t x,
 861:Core/Inc/arm_math.h ****   uint32_t y)
 862:Core/Inc/arm_math.h ****   {
 863:Core/Inc/arm_math.h ****     q31_t r, s;
 864:Core/Inc/arm_math.h **** 
 865:Core/Inc/arm_math.h ****     r = (((((q31_t)x << 16) >> 16) + (((q31_t)y      ) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 866:Core/Inc/arm_math.h ****     s = (((((q31_t)x      ) >> 16) - (((q31_t)y << 16) >> 16)) >> 1) & (int32_t)0x0000FFFF;
 867:Core/Inc/arm_math.h **** 
 868:Core/Inc/arm_math.h ****     return ((uint32_t)((s << 16) | (r      )));
 869:Core/Inc/arm_math.h ****   }
 870:Core/Inc/arm_math.h **** 
 871:Core/Inc/arm_math.h **** 
 872:Core/Inc/arm_math.h ****   /*
 873:Core/Inc/arm_math.h ****    * @brief C custom defined SMUSDX for M3 and M0 processors
 874:Core/Inc/arm_math.h ****    */
 875:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMUSDX(
 876:Core/Inc/arm_math.h ****   uint32_t x,
ARM GAS  /tmp/ccpEjOub.s 			page 18


 877:Core/Inc/arm_math.h ****   uint32_t y)
 878:Core/Inc/arm_math.h ****   {
 879:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 880:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 881:Core/Inc/arm_math.h ****   }
 882:Core/Inc/arm_math.h **** 
 883:Core/Inc/arm_math.h ****   /*
 884:Core/Inc/arm_math.h ****    * @brief C custom defined SMUADX for M3 and M0 processors
 885:Core/Inc/arm_math.h ****    */
 886:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMUADX(
 887:Core/Inc/arm_math.h ****   uint32_t x,
 888:Core/Inc/arm_math.h ****   uint32_t y)
 889:Core/Inc/arm_math.h ****   {
 890:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 891:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16))   ));
 892:Core/Inc/arm_math.h ****   }
 893:Core/Inc/arm_math.h **** 
 894:Core/Inc/arm_math.h **** 
 895:Core/Inc/arm_math.h ****   /*
 896:Core/Inc/arm_math.h ****    * @brief C custom defined QADD for M3 and M0 processors
 897:Core/Inc/arm_math.h ****    */
 898:Core/Inc/arm_math.h ****   static __INLINE int32_t __QADD(
 899:Core/Inc/arm_math.h ****   int32_t x,
 900:Core/Inc/arm_math.h ****   int32_t y)
 901:Core/Inc/arm_math.h ****   {
  97              		.loc 1 901 3
  98              		.cfi_startproc
  99              		@ args = 0, pretend = 0, frame = 8
 100              		@ frame_needed = 1, uses_anonymous_args = 0
 101 0000 B0B5     		push	{r4, r5, r7, lr}
 102              	.LCFI6:
 103              		.cfi_def_cfa_offset 16
 104              		.cfi_offset 4, -16
 105              		.cfi_offset 5, -12
 106              		.cfi_offset 7, -8
 107              		.cfi_offset 14, -4
 108 0002 82B0     		sub	sp, sp, #8
 109              	.LCFI7:
 110              		.cfi_def_cfa_offset 24
 111 0004 00AF     		add	r7, sp, #0
 112              	.LCFI8:
 113              		.cfi_def_cfa_register 7
 114 0006 7860     		str	r0, [r7, #4]
 115 0008 3960     		str	r1, [r7]
 902:Core/Inc/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x + (q31_t)y)));
 116              		.loc 1 902 39
 117 000a 7B68     		ldr	r3, [r7, #4]
 118 000c 1846     		mov	r0, r3
 119 000e 4FEAE071 		asr	r1, r0, #31
 120              		.loc 1 902 50
 121 0012 3B68     		ldr	r3, [r7]
 122 0014 1A46     		mov	r2, r3
 123 0016 4FEAE273 		asr	r3, r2, #31
 124              		.loc 1 902 23
 125 001a 8418     		adds	r4, r0, r2
 126 001c 41EB0305 		adc	r5, r1, r3
 127 0020 2046     		mov	r0, r4
ARM GAS  /tmp/ccpEjOub.s 			page 19


 128 0022 2946     		mov	r1, r5
 129 0024 FFF7FEFF 		bl	clip_q63_to_q31
 130 0028 0346     		mov	r3, r0
 903:Core/Inc/arm_math.h ****   }
 131              		.loc 1 903 3
 132 002a 1846     		mov	r0, r3
 133 002c 0837     		adds	r7, r7, #8
 134              	.LCFI9:
 135              		.cfi_def_cfa_offset 16
 136 002e BD46     		mov	sp, r7
 137              	.LCFI10:
 138              		.cfi_def_cfa_register 13
 139              		@ sp needed
 140 0030 B0BD     		pop	{r4, r5, r7, pc}
 141              		.cfi_endproc
 142              	.LFE63:
 144              		.section	.text.__QSUB,"ax",%progbits
 145              		.align	1
 146              		.syntax unified
 147              		.thumb
 148              		.thumb_func
 149              		.fpu softvfp
 151              	__QSUB:
 152              	.LFB64:
 904:Core/Inc/arm_math.h **** 
 905:Core/Inc/arm_math.h **** 
 906:Core/Inc/arm_math.h ****   /*
 907:Core/Inc/arm_math.h ****    * @brief C custom defined QSUB for M3 and M0 processors
 908:Core/Inc/arm_math.h ****    */
 909:Core/Inc/arm_math.h ****   static __INLINE int32_t __QSUB(
 910:Core/Inc/arm_math.h ****   int32_t x,
 911:Core/Inc/arm_math.h ****   int32_t y)
 912:Core/Inc/arm_math.h ****   {
 153              		.loc 1 912 3
 154              		.cfi_startproc
 155              		@ args = 0, pretend = 0, frame = 8
 156              		@ frame_needed = 1, uses_anonymous_args = 0
 157 0000 B0B5     		push	{r4, r5, r7, lr}
 158              	.LCFI11:
 159              		.cfi_def_cfa_offset 16
 160              		.cfi_offset 4, -16
 161              		.cfi_offset 5, -12
 162              		.cfi_offset 7, -8
 163              		.cfi_offset 14, -4
 164 0002 82B0     		sub	sp, sp, #8
 165              	.LCFI12:
 166              		.cfi_def_cfa_offset 24
 167 0004 00AF     		add	r7, sp, #0
 168              	.LCFI13:
 169              		.cfi_def_cfa_register 7
 170 0006 7860     		str	r0, [r7, #4]
 171 0008 3960     		str	r1, [r7]
 913:Core/Inc/arm_math.h ****     return ((int32_t)(clip_q63_to_q31((q63_t)x - (q31_t)y)));
 172              		.loc 1 913 39
 173 000a 7B68     		ldr	r3, [r7, #4]
 174 000c 1846     		mov	r0, r3
 175 000e 4FEAE071 		asr	r1, r0, #31
ARM GAS  /tmp/ccpEjOub.s 			page 20


 176              		.loc 1 913 50
 177 0012 3B68     		ldr	r3, [r7]
 178 0014 1A46     		mov	r2, r3
 179 0016 4FEAE273 		asr	r3, r2, #31
 180              		.loc 1 913 23
 181 001a 841A     		subs	r4, r0, r2
 182 001c 61EB0305 		sbc	r5, r1, r3
 183 0020 2046     		mov	r0, r4
 184 0022 2946     		mov	r1, r5
 185 0024 FFF7FEFF 		bl	clip_q63_to_q31
 186 0028 0346     		mov	r3, r0
 914:Core/Inc/arm_math.h ****   }
 187              		.loc 1 914 3
 188 002a 1846     		mov	r0, r3
 189 002c 0837     		adds	r7, r7, #8
 190              	.LCFI14:
 191              		.cfi_def_cfa_offset 16
 192 002e BD46     		mov	sp, r7
 193              	.LCFI15:
 194              		.cfi_def_cfa_register 13
 195              		@ sp needed
 196 0030 B0BD     		pop	{r4, r5, r7, pc}
 197              		.cfi_endproc
 198              	.LFE64:
 200              		.section	.text.arm_clarke_q31,"ax",%progbits
 201              		.align	1
 202              		.syntax unified
 203              		.thumb
 204              		.thumb_func
 205              		.fpu softvfp
 207              	arm_clarke_q31:
 208              	.LFB77:
 915:Core/Inc/arm_math.h **** 
 916:Core/Inc/arm_math.h **** 
 917:Core/Inc/arm_math.h ****   /*
 918:Core/Inc/arm_math.h ****    * @brief C custom defined SMLAD for M3 and M0 processors
 919:Core/Inc/arm_math.h ****    */
 920:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMLAD(
 921:Core/Inc/arm_math.h ****   uint32_t x,
 922:Core/Inc/arm_math.h ****   uint32_t y,
 923:Core/Inc/arm_math.h ****   uint32_t sum)
 924:Core/Inc/arm_math.h ****   {
 925:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 926:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 927:Core/Inc/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 928:Core/Inc/arm_math.h ****   }
 929:Core/Inc/arm_math.h **** 
 930:Core/Inc/arm_math.h **** 
 931:Core/Inc/arm_math.h ****   /*
 932:Core/Inc/arm_math.h ****    * @brief C custom defined SMLADX for M3 and M0 processors
 933:Core/Inc/arm_math.h ****    */
 934:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMLADX(
 935:Core/Inc/arm_math.h ****   uint32_t x,
 936:Core/Inc/arm_math.h ****   uint32_t y,
 937:Core/Inc/arm_math.h ****   uint32_t sum)
 938:Core/Inc/arm_math.h ****   {
 939:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
ARM GAS  /tmp/ccpEjOub.s 			page 21


 940:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 941:Core/Inc/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 942:Core/Inc/arm_math.h ****   }
 943:Core/Inc/arm_math.h **** 
 944:Core/Inc/arm_math.h **** 
 945:Core/Inc/arm_math.h ****   /*
 946:Core/Inc/arm_math.h ****    * @brief C custom defined SMLSDX for M3 and M0 processors
 947:Core/Inc/arm_math.h ****    */
 948:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMLSDX(
 949:Core/Inc/arm_math.h ****   uint32_t x,
 950:Core/Inc/arm_math.h ****   uint32_t y,
 951:Core/Inc/arm_math.h ****   uint32_t sum)
 952:Core/Inc/arm_math.h ****   {
 953:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) -
 954:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 955:Core/Inc/arm_math.h ****                        ( ((q31_t)sum    )                                  )   ));
 956:Core/Inc/arm_math.h ****   }
 957:Core/Inc/arm_math.h **** 
 958:Core/Inc/arm_math.h **** 
 959:Core/Inc/arm_math.h ****   /*
 960:Core/Inc/arm_math.h ****    * @brief C custom defined SMLALD for M3 and M0 processors
 961:Core/Inc/arm_math.h ****    */
 962:Core/Inc/arm_math.h ****   static __INLINE uint64_t __SMLALD(
 963:Core/Inc/arm_math.h ****   uint32_t x,
 964:Core/Inc/arm_math.h ****   uint32_t y,
 965:Core/Inc/arm_math.h ****   uint64_t sum)
 966:Core/Inc/arm_math.h ****   {
 967:Core/Inc/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) + ((q15_t) x * (q15_t) y)); */
 968:Core/Inc/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
 969:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16)) +
 970:Core/Inc/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 971:Core/Inc/arm_math.h ****   }
 972:Core/Inc/arm_math.h **** 
 973:Core/Inc/arm_math.h **** 
 974:Core/Inc/arm_math.h ****   /*
 975:Core/Inc/arm_math.h ****    * @brief C custom defined SMLALDX for M3 and M0 processors
 976:Core/Inc/arm_math.h ****    */
 977:Core/Inc/arm_math.h ****   static __INLINE uint64_t __SMLALDX(
 978:Core/Inc/arm_math.h ****   uint32_t x,
 979:Core/Inc/arm_math.h ****   uint32_t y,
 980:Core/Inc/arm_math.h ****   uint64_t sum)
 981:Core/Inc/arm_math.h ****   {
 982:Core/Inc/arm_math.h **** /*  return (sum + ((q15_t) (x >> 16) * (q15_t) y)) + ((q15_t) x * (q15_t) (y >> 16)); */
 983:Core/Inc/arm_math.h ****     return ((uint64_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y      ) >> 16)) +
 984:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y << 16) >> 16)) +
 985:Core/Inc/arm_math.h ****                        ( ((q63_t)sum    )                                  )   ));
 986:Core/Inc/arm_math.h ****   }
 987:Core/Inc/arm_math.h **** 
 988:Core/Inc/arm_math.h **** 
 989:Core/Inc/arm_math.h ****   /*
 990:Core/Inc/arm_math.h ****    * @brief C custom defined SMUAD for M3 and M0 processors
 991:Core/Inc/arm_math.h ****    */
 992:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMUAD(
 993:Core/Inc/arm_math.h ****   uint32_t x,
 994:Core/Inc/arm_math.h ****   uint32_t y)
 995:Core/Inc/arm_math.h ****   {
 996:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) +
ARM GAS  /tmp/ccpEjOub.s 			page 22


 997:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
 998:Core/Inc/arm_math.h ****   }
 999:Core/Inc/arm_math.h **** 
1000:Core/Inc/arm_math.h **** 
1001:Core/Inc/arm_math.h ****   /*
1002:Core/Inc/arm_math.h ****    * @brief C custom defined SMUSD for M3 and M0 processors
1003:Core/Inc/arm_math.h ****    */
1004:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SMUSD(
1005:Core/Inc/arm_math.h ****   uint32_t x,
1006:Core/Inc/arm_math.h ****   uint32_t y)
1007:Core/Inc/arm_math.h ****   {
1008:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 16) >> 16) * (((q31_t)y << 16) >> 16)) -
1009:Core/Inc/arm_math.h ****                        ((((q31_t)x      ) >> 16) * (((q31_t)y      ) >> 16))   ));
1010:Core/Inc/arm_math.h ****   }
1011:Core/Inc/arm_math.h **** 
1012:Core/Inc/arm_math.h **** 
1013:Core/Inc/arm_math.h ****   /*
1014:Core/Inc/arm_math.h ****    * @brief C custom defined SXTB16 for M3 and M0 processors
1015:Core/Inc/arm_math.h ****    */
1016:Core/Inc/arm_math.h ****   static __INLINE uint32_t __SXTB16(
1017:Core/Inc/arm_math.h ****   uint32_t x)
1018:Core/Inc/arm_math.h ****   {
1019:Core/Inc/arm_math.h ****     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
1020:Core/Inc/arm_math.h ****                        ((((q31_t)x <<  8) >>  8) & (q31_t)0xFFFF0000)  ));
1021:Core/Inc/arm_math.h ****   }
1022:Core/Inc/arm_math.h **** 
1023:Core/Inc/arm_math.h **** #endif /* defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
1024:Core/Inc/arm_math.h **** 
1025:Core/Inc/arm_math.h **** 
1026:Core/Inc/arm_math.h ****   /**
1027:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q7 FIR filter.
1028:Core/Inc/arm_math.h ****    */
1029:Core/Inc/arm_math.h ****   typedef struct
1030:Core/Inc/arm_math.h ****   {
1031:Core/Inc/arm_math.h ****     uint16_t numTaps;        /**< number of filter coefficients in the filter. */
1032:Core/Inc/arm_math.h ****     q7_t *pState;            /**< points to the state variable array. The array is of length numTap
1033:Core/Inc/arm_math.h ****     q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*
1034:Core/Inc/arm_math.h ****   } arm_fir_instance_q7;
1035:Core/Inc/arm_math.h **** 
1036:Core/Inc/arm_math.h ****   /**
1037:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR filter.
1038:Core/Inc/arm_math.h ****    */
1039:Core/Inc/arm_math.h ****   typedef struct
1040:Core/Inc/arm_math.h ****   {
1041:Core/Inc/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1042:Core/Inc/arm_math.h ****     q15_t *pState;            /**< points to the state variable array. The array is of length numTa
1043:Core/Inc/arm_math.h ****     q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
1044:Core/Inc/arm_math.h ****   } arm_fir_instance_q15;
1045:Core/Inc/arm_math.h **** 
1046:Core/Inc/arm_math.h ****   /**
1047:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR filter.
1048:Core/Inc/arm_math.h ****    */
1049:Core/Inc/arm_math.h ****   typedef struct
1050:Core/Inc/arm_math.h ****   {
1051:Core/Inc/arm_math.h ****     uint16_t numTaps;         /**< number of filter coefficients in the filter. */
1052:Core/Inc/arm_math.h ****     q31_t *pState;            /**< points to the state variable array. The array is of length numTa
1053:Core/Inc/arm_math.h ****     q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.
ARM GAS  /tmp/ccpEjOub.s 			page 23


1054:Core/Inc/arm_math.h ****   } arm_fir_instance_q31;
1055:Core/Inc/arm_math.h **** 
1056:Core/Inc/arm_math.h ****   /**
1057:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR filter.
1058:Core/Inc/arm_math.h ****    */
1059:Core/Inc/arm_math.h ****   typedef struct
1060:Core/Inc/arm_math.h ****   {
1061:Core/Inc/arm_math.h ****     uint16_t numTaps;     /**< number of filter coefficients in the filter. */
1062:Core/Inc/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
1063:Core/Inc/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
1064:Core/Inc/arm_math.h ****   } arm_fir_instance_f32;
1065:Core/Inc/arm_math.h **** 
1066:Core/Inc/arm_math.h **** 
1067:Core/Inc/arm_math.h ****   /**
1068:Core/Inc/arm_math.h ****    * @brief Processing function for the Q7 FIR filter.
1069:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
1070:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1071:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1072:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1073:Core/Inc/arm_math.h ****    */
1074:Core/Inc/arm_math.h ****   void arm_fir_q7(
1075:Core/Inc/arm_math.h ****   const arm_fir_instance_q7 * S,
1076:Core/Inc/arm_math.h ****   q7_t * pSrc,
1077:Core/Inc/arm_math.h ****   q7_t * pDst,
1078:Core/Inc/arm_math.h ****   uint32_t blockSize);
1079:Core/Inc/arm_math.h **** 
1080:Core/Inc/arm_math.h **** 
1081:Core/Inc/arm_math.h ****   /**
1082:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q7 FIR filter.
1083:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 FIR structure.
1084:Core/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1085:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1086:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1087:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed.
1088:Core/Inc/arm_math.h ****    */
1089:Core/Inc/arm_math.h ****   void arm_fir_init_q7(
1090:Core/Inc/arm_math.h ****   arm_fir_instance_q7 * S,
1091:Core/Inc/arm_math.h ****   uint16_t numTaps,
1092:Core/Inc/arm_math.h ****   q7_t * pCoeffs,
1093:Core/Inc/arm_math.h ****   q7_t * pState,
1094:Core/Inc/arm_math.h ****   uint32_t blockSize);
1095:Core/Inc/arm_math.h **** 
1096:Core/Inc/arm_math.h **** 
1097:Core/Inc/arm_math.h ****   /**
1098:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR filter.
1099:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR structure.
1100:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1101:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1102:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1103:Core/Inc/arm_math.h ****    */
1104:Core/Inc/arm_math.h ****   void arm_fir_q15(
1105:Core/Inc/arm_math.h ****   const arm_fir_instance_q15 * S,
1106:Core/Inc/arm_math.h ****   q15_t * pSrc,
1107:Core/Inc/arm_math.h ****   q15_t * pDst,
1108:Core/Inc/arm_math.h ****   uint32_t blockSize);
1109:Core/Inc/arm_math.h **** 
1110:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 24


1111:Core/Inc/arm_math.h ****   /**
1112:Core/Inc/arm_math.h ****    * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
1113:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
1114:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1115:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1116:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1117:Core/Inc/arm_math.h ****    */
1118:Core/Inc/arm_math.h ****   void arm_fir_fast_q15(
1119:Core/Inc/arm_math.h ****   const arm_fir_instance_q15 * S,
1120:Core/Inc/arm_math.h ****   q15_t * pSrc,
1121:Core/Inc/arm_math.h ****   q15_t * pDst,
1122:Core/Inc/arm_math.h ****   uint32_t blockSize);
1123:Core/Inc/arm_math.h **** 
1124:Core/Inc/arm_math.h **** 
1125:Core/Inc/arm_math.h ****   /**
1126:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 FIR filter.
1127:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR filter structure.
1128:Core/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greate
1129:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1130:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1131:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1132:Core/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARG
1133:Core/Inc/arm_math.h ****    * <code>numTaps</code> is not a supported value.
1134:Core/Inc/arm_math.h ****    */
1135:Core/Inc/arm_math.h ****   arm_status arm_fir_init_q15(
1136:Core/Inc/arm_math.h ****   arm_fir_instance_q15 * S,
1137:Core/Inc/arm_math.h ****   uint16_t numTaps,
1138:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
1139:Core/Inc/arm_math.h ****   q15_t * pState,
1140:Core/Inc/arm_math.h ****   uint32_t blockSize);
1141:Core/Inc/arm_math.h **** 
1142:Core/Inc/arm_math.h **** 
1143:Core/Inc/arm_math.h ****   /**
1144:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR filter.
1145:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR filter structure.
1146:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1147:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1148:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1149:Core/Inc/arm_math.h ****    */
1150:Core/Inc/arm_math.h ****   void arm_fir_q31(
1151:Core/Inc/arm_math.h ****   const arm_fir_instance_q31 * S,
1152:Core/Inc/arm_math.h ****   q31_t * pSrc,
1153:Core/Inc/arm_math.h ****   q31_t * pDst,
1154:Core/Inc/arm_math.h ****   uint32_t blockSize);
1155:Core/Inc/arm_math.h **** 
1156:Core/Inc/arm_math.h **** 
1157:Core/Inc/arm_math.h ****   /**
1158:Core/Inc/arm_math.h ****    * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
1159:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR structure.
1160:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1161:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1162:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1163:Core/Inc/arm_math.h ****    */
1164:Core/Inc/arm_math.h ****   void arm_fir_fast_q31(
1165:Core/Inc/arm_math.h ****   const arm_fir_instance_q31 * S,
1166:Core/Inc/arm_math.h ****   q31_t * pSrc,
1167:Core/Inc/arm_math.h ****   q31_t * pDst,
ARM GAS  /tmp/ccpEjOub.s 			page 25


1168:Core/Inc/arm_math.h ****   uint32_t blockSize);
1169:Core/Inc/arm_math.h **** 
1170:Core/Inc/arm_math.h **** 
1171:Core/Inc/arm_math.h ****   /**
1172:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 FIR filter.
1173:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR structure.
1174:Core/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1175:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1176:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1177:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1178:Core/Inc/arm_math.h ****    */
1179:Core/Inc/arm_math.h ****   void arm_fir_init_q31(
1180:Core/Inc/arm_math.h ****   arm_fir_instance_q31 * S,
1181:Core/Inc/arm_math.h ****   uint16_t numTaps,
1182:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
1183:Core/Inc/arm_math.h ****   q31_t * pState,
1184:Core/Inc/arm_math.h ****   uint32_t blockSize);
1185:Core/Inc/arm_math.h **** 
1186:Core/Inc/arm_math.h **** 
1187:Core/Inc/arm_math.h ****   /**
1188:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR filter.
1189:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR structure.
1190:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1191:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1192:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1193:Core/Inc/arm_math.h ****    */
1194:Core/Inc/arm_math.h ****   void arm_fir_f32(
1195:Core/Inc/arm_math.h ****   const arm_fir_instance_f32 * S,
1196:Core/Inc/arm_math.h ****   float32_t * pSrc,
1197:Core/Inc/arm_math.h ****   float32_t * pDst,
1198:Core/Inc/arm_math.h ****   uint32_t blockSize);
1199:Core/Inc/arm_math.h **** 
1200:Core/Inc/arm_math.h **** 
1201:Core/Inc/arm_math.h ****   /**
1202:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point FIR filter.
1203:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR filter structure.
1204:Core/Inc/arm_math.h ****    * @param[in]     numTaps    Number of filter coefficients in the filter.
1205:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1206:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1207:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that are processed at a time.
1208:Core/Inc/arm_math.h ****    */
1209:Core/Inc/arm_math.h ****   void arm_fir_init_f32(
1210:Core/Inc/arm_math.h ****   arm_fir_instance_f32 * S,
1211:Core/Inc/arm_math.h ****   uint16_t numTaps,
1212:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
1213:Core/Inc/arm_math.h ****   float32_t * pState,
1214:Core/Inc/arm_math.h ****   uint32_t blockSize);
1215:Core/Inc/arm_math.h **** 
1216:Core/Inc/arm_math.h **** 
1217:Core/Inc/arm_math.h ****   /**
1218:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 Biquad cascade filter.
1219:Core/Inc/arm_math.h ****    */
1220:Core/Inc/arm_math.h ****   typedef struct
1221:Core/Inc/arm_math.h ****   {
1222:Core/Inc/arm_math.h ****     int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*num
1223:Core/Inc/arm_math.h ****     q15_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1224:Core/Inc/arm_math.h ****     q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
ARM GAS  /tmp/ccpEjOub.s 			page 26


1225:Core/Inc/arm_math.h ****     int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
1226:Core/Inc/arm_math.h ****   } arm_biquad_casd_df1_inst_q15;
1227:Core/Inc/arm_math.h **** 
1228:Core/Inc/arm_math.h ****   /**
1229:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 Biquad cascade filter.
1230:Core/Inc/arm_math.h ****    */
1231:Core/Inc/arm_math.h ****   typedef struct
1232:Core/Inc/arm_math.h ****   {
1233:Core/Inc/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1234:Core/Inc/arm_math.h ****     q31_t *pState;           /**< Points to the array of state coefficients.  The array is of lengt
1235:Core/Inc/arm_math.h ****     q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*nu
1236:Core/Inc/arm_math.h ****     uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
1237:Core/Inc/arm_math.h ****   } arm_biquad_casd_df1_inst_q31;
1238:Core/Inc/arm_math.h **** 
1239:Core/Inc/arm_math.h ****   /**
1240:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point Biquad cascade filter.
1241:Core/Inc/arm_math.h ****    */
1242:Core/Inc/arm_math.h ****   typedef struct
1243:Core/Inc/arm_math.h ****   {
1244:Core/Inc/arm_math.h ****     uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*num
1245:Core/Inc/arm_math.h ****     float32_t *pState;       /**< Points to the array of state coefficients.  The array is of lengt
1246:Core/Inc/arm_math.h ****     float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*nu
1247:Core/Inc/arm_math.h ****   } arm_biquad_casd_df1_inst_f32;
1248:Core/Inc/arm_math.h **** 
1249:Core/Inc/arm_math.h **** 
1250:Core/Inc/arm_math.h ****   /**
1251:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 Biquad cascade filter.
1252:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1253:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1254:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1255:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1256:Core/Inc/arm_math.h ****    */
1257:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_q15(
1258:Core/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1259:Core/Inc/arm_math.h ****   q15_t * pSrc,
1260:Core/Inc/arm_math.h ****   q15_t * pDst,
1261:Core/Inc/arm_math.h ****   uint32_t blockSize);
1262:Core/Inc/arm_math.h **** 
1263:Core/Inc/arm_math.h **** 
1264:Core/Inc/arm_math.h ****   /**
1265:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 Biquad cascade filter.
1266:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 Biquad cascade structure.
1267:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1268:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1269:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1270:Core/Inc/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1271:Core/Inc/arm_math.h ****    */
1272:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_init_q15(
1273:Core/Inc/arm_math.h ****   arm_biquad_casd_df1_inst_q15 * S,
1274:Core/Inc/arm_math.h ****   uint8_t numStages,
1275:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
1276:Core/Inc/arm_math.h ****   q15_t * pState,
1277:Core/Inc/arm_math.h ****   int8_t postShift);
1278:Core/Inc/arm_math.h **** 
1279:Core/Inc/arm_math.h **** 
1280:Core/Inc/arm_math.h ****   /**
1281:Core/Inc/arm_math.h ****    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-
ARM GAS  /tmp/ccpEjOub.s 			page 27


1282:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
1283:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1284:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1285:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1286:Core/Inc/arm_math.h ****    */
1287:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_fast_q15(
1288:Core/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q15 * S,
1289:Core/Inc/arm_math.h ****   q15_t * pSrc,
1290:Core/Inc/arm_math.h ****   q15_t * pDst,
1291:Core/Inc/arm_math.h ****   uint32_t blockSize);
1292:Core/Inc/arm_math.h **** 
1293:Core/Inc/arm_math.h **** 
1294:Core/Inc/arm_math.h ****   /**
1295:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 Biquad cascade filter
1296:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1297:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1298:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1299:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1300:Core/Inc/arm_math.h ****    */
1301:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_q31(
1302:Core/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1303:Core/Inc/arm_math.h ****   q31_t * pSrc,
1304:Core/Inc/arm_math.h ****   q31_t * pDst,
1305:Core/Inc/arm_math.h ****   uint32_t blockSize);
1306:Core/Inc/arm_math.h **** 
1307:Core/Inc/arm_math.h **** 
1308:Core/Inc/arm_math.h ****   /**
1309:Core/Inc/arm_math.h ****    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-
1310:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 Biquad cascade structure.
1311:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1312:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1313:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1314:Core/Inc/arm_math.h ****    */
1315:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_fast_q31(
1316:Core/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_q31 * S,
1317:Core/Inc/arm_math.h ****   q31_t * pSrc,
1318:Core/Inc/arm_math.h ****   q31_t * pDst,
1319:Core/Inc/arm_math.h ****   uint32_t blockSize);
1320:Core/Inc/arm_math.h **** 
1321:Core/Inc/arm_math.h **** 
1322:Core/Inc/arm_math.h ****   /**
1323:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 Biquad cascade filter.
1324:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 Biquad cascade structure.
1325:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1326:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1327:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1328:Core/Inc/arm_math.h ****    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficie
1329:Core/Inc/arm_math.h ****    */
1330:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_init_q31(
1331:Core/Inc/arm_math.h ****   arm_biquad_casd_df1_inst_q31 * S,
1332:Core/Inc/arm_math.h ****   uint8_t numStages,
1333:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
1334:Core/Inc/arm_math.h ****   q31_t * pState,
1335:Core/Inc/arm_math.h ****   int8_t postShift);
1336:Core/Inc/arm_math.h **** 
1337:Core/Inc/arm_math.h **** 
1338:Core/Inc/arm_math.h ****   /**
ARM GAS  /tmp/ccpEjOub.s 			page 28


1339:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point Biquad cascade filter.
1340:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point Biquad cascade structure.
1341:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
1342:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
1343:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
1344:Core/Inc/arm_math.h ****    */
1345:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_f32(
1346:Core/Inc/arm_math.h ****   const arm_biquad_casd_df1_inst_f32 * S,
1347:Core/Inc/arm_math.h ****   float32_t * pSrc,
1348:Core/Inc/arm_math.h ****   float32_t * pDst,
1349:Core/Inc/arm_math.h ****   uint32_t blockSize);
1350:Core/Inc/arm_math.h **** 
1351:Core/Inc/arm_math.h **** 
1352:Core/Inc/arm_math.h ****   /**
1353:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point Biquad cascade filter.
1354:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point Biquad cascade structure
1355:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
1356:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
1357:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
1358:Core/Inc/arm_math.h ****    */
1359:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df1_init_f32(
1360:Core/Inc/arm_math.h ****   arm_biquad_casd_df1_inst_f32 * S,
1361:Core/Inc/arm_math.h ****   uint8_t numStages,
1362:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
1363:Core/Inc/arm_math.h ****   float32_t * pState);
1364:Core/Inc/arm_math.h **** 
1365:Core/Inc/arm_math.h **** 
1366:Core/Inc/arm_math.h ****   /**
1367:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1368:Core/Inc/arm_math.h ****    */
1369:Core/Inc/arm_math.h ****   typedef struct
1370:Core/Inc/arm_math.h ****   {
1371:Core/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1372:Core/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1373:Core/Inc/arm_math.h ****     float32_t *pData;     /**< points to the data of the matrix. */
1374:Core/Inc/arm_math.h ****   } arm_matrix_instance_f32;
1375:Core/Inc/arm_math.h **** 
1376:Core/Inc/arm_math.h **** 
1377:Core/Inc/arm_math.h ****   /**
1378:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point matrix structure.
1379:Core/Inc/arm_math.h ****    */
1380:Core/Inc/arm_math.h ****   typedef struct
1381:Core/Inc/arm_math.h ****   {
1382:Core/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1383:Core/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1384:Core/Inc/arm_math.h ****     float64_t *pData;     /**< points to the data of the matrix. */
1385:Core/Inc/arm_math.h ****   } arm_matrix_instance_f64;
1386:Core/Inc/arm_math.h **** 
1387:Core/Inc/arm_math.h ****   /**
1388:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 matrix structure.
1389:Core/Inc/arm_math.h ****    */
1390:Core/Inc/arm_math.h ****   typedef struct
1391:Core/Inc/arm_math.h ****   {
1392:Core/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1393:Core/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1394:Core/Inc/arm_math.h ****     q15_t *pData;         /**< points to the data of the matrix. */
1395:Core/Inc/arm_math.h ****   } arm_matrix_instance_q15;
ARM GAS  /tmp/ccpEjOub.s 			page 29


1396:Core/Inc/arm_math.h **** 
1397:Core/Inc/arm_math.h ****   /**
1398:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 matrix structure.
1399:Core/Inc/arm_math.h ****    */
1400:Core/Inc/arm_math.h ****   typedef struct
1401:Core/Inc/arm_math.h ****   {
1402:Core/Inc/arm_math.h ****     uint16_t numRows;     /**< number of rows of the matrix.     */
1403:Core/Inc/arm_math.h ****     uint16_t numCols;     /**< number of columns of the matrix.  */
1404:Core/Inc/arm_math.h ****     q31_t *pData;         /**< points to the data of the matrix. */
1405:Core/Inc/arm_math.h ****   } arm_matrix_instance_q31;
1406:Core/Inc/arm_math.h **** 
1407:Core/Inc/arm_math.h **** 
1408:Core/Inc/arm_math.h ****   /**
1409:Core/Inc/arm_math.h ****    * @brief Floating-point matrix addition.
1410:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1411:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1412:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1413:Core/Inc/arm_math.h ****    * @return     The function returns either
1414:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1415:Core/Inc/arm_math.h ****    */
1416:Core/Inc/arm_math.h ****   arm_status arm_mat_add_f32(
1417:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1418:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1419:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1420:Core/Inc/arm_math.h **** 
1421:Core/Inc/arm_math.h **** 
1422:Core/Inc/arm_math.h ****   /**
1423:Core/Inc/arm_math.h ****    * @brief Q15 matrix addition.
1424:Core/Inc/arm_math.h ****    * @param[in]   pSrcA  points to the first input matrix structure
1425:Core/Inc/arm_math.h ****    * @param[in]   pSrcB  points to the second input matrix structure
1426:Core/Inc/arm_math.h ****    * @param[out]  pDst   points to output matrix structure
1427:Core/Inc/arm_math.h ****    * @return     The function returns either
1428:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1429:Core/Inc/arm_math.h ****    */
1430:Core/Inc/arm_math.h ****   arm_status arm_mat_add_q15(
1431:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1432:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1433:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1434:Core/Inc/arm_math.h **** 
1435:Core/Inc/arm_math.h **** 
1436:Core/Inc/arm_math.h ****   /**
1437:Core/Inc/arm_math.h ****    * @brief Q31 matrix addition.
1438:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1439:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1440:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1441:Core/Inc/arm_math.h ****    * @return     The function returns either
1442:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1443:Core/Inc/arm_math.h ****    */
1444:Core/Inc/arm_math.h ****   arm_status arm_mat_add_q31(
1445:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1446:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1447:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1448:Core/Inc/arm_math.h **** 
1449:Core/Inc/arm_math.h **** 
1450:Core/Inc/arm_math.h ****   /**
1451:Core/Inc/arm_math.h ****    * @brief Floating-point, complex, matrix multiplication.
1452:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
ARM GAS  /tmp/ccpEjOub.s 			page 30


1453:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1454:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1455:Core/Inc/arm_math.h ****    * @return     The function returns either
1456:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1457:Core/Inc/arm_math.h ****    */
1458:Core/Inc/arm_math.h ****   arm_status arm_mat_cmplx_mult_f32(
1459:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1460:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1461:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1462:Core/Inc/arm_math.h **** 
1463:Core/Inc/arm_math.h **** 
1464:Core/Inc/arm_math.h ****   /**
1465:Core/Inc/arm_math.h ****    * @brief Q15, complex,  matrix multiplication.
1466:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1467:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1468:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1469:Core/Inc/arm_math.h ****    * @return     The function returns either
1470:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1471:Core/Inc/arm_math.h ****    */
1472:Core/Inc/arm_math.h ****   arm_status arm_mat_cmplx_mult_q15(
1473:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1474:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1475:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1476:Core/Inc/arm_math.h ****   q15_t * pScratch);
1477:Core/Inc/arm_math.h **** 
1478:Core/Inc/arm_math.h **** 
1479:Core/Inc/arm_math.h ****   /**
1480:Core/Inc/arm_math.h ****    * @brief Q31, complex, matrix multiplication.
1481:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1482:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1483:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1484:Core/Inc/arm_math.h ****    * @return     The function returns either
1485:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1486:Core/Inc/arm_math.h ****    */
1487:Core/Inc/arm_math.h ****   arm_status arm_mat_cmplx_mult_q31(
1488:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1489:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1490:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1491:Core/Inc/arm_math.h **** 
1492:Core/Inc/arm_math.h **** 
1493:Core/Inc/arm_math.h ****   /**
1494:Core/Inc/arm_math.h ****    * @brief Floating-point matrix transpose.
1495:Core/Inc/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1496:Core/Inc/arm_math.h ****    * @param[out] pDst  points to the output matrix
1497:Core/Inc/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1498:Core/Inc/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1499:Core/Inc/arm_math.h ****    */
1500:Core/Inc/arm_math.h ****   arm_status arm_mat_trans_f32(
1501:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1502:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1503:Core/Inc/arm_math.h **** 
1504:Core/Inc/arm_math.h **** 
1505:Core/Inc/arm_math.h ****   /**
1506:Core/Inc/arm_math.h ****    * @brief Q15 matrix transpose.
1507:Core/Inc/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1508:Core/Inc/arm_math.h ****    * @param[out] pDst  points to the output matrix
1509:Core/Inc/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
ARM GAS  /tmp/ccpEjOub.s 			page 31


1510:Core/Inc/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1511:Core/Inc/arm_math.h ****    */
1512:Core/Inc/arm_math.h ****   arm_status arm_mat_trans_q15(
1513:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1514:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1515:Core/Inc/arm_math.h **** 
1516:Core/Inc/arm_math.h **** 
1517:Core/Inc/arm_math.h ****   /**
1518:Core/Inc/arm_math.h ****    * @brief Q31 matrix transpose.
1519:Core/Inc/arm_math.h ****    * @param[in]  pSrc  points to the input matrix
1520:Core/Inc/arm_math.h ****    * @param[out] pDst  points to the output matrix
1521:Core/Inc/arm_math.h ****    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
1522:Core/Inc/arm_math.h ****    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
1523:Core/Inc/arm_math.h ****    */
1524:Core/Inc/arm_math.h ****   arm_status arm_mat_trans_q31(
1525:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1526:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1527:Core/Inc/arm_math.h **** 
1528:Core/Inc/arm_math.h **** 
1529:Core/Inc/arm_math.h ****   /**
1530:Core/Inc/arm_math.h ****    * @brief Floating-point matrix multiplication
1531:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1532:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1533:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1534:Core/Inc/arm_math.h ****    * @return     The function returns either
1535:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1536:Core/Inc/arm_math.h ****    */
1537:Core/Inc/arm_math.h ****   arm_status arm_mat_mult_f32(
1538:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1539:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1540:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1541:Core/Inc/arm_math.h **** 
1542:Core/Inc/arm_math.h **** 
1543:Core/Inc/arm_math.h ****   /**
1544:Core/Inc/arm_math.h ****    * @brief Q15 matrix multiplication
1545:Core/Inc/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1546:Core/Inc/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1547:Core/Inc/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1548:Core/Inc/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1549:Core/Inc/arm_math.h ****    * @return     The function returns either
1550:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1551:Core/Inc/arm_math.h ****    */
1552:Core/Inc/arm_math.h ****   arm_status arm_mat_mult_q15(
1553:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1554:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1555:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1556:Core/Inc/arm_math.h ****   q15_t * pState);
1557:Core/Inc/arm_math.h **** 
1558:Core/Inc/arm_math.h **** 
1559:Core/Inc/arm_math.h ****   /**
1560:Core/Inc/arm_math.h ****    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1561:Core/Inc/arm_math.h ****    * @param[in]  pSrcA   points to the first input matrix structure
1562:Core/Inc/arm_math.h ****    * @param[in]  pSrcB   points to the second input matrix structure
1563:Core/Inc/arm_math.h ****    * @param[out] pDst    points to output matrix structure
1564:Core/Inc/arm_math.h ****    * @param[in]  pState  points to the array for storing intermediate results
1565:Core/Inc/arm_math.h ****    * @return     The function returns either
1566:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
ARM GAS  /tmp/ccpEjOub.s 			page 32


1567:Core/Inc/arm_math.h ****    */
1568:Core/Inc/arm_math.h ****   arm_status arm_mat_mult_fast_q15(
1569:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1570:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1571:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst,
1572:Core/Inc/arm_math.h ****   q15_t * pState);
1573:Core/Inc/arm_math.h **** 
1574:Core/Inc/arm_math.h **** 
1575:Core/Inc/arm_math.h ****   /**
1576:Core/Inc/arm_math.h ****    * @brief Q31 matrix multiplication
1577:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1578:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1579:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1580:Core/Inc/arm_math.h ****    * @return     The function returns either
1581:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1582:Core/Inc/arm_math.h ****    */
1583:Core/Inc/arm_math.h ****   arm_status arm_mat_mult_q31(
1584:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1585:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1586:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1587:Core/Inc/arm_math.h **** 
1588:Core/Inc/arm_math.h **** 
1589:Core/Inc/arm_math.h ****   /**
1590:Core/Inc/arm_math.h ****    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
1591:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1592:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1593:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1594:Core/Inc/arm_math.h ****    * @return     The function returns either
1595:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1596:Core/Inc/arm_math.h ****    */
1597:Core/Inc/arm_math.h ****   arm_status arm_mat_mult_fast_q31(
1598:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1599:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1600:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1601:Core/Inc/arm_math.h **** 
1602:Core/Inc/arm_math.h **** 
1603:Core/Inc/arm_math.h ****   /**
1604:Core/Inc/arm_math.h ****    * @brief Floating-point matrix subtraction
1605:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1606:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1607:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1608:Core/Inc/arm_math.h ****    * @return     The function returns either
1609:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1610:Core/Inc/arm_math.h ****    */
1611:Core/Inc/arm_math.h ****   arm_status arm_mat_sub_f32(
1612:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcA,
1613:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrcB,
1614:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1615:Core/Inc/arm_math.h **** 
1616:Core/Inc/arm_math.h **** 
1617:Core/Inc/arm_math.h ****   /**
1618:Core/Inc/arm_math.h ****    * @brief Q15 matrix subtraction
1619:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1620:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1621:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1622:Core/Inc/arm_math.h ****    * @return     The function returns either
1623:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
ARM GAS  /tmp/ccpEjOub.s 			page 33


1624:Core/Inc/arm_math.h ****    */
1625:Core/Inc/arm_math.h ****   arm_status arm_mat_sub_q15(
1626:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcA,
1627:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrcB,
1628:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1629:Core/Inc/arm_math.h **** 
1630:Core/Inc/arm_math.h **** 
1631:Core/Inc/arm_math.h ****   /**
1632:Core/Inc/arm_math.h ****    * @brief Q31 matrix subtraction
1633:Core/Inc/arm_math.h ****    * @param[in]  pSrcA  points to the first input matrix structure
1634:Core/Inc/arm_math.h ****    * @param[in]  pSrcB  points to the second input matrix structure
1635:Core/Inc/arm_math.h ****    * @param[out] pDst   points to output matrix structure
1636:Core/Inc/arm_math.h ****    * @return     The function returns either
1637:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1638:Core/Inc/arm_math.h ****    */
1639:Core/Inc/arm_math.h ****   arm_status arm_mat_sub_q31(
1640:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcA,
1641:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrcB,
1642:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1643:Core/Inc/arm_math.h **** 
1644:Core/Inc/arm_math.h **** 
1645:Core/Inc/arm_math.h ****   /**
1646:Core/Inc/arm_math.h ****    * @brief Floating-point matrix scaling.
1647:Core/Inc/arm_math.h ****    * @param[in]  pSrc   points to the input matrix
1648:Core/Inc/arm_math.h ****    * @param[in]  scale  scale factor
1649:Core/Inc/arm_math.h ****    * @param[out] pDst   points to the output matrix
1650:Core/Inc/arm_math.h ****    * @return     The function returns either
1651:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1652:Core/Inc/arm_math.h ****    */
1653:Core/Inc/arm_math.h ****   arm_status arm_mat_scale_f32(
1654:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * pSrc,
1655:Core/Inc/arm_math.h ****   float32_t scale,
1656:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * pDst);
1657:Core/Inc/arm_math.h **** 
1658:Core/Inc/arm_math.h **** 
1659:Core/Inc/arm_math.h ****   /**
1660:Core/Inc/arm_math.h ****    * @brief Q15 matrix scaling.
1661:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1662:Core/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1663:Core/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1664:Core/Inc/arm_math.h ****    * @param[out] pDst        points to output matrix
1665:Core/Inc/arm_math.h ****    * @return     The function returns either
1666:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1667:Core/Inc/arm_math.h ****    */
1668:Core/Inc/arm_math.h ****   arm_status arm_mat_scale_q15(
1669:Core/Inc/arm_math.h ****   const arm_matrix_instance_q15 * pSrc,
1670:Core/Inc/arm_math.h ****   q15_t scaleFract,
1671:Core/Inc/arm_math.h ****   int32_t shift,
1672:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * pDst);
1673:Core/Inc/arm_math.h **** 
1674:Core/Inc/arm_math.h **** 
1675:Core/Inc/arm_math.h ****   /**
1676:Core/Inc/arm_math.h ****    * @brief Q31 matrix scaling.
1677:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to input matrix
1678:Core/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale factor
1679:Core/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
1680:Core/Inc/arm_math.h ****    * @param[out] pDst        points to output matrix structure
ARM GAS  /tmp/ccpEjOub.s 			page 34


1681:Core/Inc/arm_math.h ****    * @return     The function returns either
1682:Core/Inc/arm_math.h ****    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of s
1683:Core/Inc/arm_math.h ****    */
1684:Core/Inc/arm_math.h ****   arm_status arm_mat_scale_q31(
1685:Core/Inc/arm_math.h ****   const arm_matrix_instance_q31 * pSrc,
1686:Core/Inc/arm_math.h ****   q31_t scaleFract,
1687:Core/Inc/arm_math.h ****   int32_t shift,
1688:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * pDst);
1689:Core/Inc/arm_math.h **** 
1690:Core/Inc/arm_math.h **** 
1691:Core/Inc/arm_math.h ****   /**
1692:Core/Inc/arm_math.h ****    * @brief  Q31 matrix initialization.
1693:Core/Inc/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1694:Core/Inc/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1695:Core/Inc/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1696:Core/Inc/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1697:Core/Inc/arm_math.h ****    */
1698:Core/Inc/arm_math.h ****   void arm_mat_init_q31(
1699:Core/Inc/arm_math.h ****   arm_matrix_instance_q31 * S,
1700:Core/Inc/arm_math.h ****   uint16_t nRows,
1701:Core/Inc/arm_math.h ****   uint16_t nColumns,
1702:Core/Inc/arm_math.h ****   q31_t * pData);
1703:Core/Inc/arm_math.h **** 
1704:Core/Inc/arm_math.h **** 
1705:Core/Inc/arm_math.h ****   /**
1706:Core/Inc/arm_math.h ****    * @brief  Q15 matrix initialization.
1707:Core/Inc/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1708:Core/Inc/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1709:Core/Inc/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1710:Core/Inc/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1711:Core/Inc/arm_math.h ****    */
1712:Core/Inc/arm_math.h ****   void arm_mat_init_q15(
1713:Core/Inc/arm_math.h ****   arm_matrix_instance_q15 * S,
1714:Core/Inc/arm_math.h ****   uint16_t nRows,
1715:Core/Inc/arm_math.h ****   uint16_t nColumns,
1716:Core/Inc/arm_math.h ****   q15_t * pData);
1717:Core/Inc/arm_math.h **** 
1718:Core/Inc/arm_math.h **** 
1719:Core/Inc/arm_math.h ****   /**
1720:Core/Inc/arm_math.h ****    * @brief  Floating-point matrix initialization.
1721:Core/Inc/arm_math.h ****    * @param[in,out] S         points to an instance of the floating-point matrix structure.
1722:Core/Inc/arm_math.h ****    * @param[in]     nRows     number of rows in the matrix.
1723:Core/Inc/arm_math.h ****    * @param[in]     nColumns  number of columns in the matrix.
1724:Core/Inc/arm_math.h ****    * @param[in]     pData     points to the matrix data array.
1725:Core/Inc/arm_math.h ****    */
1726:Core/Inc/arm_math.h ****   void arm_mat_init_f32(
1727:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * S,
1728:Core/Inc/arm_math.h ****   uint16_t nRows,
1729:Core/Inc/arm_math.h ****   uint16_t nColumns,
1730:Core/Inc/arm_math.h ****   float32_t * pData);
1731:Core/Inc/arm_math.h **** 
1732:Core/Inc/arm_math.h **** 
1733:Core/Inc/arm_math.h **** 
1734:Core/Inc/arm_math.h ****   /**
1735:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 PID Control.
1736:Core/Inc/arm_math.h ****    */
1737:Core/Inc/arm_math.h ****   typedef struct
ARM GAS  /tmp/ccpEjOub.s 			page 35


1738:Core/Inc/arm_math.h ****   {
1739:Core/Inc/arm_math.h ****     q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
1740:Core/Inc/arm_math.h **** #ifdef ARM_MATH_CM0_FAMILY
1741:Core/Inc/arm_math.h ****     q15_t A1;
1742:Core/Inc/arm_math.h ****     q15_t A2;
1743:Core/Inc/arm_math.h **** #else
1744:Core/Inc/arm_math.h ****     q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
1745:Core/Inc/arm_math.h **** #endif
1746:Core/Inc/arm_math.h ****     q15_t state[3];     /**< The state array of length 3. */
1747:Core/Inc/arm_math.h ****     q15_t Kp;           /**< The proportional gain. */
1748:Core/Inc/arm_math.h ****     q15_t Ki;           /**< The integral gain. */
1749:Core/Inc/arm_math.h ****     q15_t Kd;           /**< The derivative gain. */
1750:Core/Inc/arm_math.h ****   } arm_pid_instance_q15;
1751:Core/Inc/arm_math.h **** 
1752:Core/Inc/arm_math.h ****   /**
1753:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 PID Control.
1754:Core/Inc/arm_math.h ****    */
1755:Core/Inc/arm_math.h ****   typedef struct
1756:Core/Inc/arm_math.h ****   {
1757:Core/Inc/arm_math.h ****     q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
1758:Core/Inc/arm_math.h ****     q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
1759:Core/Inc/arm_math.h ****     q31_t A2;            /**< The derived gain, A2 = Kd . */
1760:Core/Inc/arm_math.h ****     q31_t state[3];      /**< The state array of length 3. */
1761:Core/Inc/arm_math.h ****     q31_t Kp;            /**< The proportional gain. */
1762:Core/Inc/arm_math.h ****     q31_t Ki;            /**< The integral gain. */
1763:Core/Inc/arm_math.h ****     q31_t Kd;            /**< The derivative gain. */
1764:Core/Inc/arm_math.h ****   } arm_pid_instance_q31;
1765:Core/Inc/arm_math.h **** 
1766:Core/Inc/arm_math.h ****   /**
1767:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point PID Control.
1768:Core/Inc/arm_math.h ****    */
1769:Core/Inc/arm_math.h ****   typedef struct
1770:Core/Inc/arm_math.h ****   {
1771:Core/Inc/arm_math.h ****     float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
1772:Core/Inc/arm_math.h ****     float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
1773:Core/Inc/arm_math.h ****     float32_t A2;          /**< The derived gain, A2 = Kd . */
1774:Core/Inc/arm_math.h ****     float32_t state[3];    /**< The state array of length 3. */
1775:Core/Inc/arm_math.h ****     float32_t Kp;          /**< The proportional gain. */
1776:Core/Inc/arm_math.h ****     float32_t Ki;          /**< The integral gain. */
1777:Core/Inc/arm_math.h ****     float32_t Kd;          /**< The derivative gain. */
1778:Core/Inc/arm_math.h ****   } arm_pid_instance_f32;
1779:Core/Inc/arm_math.h **** 
1780:Core/Inc/arm_math.h **** 
1781:Core/Inc/arm_math.h **** 
1782:Core/Inc/arm_math.h ****   /**
1783:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point PID Control.
1784:Core/Inc/arm_math.h ****    * @param[in,out] S               points to an instance of the PID structure.
1785:Core/Inc/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1786:Core/Inc/arm_math.h ****    */
1787:Core/Inc/arm_math.h ****   void arm_pid_init_f32(
1788:Core/Inc/arm_math.h ****   arm_pid_instance_f32 * S,
1789:Core/Inc/arm_math.h ****   int32_t resetStateFlag);
1790:Core/Inc/arm_math.h **** 
1791:Core/Inc/arm_math.h **** 
1792:Core/Inc/arm_math.h ****   /**
1793:Core/Inc/arm_math.h ****    * @brief  Reset function for the floating-point PID Control.
1794:Core/Inc/arm_math.h ****    * @param[in,out] S  is an instance of the floating-point PID Control structure
ARM GAS  /tmp/ccpEjOub.s 			page 36


1795:Core/Inc/arm_math.h ****    */
1796:Core/Inc/arm_math.h ****   void arm_pid_reset_f32(
1797:Core/Inc/arm_math.h ****   arm_pid_instance_f32 * S);
1798:Core/Inc/arm_math.h **** 
1799:Core/Inc/arm_math.h **** 
1800:Core/Inc/arm_math.h ****   /**
1801:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 PID Control.
1802:Core/Inc/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1803:Core/Inc/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1804:Core/Inc/arm_math.h ****    */
1805:Core/Inc/arm_math.h ****   void arm_pid_init_q31(
1806:Core/Inc/arm_math.h ****   arm_pid_instance_q31 * S,
1807:Core/Inc/arm_math.h ****   int32_t resetStateFlag);
1808:Core/Inc/arm_math.h **** 
1809:Core/Inc/arm_math.h **** 
1810:Core/Inc/arm_math.h ****   /**
1811:Core/Inc/arm_math.h ****    * @brief  Reset function for the Q31 PID Control.
1812:Core/Inc/arm_math.h ****    * @param[in,out] S   points to an instance of the Q31 PID Control structure
1813:Core/Inc/arm_math.h ****    */
1814:Core/Inc/arm_math.h **** 
1815:Core/Inc/arm_math.h ****   void arm_pid_reset_q31(
1816:Core/Inc/arm_math.h ****   arm_pid_instance_q31 * S);
1817:Core/Inc/arm_math.h **** 
1818:Core/Inc/arm_math.h **** 
1819:Core/Inc/arm_math.h ****   /**
1820:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 PID Control.
1821:Core/Inc/arm_math.h ****    * @param[in,out] S               points to an instance of the Q15 PID structure.
1822:Core/Inc/arm_math.h ****    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the s
1823:Core/Inc/arm_math.h ****    */
1824:Core/Inc/arm_math.h ****   void arm_pid_init_q15(
1825:Core/Inc/arm_math.h ****   arm_pid_instance_q15 * S,
1826:Core/Inc/arm_math.h ****   int32_t resetStateFlag);
1827:Core/Inc/arm_math.h **** 
1828:Core/Inc/arm_math.h **** 
1829:Core/Inc/arm_math.h ****   /**
1830:Core/Inc/arm_math.h ****    * @brief  Reset function for the Q15 PID Control.
1831:Core/Inc/arm_math.h ****    * @param[in,out] S  points to an instance of the q15 PID Control structure
1832:Core/Inc/arm_math.h ****    */
1833:Core/Inc/arm_math.h ****   void arm_pid_reset_q15(
1834:Core/Inc/arm_math.h ****   arm_pid_instance_q15 * S);
1835:Core/Inc/arm_math.h **** 
1836:Core/Inc/arm_math.h **** 
1837:Core/Inc/arm_math.h ****   /**
1838:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point Linear Interpolate function.
1839:Core/Inc/arm_math.h ****    */
1840:Core/Inc/arm_math.h ****   typedef struct
1841:Core/Inc/arm_math.h ****   {
1842:Core/Inc/arm_math.h ****     uint32_t nValues;           /**< nValues */
1843:Core/Inc/arm_math.h ****     float32_t x1;               /**< x1 */
1844:Core/Inc/arm_math.h ****     float32_t xSpacing;         /**< xSpacing */
1845:Core/Inc/arm_math.h ****     float32_t *pYData;          /**< pointer to the table of Y values */
1846:Core/Inc/arm_math.h ****   } arm_linear_interp_instance_f32;
1847:Core/Inc/arm_math.h **** 
1848:Core/Inc/arm_math.h ****   /**
1849:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point bilinear interpolation function.
1850:Core/Inc/arm_math.h ****    */
1851:Core/Inc/arm_math.h ****   typedef struct
ARM GAS  /tmp/ccpEjOub.s 			page 37


1852:Core/Inc/arm_math.h ****   {
1853:Core/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1854:Core/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1855:Core/Inc/arm_math.h ****     float32_t *pData;   /**< points to the data table. */
1856:Core/Inc/arm_math.h ****   } arm_bilinear_interp_instance_f32;
1857:Core/Inc/arm_math.h **** 
1858:Core/Inc/arm_math.h ****    /**
1859:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 bilinear interpolation function.
1860:Core/Inc/arm_math.h ****    */
1861:Core/Inc/arm_math.h ****   typedef struct
1862:Core/Inc/arm_math.h ****   {
1863:Core/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1864:Core/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1865:Core/Inc/arm_math.h ****     q31_t *pData;       /**< points to the data table. */
1866:Core/Inc/arm_math.h ****   } arm_bilinear_interp_instance_q31;
1867:Core/Inc/arm_math.h **** 
1868:Core/Inc/arm_math.h ****    /**
1869:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1870:Core/Inc/arm_math.h ****    */
1871:Core/Inc/arm_math.h ****   typedef struct
1872:Core/Inc/arm_math.h ****   {
1873:Core/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1874:Core/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1875:Core/Inc/arm_math.h ****     q15_t *pData;       /**< points to the data table. */
1876:Core/Inc/arm_math.h ****   } arm_bilinear_interp_instance_q15;
1877:Core/Inc/arm_math.h **** 
1878:Core/Inc/arm_math.h ****    /**
1879:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 bilinear interpolation function.
1880:Core/Inc/arm_math.h ****    */
1881:Core/Inc/arm_math.h ****   typedef struct
1882:Core/Inc/arm_math.h ****   {
1883:Core/Inc/arm_math.h ****     uint16_t numRows;   /**< number of rows in the data table. */
1884:Core/Inc/arm_math.h ****     uint16_t numCols;   /**< number of columns in the data table. */
1885:Core/Inc/arm_math.h ****     q7_t *pData;        /**< points to the data table. */
1886:Core/Inc/arm_math.h ****   } arm_bilinear_interp_instance_q7;
1887:Core/Inc/arm_math.h **** 
1888:Core/Inc/arm_math.h **** 
1889:Core/Inc/arm_math.h ****   /**
1890:Core/Inc/arm_math.h ****    * @brief Q7 vector multiplication.
1891:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1892:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1893:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1894:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1895:Core/Inc/arm_math.h ****    */
1896:Core/Inc/arm_math.h ****   void arm_mult_q7(
1897:Core/Inc/arm_math.h ****   q7_t * pSrcA,
1898:Core/Inc/arm_math.h ****   q7_t * pSrcB,
1899:Core/Inc/arm_math.h ****   q7_t * pDst,
1900:Core/Inc/arm_math.h ****   uint32_t blockSize);
1901:Core/Inc/arm_math.h **** 
1902:Core/Inc/arm_math.h **** 
1903:Core/Inc/arm_math.h ****   /**
1904:Core/Inc/arm_math.h ****    * @brief Q15 vector multiplication.
1905:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1906:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1907:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1908:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
ARM GAS  /tmp/ccpEjOub.s 			page 38


1909:Core/Inc/arm_math.h ****    */
1910:Core/Inc/arm_math.h ****   void arm_mult_q15(
1911:Core/Inc/arm_math.h ****   q15_t * pSrcA,
1912:Core/Inc/arm_math.h ****   q15_t * pSrcB,
1913:Core/Inc/arm_math.h ****   q15_t * pDst,
1914:Core/Inc/arm_math.h ****   uint32_t blockSize);
1915:Core/Inc/arm_math.h **** 
1916:Core/Inc/arm_math.h **** 
1917:Core/Inc/arm_math.h ****   /**
1918:Core/Inc/arm_math.h ****    * @brief Q31 vector multiplication.
1919:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1920:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1921:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1922:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1923:Core/Inc/arm_math.h ****    */
1924:Core/Inc/arm_math.h ****   void arm_mult_q31(
1925:Core/Inc/arm_math.h ****   q31_t * pSrcA,
1926:Core/Inc/arm_math.h ****   q31_t * pSrcB,
1927:Core/Inc/arm_math.h ****   q31_t * pDst,
1928:Core/Inc/arm_math.h ****   uint32_t blockSize);
1929:Core/Inc/arm_math.h **** 
1930:Core/Inc/arm_math.h **** 
1931:Core/Inc/arm_math.h ****   /**
1932:Core/Inc/arm_math.h ****    * @brief Floating-point vector multiplication.
1933:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
1934:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
1935:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
1936:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
1937:Core/Inc/arm_math.h ****    */
1938:Core/Inc/arm_math.h ****   void arm_mult_f32(
1939:Core/Inc/arm_math.h ****   float32_t * pSrcA,
1940:Core/Inc/arm_math.h ****   float32_t * pSrcB,
1941:Core/Inc/arm_math.h ****   float32_t * pDst,
1942:Core/Inc/arm_math.h ****   uint32_t blockSize);
1943:Core/Inc/arm_math.h **** 
1944:Core/Inc/arm_math.h **** 
1945:Core/Inc/arm_math.h ****   /**
1946:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
1947:Core/Inc/arm_math.h ****    */
1948:Core/Inc/arm_math.h ****   typedef struct
1949:Core/Inc/arm_math.h ****   {
1950:Core/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
1951:Core/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
1952:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
1953:Core/Inc/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
1954:Core/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
1955:Core/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
1956:Core/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
1957:Core/Inc/arm_math.h ****   } arm_cfft_radix2_instance_q15;
1958:Core/Inc/arm_math.h **** 
1959:Core/Inc/arm_math.h **** /* Deprecated */
1960:Core/Inc/arm_math.h ****   arm_status arm_cfft_radix2_init_q15(
1961:Core/Inc/arm_math.h ****   arm_cfft_radix2_instance_q15 * S,
1962:Core/Inc/arm_math.h ****   uint16_t fftLen,
1963:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
1964:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
1965:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 39


1966:Core/Inc/arm_math.h **** /* Deprecated */
1967:Core/Inc/arm_math.h ****   void arm_cfft_radix2_q15(
1968:Core/Inc/arm_math.h ****   const arm_cfft_radix2_instance_q15 * S,
1969:Core/Inc/arm_math.h ****   q15_t * pSrc);
1970:Core/Inc/arm_math.h **** 
1971:Core/Inc/arm_math.h **** 
1972:Core/Inc/arm_math.h ****   /**
1973:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 CFFT/CIFFT function.
1974:Core/Inc/arm_math.h ****    */
1975:Core/Inc/arm_math.h ****   typedef struct
1976:Core/Inc/arm_math.h ****   {
1977:Core/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
1978:Core/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
1979:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
1980:Core/Inc/arm_math.h ****     q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
1981:Core/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
1982:Core/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
1983:Core/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
1984:Core/Inc/arm_math.h ****   } arm_cfft_radix4_instance_q15;
1985:Core/Inc/arm_math.h **** 
1986:Core/Inc/arm_math.h **** /* Deprecated */
1987:Core/Inc/arm_math.h ****   arm_status arm_cfft_radix4_init_q15(
1988:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_q15 * S,
1989:Core/Inc/arm_math.h ****   uint16_t fftLen,
1990:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
1991:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
1992:Core/Inc/arm_math.h **** 
1993:Core/Inc/arm_math.h **** /* Deprecated */
1994:Core/Inc/arm_math.h ****   void arm_cfft_radix4_q15(
1995:Core/Inc/arm_math.h ****   const arm_cfft_radix4_instance_q15 * S,
1996:Core/Inc/arm_math.h ****   q15_t * pSrc);
1997:Core/Inc/arm_math.h **** 
1998:Core/Inc/arm_math.h ****   /**
1999:Core/Inc/arm_math.h ****    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
2000:Core/Inc/arm_math.h ****    */
2001:Core/Inc/arm_math.h ****   typedef struct
2002:Core/Inc/arm_math.h ****   {
2003:Core/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2004:Core/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2005:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2006:Core/Inc/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
2007:Core/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2008:Core/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2009:Core/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2010:Core/Inc/arm_math.h ****   } arm_cfft_radix2_instance_q31;
2011:Core/Inc/arm_math.h **** 
2012:Core/Inc/arm_math.h **** /* Deprecated */
2013:Core/Inc/arm_math.h ****   arm_status arm_cfft_radix2_init_q31(
2014:Core/Inc/arm_math.h ****   arm_cfft_radix2_instance_q31 * S,
2015:Core/Inc/arm_math.h ****   uint16_t fftLen,
2016:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
2017:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2018:Core/Inc/arm_math.h **** 
2019:Core/Inc/arm_math.h **** /* Deprecated */
2020:Core/Inc/arm_math.h ****   void arm_cfft_radix2_q31(
2021:Core/Inc/arm_math.h ****   const arm_cfft_radix2_instance_q31 * S,
2022:Core/Inc/arm_math.h ****   q31_t * pSrc);
ARM GAS  /tmp/ccpEjOub.s 			page 40


2023:Core/Inc/arm_math.h **** 
2024:Core/Inc/arm_math.h ****   /**
2025:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 CFFT/CIFFT function.
2026:Core/Inc/arm_math.h ****    */
2027:Core/Inc/arm_math.h ****   typedef struct
2028:Core/Inc/arm_math.h ****   {
2029:Core/Inc/arm_math.h ****     uint16_t fftLen;                 /**< length of the FFT. */
2030:Core/Inc/arm_math.h ****     uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFl
2031:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReve
2032:Core/Inc/arm_math.h ****     q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
2033:Core/Inc/arm_math.h ****     uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
2034:Core/Inc/arm_math.h ****     uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size
2035:Core/Inc/arm_math.h ****     uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs w
2036:Core/Inc/arm_math.h ****   } arm_cfft_radix4_instance_q31;
2037:Core/Inc/arm_math.h **** 
2038:Core/Inc/arm_math.h **** /* Deprecated */
2039:Core/Inc/arm_math.h ****   void arm_cfft_radix4_q31(
2040:Core/Inc/arm_math.h ****   const arm_cfft_radix4_instance_q31 * S,
2041:Core/Inc/arm_math.h ****   q31_t * pSrc);
2042:Core/Inc/arm_math.h **** 
2043:Core/Inc/arm_math.h **** /* Deprecated */
2044:Core/Inc/arm_math.h ****   arm_status arm_cfft_radix4_init_q31(
2045:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_q31 * S,
2046:Core/Inc/arm_math.h ****   uint16_t fftLen,
2047:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
2048:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2049:Core/Inc/arm_math.h **** 
2050:Core/Inc/arm_math.h ****   /**
2051:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2052:Core/Inc/arm_math.h ****    */
2053:Core/Inc/arm_math.h ****   typedef struct
2054:Core/Inc/arm_math.h ****   {
2055:Core/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2056:Core/Inc/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2057:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2058:Core/Inc/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2059:Core/Inc/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2060:Core/Inc/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2061:Core/Inc/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2062:Core/Inc/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2063:Core/Inc/arm_math.h ****   } arm_cfft_radix2_instance_f32;
2064:Core/Inc/arm_math.h **** 
2065:Core/Inc/arm_math.h **** /* Deprecated */
2066:Core/Inc/arm_math.h ****   arm_status arm_cfft_radix2_init_f32(
2067:Core/Inc/arm_math.h ****   arm_cfft_radix2_instance_f32 * S,
2068:Core/Inc/arm_math.h ****   uint16_t fftLen,
2069:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
2070:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2071:Core/Inc/arm_math.h **** 
2072:Core/Inc/arm_math.h **** /* Deprecated */
2073:Core/Inc/arm_math.h ****   void arm_cfft_radix2_f32(
2074:Core/Inc/arm_math.h ****   const arm_cfft_radix2_instance_f32 * S,
2075:Core/Inc/arm_math.h ****   float32_t * pSrc);
2076:Core/Inc/arm_math.h **** 
2077:Core/Inc/arm_math.h ****   /**
2078:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2079:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 41


2080:Core/Inc/arm_math.h ****   typedef struct
2081:Core/Inc/arm_math.h ****   {
2082:Core/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2083:Core/Inc/arm_math.h ****     uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifft
2084:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitRe
2085:Core/Inc/arm_math.h ****     float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
2086:Core/Inc/arm_math.h ****     uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
2087:Core/Inc/arm_math.h ****     uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different si
2088:Core/Inc/arm_math.h ****     uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs
2089:Core/Inc/arm_math.h ****     float32_t onebyfftLen;             /**< value of 1/fftLen. */
2090:Core/Inc/arm_math.h ****   } arm_cfft_radix4_instance_f32;
2091:Core/Inc/arm_math.h **** 
2092:Core/Inc/arm_math.h **** /* Deprecated */
2093:Core/Inc/arm_math.h ****   arm_status arm_cfft_radix4_init_f32(
2094:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_f32 * S,
2095:Core/Inc/arm_math.h ****   uint16_t fftLen,
2096:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
2097:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2098:Core/Inc/arm_math.h **** 
2099:Core/Inc/arm_math.h **** /* Deprecated */
2100:Core/Inc/arm_math.h ****   void arm_cfft_radix4_f32(
2101:Core/Inc/arm_math.h ****   const arm_cfft_radix4_instance_f32 * S,
2102:Core/Inc/arm_math.h ****   float32_t * pSrc);
2103:Core/Inc/arm_math.h **** 
2104:Core/Inc/arm_math.h ****   /**
2105:Core/Inc/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2106:Core/Inc/arm_math.h ****    */
2107:Core/Inc/arm_math.h ****   typedef struct
2108:Core/Inc/arm_math.h ****   {
2109:Core/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2110:Core/Inc/arm_math.h ****     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
2111:Core/Inc/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2112:Core/Inc/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2113:Core/Inc/arm_math.h ****   } arm_cfft_instance_q15;
2114:Core/Inc/arm_math.h **** 
2115:Core/Inc/arm_math.h **** void arm_cfft_q15(
2116:Core/Inc/arm_math.h ****     const arm_cfft_instance_q15 * S,
2117:Core/Inc/arm_math.h ****     q15_t * p1,
2118:Core/Inc/arm_math.h ****     uint8_t ifftFlag,
2119:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag);
2120:Core/Inc/arm_math.h **** 
2121:Core/Inc/arm_math.h ****   /**
2122:Core/Inc/arm_math.h ****    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
2123:Core/Inc/arm_math.h ****    */
2124:Core/Inc/arm_math.h ****   typedef struct
2125:Core/Inc/arm_math.h ****   {
2126:Core/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2127:Core/Inc/arm_math.h ****     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
2128:Core/Inc/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2129:Core/Inc/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2130:Core/Inc/arm_math.h ****   } arm_cfft_instance_q31;
2131:Core/Inc/arm_math.h **** 
2132:Core/Inc/arm_math.h **** void arm_cfft_q31(
2133:Core/Inc/arm_math.h ****     const arm_cfft_instance_q31 * S,
2134:Core/Inc/arm_math.h ****     q31_t * p1,
2135:Core/Inc/arm_math.h ****     uint8_t ifftFlag,
2136:Core/Inc/arm_math.h ****     uint8_t bitReverseFlag);
ARM GAS  /tmp/ccpEjOub.s 			page 42


2137:Core/Inc/arm_math.h **** 
2138:Core/Inc/arm_math.h ****   /**
2139:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point CFFT/CIFFT function.
2140:Core/Inc/arm_math.h ****    */
2141:Core/Inc/arm_math.h ****   typedef struct
2142:Core/Inc/arm_math.h ****   {
2143:Core/Inc/arm_math.h ****     uint16_t fftLen;                   /**< length of the FFT. */
2144:Core/Inc/arm_math.h ****     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
2145:Core/Inc/arm_math.h ****     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
2146:Core/Inc/arm_math.h ****     uint16_t bitRevLength;             /**< bit reversal table length. */
2147:Core/Inc/arm_math.h ****   } arm_cfft_instance_f32;
2148:Core/Inc/arm_math.h **** 
2149:Core/Inc/arm_math.h ****   void arm_cfft_f32(
2150:Core/Inc/arm_math.h ****   const arm_cfft_instance_f32 * S,
2151:Core/Inc/arm_math.h ****   float32_t * p1,
2152:Core/Inc/arm_math.h ****   uint8_t ifftFlag,
2153:Core/Inc/arm_math.h ****   uint8_t bitReverseFlag);
2154:Core/Inc/arm_math.h **** 
2155:Core/Inc/arm_math.h ****   /**
2156:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 RFFT/RIFFT function.
2157:Core/Inc/arm_math.h ****    */
2158:Core/Inc/arm_math.h ****   typedef struct
2159:Core/Inc/arm_math.h ****   {
2160:Core/Inc/arm_math.h ****     uint32_t fftLenReal;                      /**< length of the real FFT. */
2161:Core/Inc/arm_math.h ****     uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inver
2162:Core/Inc/arm_math.h ****     uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disable
2163:Core/Inc/arm_math.h ****     uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports diffe
2164:Core/Inc/arm_math.h ****     q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
2165:Core/Inc/arm_math.h ****     q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
2166:Core/Inc/arm_math.h ****     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
2167:Core/Inc/arm_math.h ****   } arm_rfft_instance_q15;
2168:Core/Inc/arm_math.h **** 
2169:Core/Inc/arm_math.h ****   arm_status arm_rfft_init_q15(
2170:Core/Inc/arm_math.h ****   arm_rfft_instance_q15 * S,
2171:Core/Inc/arm_math.h ****   uint32_t fftLenReal,
2172:Core/Inc/arm_math.h ****   uint32_t ifftFlagR,
2173:Core/Inc/arm_math.h ****   uint32_t bitReverseFlag);
2174:Core/Inc/arm_math.h **** 
2175:Core/Inc/arm_math.h ****   void arm_rfft_q15(
2176:Core/Inc/arm_math.h ****   const arm_rfft_instance_q15 * S,
2177:Core/Inc/arm_math.h ****   q15_t * pSrc,
2178:Core/Inc/arm_math.h ****   q15_t * pDst);
2179:Core/Inc/arm_math.h **** 
2180:Core/Inc/arm_math.h ****   /**
2181:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 RFFT/RIFFT function.
2182:Core/Inc/arm_math.h ****    */
2183:Core/Inc/arm_math.h ****   typedef struct
2184:Core/Inc/arm_math.h ****   {
2185:Core/Inc/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2186:Core/Inc/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2187:Core/Inc/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2188:Core/Inc/arm_math.h ****     uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports dif
2189:Core/Inc/arm_math.h ****     q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
2190:Core/Inc/arm_math.h ****     q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
2191:Core/Inc/arm_math.h ****     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
2192:Core/Inc/arm_math.h ****   } arm_rfft_instance_q31;
2193:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 43


2194:Core/Inc/arm_math.h ****   arm_status arm_rfft_init_q31(
2195:Core/Inc/arm_math.h ****   arm_rfft_instance_q31 * S,
2196:Core/Inc/arm_math.h ****   uint32_t fftLenReal,
2197:Core/Inc/arm_math.h ****   uint32_t ifftFlagR,
2198:Core/Inc/arm_math.h ****   uint32_t bitReverseFlag);
2199:Core/Inc/arm_math.h **** 
2200:Core/Inc/arm_math.h ****   void arm_rfft_q31(
2201:Core/Inc/arm_math.h ****   const arm_rfft_instance_q31 * S,
2202:Core/Inc/arm_math.h ****   q31_t * pSrc,
2203:Core/Inc/arm_math.h ****   q31_t * pDst);
2204:Core/Inc/arm_math.h **** 
2205:Core/Inc/arm_math.h ****   /**
2206:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2207:Core/Inc/arm_math.h ****    */
2208:Core/Inc/arm_math.h ****   typedef struct
2209:Core/Inc/arm_math.h ****   {
2210:Core/Inc/arm_math.h ****     uint32_t fftLenReal;                        /**< length of the real FFT. */
2211:Core/Inc/arm_math.h ****     uint16_t fftLenBy2;                         /**< length of the complex FFT. */
2212:Core/Inc/arm_math.h ****     uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inv
2213:Core/Inc/arm_math.h ****     uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disab
2214:Core/Inc/arm_math.h ****     uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports
2215:Core/Inc/arm_math.h ****     float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
2216:Core/Inc/arm_math.h ****     float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
2217:Core/Inc/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
2218:Core/Inc/arm_math.h ****   } arm_rfft_instance_f32;
2219:Core/Inc/arm_math.h **** 
2220:Core/Inc/arm_math.h ****   arm_status arm_rfft_init_f32(
2221:Core/Inc/arm_math.h ****   arm_rfft_instance_f32 * S,
2222:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2223:Core/Inc/arm_math.h ****   uint32_t fftLenReal,
2224:Core/Inc/arm_math.h ****   uint32_t ifftFlagR,
2225:Core/Inc/arm_math.h ****   uint32_t bitReverseFlag);
2226:Core/Inc/arm_math.h **** 
2227:Core/Inc/arm_math.h ****   void arm_rfft_f32(
2228:Core/Inc/arm_math.h ****   const arm_rfft_instance_f32 * S,
2229:Core/Inc/arm_math.h ****   float32_t * pSrc,
2230:Core/Inc/arm_math.h ****   float32_t * pDst);
2231:Core/Inc/arm_math.h **** 
2232:Core/Inc/arm_math.h ****   /**
2233:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point RFFT/RIFFT function.
2234:Core/Inc/arm_math.h ****    */
2235:Core/Inc/arm_math.h **** typedef struct
2236:Core/Inc/arm_math.h ****   {
2237:Core/Inc/arm_math.h ****     arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
2238:Core/Inc/arm_math.h ****     uint16_t fftLenRFFT;             /**< length of the real sequence */
2239:Core/Inc/arm_math.h ****     float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
2240:Core/Inc/arm_math.h ****   } arm_rfft_fast_instance_f32 ;
2241:Core/Inc/arm_math.h **** 
2242:Core/Inc/arm_math.h **** arm_status arm_rfft_fast_init_f32 (
2243:Core/Inc/arm_math.h ****    arm_rfft_fast_instance_f32 * S,
2244:Core/Inc/arm_math.h ****    uint16_t fftLen);
2245:Core/Inc/arm_math.h **** 
2246:Core/Inc/arm_math.h **** void arm_rfft_fast_f32(
2247:Core/Inc/arm_math.h ****   arm_rfft_fast_instance_f32 * S,
2248:Core/Inc/arm_math.h ****   float32_t * p, float32_t * pOut,
2249:Core/Inc/arm_math.h ****   uint8_t ifftFlag);
2250:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 44


2251:Core/Inc/arm_math.h ****   /**
2252:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
2253:Core/Inc/arm_math.h ****    */
2254:Core/Inc/arm_math.h ****   typedef struct
2255:Core/Inc/arm_math.h ****   {
2256:Core/Inc/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2257:Core/Inc/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2258:Core/Inc/arm_math.h ****     float32_t normalize;                 /**< normalizing factor. */
2259:Core/Inc/arm_math.h ****     float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
2260:Core/Inc/arm_math.h ****     float32_t *pCosFactor;               /**< points to the cosFactor table. */
2261:Core/Inc/arm_math.h ****     arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
2262:Core/Inc/arm_math.h ****     arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
2263:Core/Inc/arm_math.h ****   } arm_dct4_instance_f32;
2264:Core/Inc/arm_math.h **** 
2265:Core/Inc/arm_math.h **** 
2266:Core/Inc/arm_math.h ****   /**
2267:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point DCT4/IDCT4.
2268:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure.
2269:Core/Inc/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure.
2270:Core/Inc/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure.
2271:Core/Inc/arm_math.h ****    * @param[in]     N          length of the DCT4.
2272:Core/Inc/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2273:Core/Inc/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2274:Core/Inc/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2275:Core/Inc/arm_math.h ****    */
2276:Core/Inc/arm_math.h ****   arm_status arm_dct4_init_f32(
2277:Core/Inc/arm_math.h ****   arm_dct4_instance_f32 * S,
2278:Core/Inc/arm_math.h ****   arm_rfft_instance_f32 * S_RFFT,
2279:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_f32 * S_CFFT,
2280:Core/Inc/arm_math.h ****   uint16_t N,
2281:Core/Inc/arm_math.h ****   uint16_t Nby2,
2282:Core/Inc/arm_math.h ****   float32_t normalize);
2283:Core/Inc/arm_math.h **** 
2284:Core/Inc/arm_math.h **** 
2285:Core/Inc/arm_math.h ****   /**
2286:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point DCT4/IDCT4.
2287:Core/Inc/arm_math.h ****    * @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure
2288:Core/Inc/arm_math.h ****    * @param[in]     pState         points to state buffer.
2289:Core/Inc/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2290:Core/Inc/arm_math.h ****    */
2291:Core/Inc/arm_math.h ****   void arm_dct4_f32(
2292:Core/Inc/arm_math.h ****   const arm_dct4_instance_f32 * S,
2293:Core/Inc/arm_math.h ****   float32_t * pState,
2294:Core/Inc/arm_math.h ****   float32_t * pInlineBuffer);
2295:Core/Inc/arm_math.h **** 
2296:Core/Inc/arm_math.h **** 
2297:Core/Inc/arm_math.h ****   /**
2298:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 DCT4/IDCT4 function.
2299:Core/Inc/arm_math.h ****    */
2300:Core/Inc/arm_math.h ****   typedef struct
2301:Core/Inc/arm_math.h ****   {
2302:Core/Inc/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2303:Core/Inc/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2304:Core/Inc/arm_math.h ****     q31_t normalize;                     /**< normalizing factor. */
2305:Core/Inc/arm_math.h ****     q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
2306:Core/Inc/arm_math.h ****     q31_t *pCosFactor;                   /**< points to the cosFactor table. */
2307:Core/Inc/arm_math.h ****     arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
ARM GAS  /tmp/ccpEjOub.s 			page 45


2308:Core/Inc/arm_math.h ****     arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
2309:Core/Inc/arm_math.h ****   } arm_dct4_instance_q31;
2310:Core/Inc/arm_math.h **** 
2311:Core/Inc/arm_math.h **** 
2312:Core/Inc/arm_math.h ****   /**
2313:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 DCT4/IDCT4.
2314:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure.
2315:Core/Inc/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure
2316:Core/Inc/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure
2317:Core/Inc/arm_math.h ****    * @param[in]     N          length of the DCT4.
2318:Core/Inc/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
2319:Core/Inc/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2320:Core/Inc/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2321:Core/Inc/arm_math.h ****    */
2322:Core/Inc/arm_math.h ****   arm_status arm_dct4_init_q31(
2323:Core/Inc/arm_math.h ****   arm_dct4_instance_q31 * S,
2324:Core/Inc/arm_math.h ****   arm_rfft_instance_q31 * S_RFFT,
2325:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_q31 * S_CFFT,
2326:Core/Inc/arm_math.h ****   uint16_t N,
2327:Core/Inc/arm_math.h ****   uint16_t Nby2,
2328:Core/Inc/arm_math.h ****   q31_t normalize);
2329:Core/Inc/arm_math.h **** 
2330:Core/Inc/arm_math.h **** 
2331:Core/Inc/arm_math.h ****   /**
2332:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 DCT4/IDCT4.
2333:Core/Inc/arm_math.h ****    * @param[in]     S              points to an instance of the Q31 DCT4 structure.
2334:Core/Inc/arm_math.h ****    * @param[in]     pState         points to state buffer.
2335:Core/Inc/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2336:Core/Inc/arm_math.h ****    */
2337:Core/Inc/arm_math.h ****   void arm_dct4_q31(
2338:Core/Inc/arm_math.h ****   const arm_dct4_instance_q31 * S,
2339:Core/Inc/arm_math.h ****   q31_t * pState,
2340:Core/Inc/arm_math.h ****   q31_t * pInlineBuffer);
2341:Core/Inc/arm_math.h **** 
2342:Core/Inc/arm_math.h **** 
2343:Core/Inc/arm_math.h ****   /**
2344:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 DCT4/IDCT4 function.
2345:Core/Inc/arm_math.h ****    */
2346:Core/Inc/arm_math.h ****   typedef struct
2347:Core/Inc/arm_math.h ****   {
2348:Core/Inc/arm_math.h ****     uint16_t N;                          /**< length of the DCT4. */
2349:Core/Inc/arm_math.h ****     uint16_t Nby2;                       /**< half of the length of the DCT4. */
2350:Core/Inc/arm_math.h ****     q15_t normalize;                     /**< normalizing factor. */
2351:Core/Inc/arm_math.h ****     q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
2352:Core/Inc/arm_math.h ****     q15_t *pCosFactor;                   /**< points to the cosFactor table. */
2353:Core/Inc/arm_math.h ****     arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
2354:Core/Inc/arm_math.h ****     arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
2355:Core/Inc/arm_math.h ****   } arm_dct4_instance_q15;
2356:Core/Inc/arm_math.h **** 
2357:Core/Inc/arm_math.h **** 
2358:Core/Inc/arm_math.h ****   /**
2359:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 DCT4/IDCT4.
2360:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure.
2361:Core/Inc/arm_math.h ****    * @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure.
2362:Core/Inc/arm_math.h ****    * @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure.
2363:Core/Inc/arm_math.h ****    * @param[in]     N          length of the DCT4.
2364:Core/Inc/arm_math.h ****    * @param[in]     Nby2       half of the length of the DCT4.
ARM GAS  /tmp/ccpEjOub.s 			page 46


2365:Core/Inc/arm_math.h ****    * @param[in]     normalize  normalizing factor.
2366:Core/Inc/arm_math.h ****    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or A
2367:Core/Inc/arm_math.h ****    */
2368:Core/Inc/arm_math.h ****   arm_status arm_dct4_init_q15(
2369:Core/Inc/arm_math.h ****   arm_dct4_instance_q15 * S,
2370:Core/Inc/arm_math.h ****   arm_rfft_instance_q15 * S_RFFT,
2371:Core/Inc/arm_math.h ****   arm_cfft_radix4_instance_q15 * S_CFFT,
2372:Core/Inc/arm_math.h ****   uint16_t N,
2373:Core/Inc/arm_math.h ****   uint16_t Nby2,
2374:Core/Inc/arm_math.h ****   q15_t normalize);
2375:Core/Inc/arm_math.h **** 
2376:Core/Inc/arm_math.h **** 
2377:Core/Inc/arm_math.h ****   /**
2378:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 DCT4/IDCT4.
2379:Core/Inc/arm_math.h ****    * @param[in]     S              points to an instance of the Q15 DCT4 structure.
2380:Core/Inc/arm_math.h ****    * @param[in]     pState         points to state buffer.
2381:Core/Inc/arm_math.h ****    * @param[in,out] pInlineBuffer  points to the in-place input and output buffer.
2382:Core/Inc/arm_math.h ****    */
2383:Core/Inc/arm_math.h ****   void arm_dct4_q15(
2384:Core/Inc/arm_math.h ****   const arm_dct4_instance_q15 * S,
2385:Core/Inc/arm_math.h ****   q15_t * pState,
2386:Core/Inc/arm_math.h ****   q15_t * pInlineBuffer);
2387:Core/Inc/arm_math.h **** 
2388:Core/Inc/arm_math.h **** 
2389:Core/Inc/arm_math.h ****   /**
2390:Core/Inc/arm_math.h ****    * @brief Floating-point vector addition.
2391:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2392:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2393:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2394:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2395:Core/Inc/arm_math.h ****    */
2396:Core/Inc/arm_math.h ****   void arm_add_f32(
2397:Core/Inc/arm_math.h ****   float32_t * pSrcA,
2398:Core/Inc/arm_math.h ****   float32_t * pSrcB,
2399:Core/Inc/arm_math.h ****   float32_t * pDst,
2400:Core/Inc/arm_math.h ****   uint32_t blockSize);
2401:Core/Inc/arm_math.h **** 
2402:Core/Inc/arm_math.h **** 
2403:Core/Inc/arm_math.h ****   /**
2404:Core/Inc/arm_math.h ****    * @brief Q7 vector addition.
2405:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2406:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2407:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2408:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2409:Core/Inc/arm_math.h ****    */
2410:Core/Inc/arm_math.h ****   void arm_add_q7(
2411:Core/Inc/arm_math.h ****   q7_t * pSrcA,
2412:Core/Inc/arm_math.h ****   q7_t * pSrcB,
2413:Core/Inc/arm_math.h ****   q7_t * pDst,
2414:Core/Inc/arm_math.h ****   uint32_t blockSize);
2415:Core/Inc/arm_math.h **** 
2416:Core/Inc/arm_math.h **** 
2417:Core/Inc/arm_math.h ****   /**
2418:Core/Inc/arm_math.h ****    * @brief Q15 vector addition.
2419:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2420:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2421:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
ARM GAS  /tmp/ccpEjOub.s 			page 47


2422:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2423:Core/Inc/arm_math.h ****    */
2424:Core/Inc/arm_math.h ****   void arm_add_q15(
2425:Core/Inc/arm_math.h ****   q15_t * pSrcA,
2426:Core/Inc/arm_math.h ****   q15_t * pSrcB,
2427:Core/Inc/arm_math.h ****   q15_t * pDst,
2428:Core/Inc/arm_math.h ****   uint32_t blockSize);
2429:Core/Inc/arm_math.h **** 
2430:Core/Inc/arm_math.h **** 
2431:Core/Inc/arm_math.h ****   /**
2432:Core/Inc/arm_math.h ****    * @brief Q31 vector addition.
2433:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2434:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2435:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2436:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2437:Core/Inc/arm_math.h ****    */
2438:Core/Inc/arm_math.h ****   void arm_add_q31(
2439:Core/Inc/arm_math.h ****   q31_t * pSrcA,
2440:Core/Inc/arm_math.h ****   q31_t * pSrcB,
2441:Core/Inc/arm_math.h ****   q31_t * pDst,
2442:Core/Inc/arm_math.h ****   uint32_t blockSize);
2443:Core/Inc/arm_math.h **** 
2444:Core/Inc/arm_math.h **** 
2445:Core/Inc/arm_math.h ****   /**
2446:Core/Inc/arm_math.h ****    * @brief Floating-point vector subtraction.
2447:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2448:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2449:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2450:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2451:Core/Inc/arm_math.h ****    */
2452:Core/Inc/arm_math.h ****   void arm_sub_f32(
2453:Core/Inc/arm_math.h ****   float32_t * pSrcA,
2454:Core/Inc/arm_math.h ****   float32_t * pSrcB,
2455:Core/Inc/arm_math.h ****   float32_t * pDst,
2456:Core/Inc/arm_math.h ****   uint32_t blockSize);
2457:Core/Inc/arm_math.h **** 
2458:Core/Inc/arm_math.h **** 
2459:Core/Inc/arm_math.h ****   /**
2460:Core/Inc/arm_math.h ****    * @brief Q7 vector subtraction.
2461:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2462:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2463:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2464:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2465:Core/Inc/arm_math.h ****    */
2466:Core/Inc/arm_math.h ****   void arm_sub_q7(
2467:Core/Inc/arm_math.h ****   q7_t * pSrcA,
2468:Core/Inc/arm_math.h ****   q7_t * pSrcB,
2469:Core/Inc/arm_math.h ****   q7_t * pDst,
2470:Core/Inc/arm_math.h ****   uint32_t blockSize);
2471:Core/Inc/arm_math.h **** 
2472:Core/Inc/arm_math.h **** 
2473:Core/Inc/arm_math.h ****   /**
2474:Core/Inc/arm_math.h ****    * @brief Q15 vector subtraction.
2475:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2476:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2477:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2478:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
ARM GAS  /tmp/ccpEjOub.s 			page 48


2479:Core/Inc/arm_math.h ****    */
2480:Core/Inc/arm_math.h ****   void arm_sub_q15(
2481:Core/Inc/arm_math.h ****   q15_t * pSrcA,
2482:Core/Inc/arm_math.h ****   q15_t * pSrcB,
2483:Core/Inc/arm_math.h ****   q15_t * pDst,
2484:Core/Inc/arm_math.h ****   uint32_t blockSize);
2485:Core/Inc/arm_math.h **** 
2486:Core/Inc/arm_math.h **** 
2487:Core/Inc/arm_math.h ****   /**
2488:Core/Inc/arm_math.h ****    * @brief Q31 vector subtraction.
2489:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2490:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2491:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2492:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2493:Core/Inc/arm_math.h ****    */
2494:Core/Inc/arm_math.h ****   void arm_sub_q31(
2495:Core/Inc/arm_math.h ****   q31_t * pSrcA,
2496:Core/Inc/arm_math.h ****   q31_t * pSrcB,
2497:Core/Inc/arm_math.h ****   q31_t * pDst,
2498:Core/Inc/arm_math.h ****   uint32_t blockSize);
2499:Core/Inc/arm_math.h **** 
2500:Core/Inc/arm_math.h **** 
2501:Core/Inc/arm_math.h ****   /**
2502:Core/Inc/arm_math.h ****    * @brief Multiplies a floating-point vector by a scalar.
2503:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2504:Core/Inc/arm_math.h ****    * @param[in]  scale      scale factor to be applied
2505:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2506:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2507:Core/Inc/arm_math.h ****    */
2508:Core/Inc/arm_math.h ****   void arm_scale_f32(
2509:Core/Inc/arm_math.h ****   float32_t * pSrc,
2510:Core/Inc/arm_math.h ****   float32_t scale,
2511:Core/Inc/arm_math.h ****   float32_t * pDst,
2512:Core/Inc/arm_math.h ****   uint32_t blockSize);
2513:Core/Inc/arm_math.h **** 
2514:Core/Inc/arm_math.h **** 
2515:Core/Inc/arm_math.h ****   /**
2516:Core/Inc/arm_math.h ****    * @brief Multiplies a Q7 vector by a scalar.
2517:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2518:Core/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2519:Core/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2520:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
2521:Core/Inc/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2522:Core/Inc/arm_math.h ****    */
2523:Core/Inc/arm_math.h ****   void arm_scale_q7(
2524:Core/Inc/arm_math.h ****   q7_t * pSrc,
2525:Core/Inc/arm_math.h ****   q7_t scaleFract,
2526:Core/Inc/arm_math.h ****   int8_t shift,
2527:Core/Inc/arm_math.h ****   q7_t * pDst,
2528:Core/Inc/arm_math.h ****   uint32_t blockSize);
2529:Core/Inc/arm_math.h **** 
2530:Core/Inc/arm_math.h **** 
2531:Core/Inc/arm_math.h ****   /**
2532:Core/Inc/arm_math.h ****    * @brief Multiplies a Q15 vector by a scalar.
2533:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2534:Core/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2535:Core/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
ARM GAS  /tmp/ccpEjOub.s 			page 49


2536:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
2537:Core/Inc/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2538:Core/Inc/arm_math.h ****    */
2539:Core/Inc/arm_math.h ****   void arm_scale_q15(
2540:Core/Inc/arm_math.h ****   q15_t * pSrc,
2541:Core/Inc/arm_math.h ****   q15_t scaleFract,
2542:Core/Inc/arm_math.h ****   int8_t shift,
2543:Core/Inc/arm_math.h ****   q15_t * pDst,
2544:Core/Inc/arm_math.h ****   uint32_t blockSize);
2545:Core/Inc/arm_math.h **** 
2546:Core/Inc/arm_math.h **** 
2547:Core/Inc/arm_math.h ****   /**
2548:Core/Inc/arm_math.h ****    * @brief Multiplies a Q31 vector by a scalar.
2549:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
2550:Core/Inc/arm_math.h ****    * @param[in]  scaleFract  fractional portion of the scale value
2551:Core/Inc/arm_math.h ****    * @param[in]  shift       number of bits to shift the result by
2552:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
2553:Core/Inc/arm_math.h ****    * @param[in]  blockSize   number of samples in the vector
2554:Core/Inc/arm_math.h ****    */
2555:Core/Inc/arm_math.h ****   void arm_scale_q31(
2556:Core/Inc/arm_math.h ****   q31_t * pSrc,
2557:Core/Inc/arm_math.h ****   q31_t scaleFract,
2558:Core/Inc/arm_math.h ****   int8_t shift,
2559:Core/Inc/arm_math.h ****   q31_t * pDst,
2560:Core/Inc/arm_math.h ****   uint32_t blockSize);
2561:Core/Inc/arm_math.h **** 
2562:Core/Inc/arm_math.h **** 
2563:Core/Inc/arm_math.h ****   /**
2564:Core/Inc/arm_math.h ****    * @brief Q7 vector absolute value.
2565:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2566:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2567:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2568:Core/Inc/arm_math.h ****    */
2569:Core/Inc/arm_math.h ****   void arm_abs_q7(
2570:Core/Inc/arm_math.h ****   q7_t * pSrc,
2571:Core/Inc/arm_math.h ****   q7_t * pDst,
2572:Core/Inc/arm_math.h ****   uint32_t blockSize);
2573:Core/Inc/arm_math.h **** 
2574:Core/Inc/arm_math.h **** 
2575:Core/Inc/arm_math.h ****   /**
2576:Core/Inc/arm_math.h ****    * @brief Floating-point vector absolute value.
2577:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2578:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2579:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2580:Core/Inc/arm_math.h ****    */
2581:Core/Inc/arm_math.h ****   void arm_abs_f32(
2582:Core/Inc/arm_math.h ****   float32_t * pSrc,
2583:Core/Inc/arm_math.h ****   float32_t * pDst,
2584:Core/Inc/arm_math.h ****   uint32_t blockSize);
2585:Core/Inc/arm_math.h **** 
2586:Core/Inc/arm_math.h **** 
2587:Core/Inc/arm_math.h ****   /**
2588:Core/Inc/arm_math.h ****    * @brief Q15 vector absolute value.
2589:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2590:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2591:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2592:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 50


2593:Core/Inc/arm_math.h ****   void arm_abs_q15(
2594:Core/Inc/arm_math.h ****   q15_t * pSrc,
2595:Core/Inc/arm_math.h ****   q15_t * pDst,
2596:Core/Inc/arm_math.h ****   uint32_t blockSize);
2597:Core/Inc/arm_math.h **** 
2598:Core/Inc/arm_math.h **** 
2599:Core/Inc/arm_math.h ****   /**
2600:Core/Inc/arm_math.h ****    * @brief Q31 vector absolute value.
2601:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input buffer
2602:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output buffer
2603:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2604:Core/Inc/arm_math.h ****    */
2605:Core/Inc/arm_math.h ****   void arm_abs_q31(
2606:Core/Inc/arm_math.h ****   q31_t * pSrc,
2607:Core/Inc/arm_math.h ****   q31_t * pDst,
2608:Core/Inc/arm_math.h ****   uint32_t blockSize);
2609:Core/Inc/arm_math.h **** 
2610:Core/Inc/arm_math.h **** 
2611:Core/Inc/arm_math.h ****   /**
2612:Core/Inc/arm_math.h ****    * @brief Dot product of floating-point vectors.
2613:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2614:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2615:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2616:Core/Inc/arm_math.h ****    * @param[out] result     output result returned here
2617:Core/Inc/arm_math.h ****    */
2618:Core/Inc/arm_math.h ****   void arm_dot_prod_f32(
2619:Core/Inc/arm_math.h ****   float32_t * pSrcA,
2620:Core/Inc/arm_math.h ****   float32_t * pSrcB,
2621:Core/Inc/arm_math.h ****   uint32_t blockSize,
2622:Core/Inc/arm_math.h ****   float32_t * result);
2623:Core/Inc/arm_math.h **** 
2624:Core/Inc/arm_math.h **** 
2625:Core/Inc/arm_math.h ****   /**
2626:Core/Inc/arm_math.h ****    * @brief Dot product of Q7 vectors.
2627:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2628:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2629:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2630:Core/Inc/arm_math.h ****    * @param[out] result     output result returned here
2631:Core/Inc/arm_math.h ****    */
2632:Core/Inc/arm_math.h ****   void arm_dot_prod_q7(
2633:Core/Inc/arm_math.h ****   q7_t * pSrcA,
2634:Core/Inc/arm_math.h ****   q7_t * pSrcB,
2635:Core/Inc/arm_math.h ****   uint32_t blockSize,
2636:Core/Inc/arm_math.h ****   q31_t * result);
2637:Core/Inc/arm_math.h **** 
2638:Core/Inc/arm_math.h **** 
2639:Core/Inc/arm_math.h ****   /**
2640:Core/Inc/arm_math.h ****    * @brief Dot product of Q15 vectors.
2641:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2642:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2643:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2644:Core/Inc/arm_math.h ****    * @param[out] result     output result returned here
2645:Core/Inc/arm_math.h ****    */
2646:Core/Inc/arm_math.h ****   void arm_dot_prod_q15(
2647:Core/Inc/arm_math.h ****   q15_t * pSrcA,
2648:Core/Inc/arm_math.h ****   q15_t * pSrcB,
2649:Core/Inc/arm_math.h ****   uint32_t blockSize,
ARM GAS  /tmp/ccpEjOub.s 			page 51


2650:Core/Inc/arm_math.h ****   q63_t * result);
2651:Core/Inc/arm_math.h **** 
2652:Core/Inc/arm_math.h **** 
2653:Core/Inc/arm_math.h ****   /**
2654:Core/Inc/arm_math.h ****    * @brief Dot product of Q31 vectors.
2655:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input vector
2656:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input vector
2657:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in each vector
2658:Core/Inc/arm_math.h ****    * @param[out] result     output result returned here
2659:Core/Inc/arm_math.h ****    */
2660:Core/Inc/arm_math.h ****   void arm_dot_prod_q31(
2661:Core/Inc/arm_math.h ****   q31_t * pSrcA,
2662:Core/Inc/arm_math.h ****   q31_t * pSrcB,
2663:Core/Inc/arm_math.h ****   uint32_t blockSize,
2664:Core/Inc/arm_math.h ****   q63_t * result);
2665:Core/Inc/arm_math.h **** 
2666:Core/Inc/arm_math.h **** 
2667:Core/Inc/arm_math.h ****   /**
2668:Core/Inc/arm_math.h ****    * @brief  Shifts the elements of a Q7 vector a specified number of bits.
2669:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2670:Core/Inc/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2671:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2672:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2673:Core/Inc/arm_math.h ****    */
2674:Core/Inc/arm_math.h ****   void arm_shift_q7(
2675:Core/Inc/arm_math.h ****   q7_t * pSrc,
2676:Core/Inc/arm_math.h ****   int8_t shiftBits,
2677:Core/Inc/arm_math.h ****   q7_t * pDst,
2678:Core/Inc/arm_math.h ****   uint32_t blockSize);
2679:Core/Inc/arm_math.h **** 
2680:Core/Inc/arm_math.h **** 
2681:Core/Inc/arm_math.h ****   /**
2682:Core/Inc/arm_math.h ****    * @brief  Shifts the elements of a Q15 vector a specified number of bits.
2683:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2684:Core/Inc/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2685:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2686:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2687:Core/Inc/arm_math.h ****    */
2688:Core/Inc/arm_math.h ****   void arm_shift_q15(
2689:Core/Inc/arm_math.h ****   q15_t * pSrc,
2690:Core/Inc/arm_math.h ****   int8_t shiftBits,
2691:Core/Inc/arm_math.h ****   q15_t * pDst,
2692:Core/Inc/arm_math.h ****   uint32_t blockSize);
2693:Core/Inc/arm_math.h **** 
2694:Core/Inc/arm_math.h **** 
2695:Core/Inc/arm_math.h ****   /**
2696:Core/Inc/arm_math.h ****    * @brief  Shifts the elements of a Q31 vector a specified number of bits.
2697:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2698:Core/Inc/arm_math.h ****    * @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative valu
2699:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2700:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2701:Core/Inc/arm_math.h ****    */
2702:Core/Inc/arm_math.h ****   void arm_shift_q31(
2703:Core/Inc/arm_math.h ****   q31_t * pSrc,
2704:Core/Inc/arm_math.h ****   int8_t shiftBits,
2705:Core/Inc/arm_math.h ****   q31_t * pDst,
2706:Core/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /tmp/ccpEjOub.s 			page 52


2707:Core/Inc/arm_math.h **** 
2708:Core/Inc/arm_math.h **** 
2709:Core/Inc/arm_math.h ****   /**
2710:Core/Inc/arm_math.h ****    * @brief  Adds a constant offset to a floating-point vector.
2711:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2712:Core/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2713:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2714:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2715:Core/Inc/arm_math.h ****    */
2716:Core/Inc/arm_math.h ****   void arm_offset_f32(
2717:Core/Inc/arm_math.h ****   float32_t * pSrc,
2718:Core/Inc/arm_math.h ****   float32_t offset,
2719:Core/Inc/arm_math.h ****   float32_t * pDst,
2720:Core/Inc/arm_math.h ****   uint32_t blockSize);
2721:Core/Inc/arm_math.h **** 
2722:Core/Inc/arm_math.h **** 
2723:Core/Inc/arm_math.h ****   /**
2724:Core/Inc/arm_math.h ****    * @brief  Adds a constant offset to a Q7 vector.
2725:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2726:Core/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2727:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2728:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2729:Core/Inc/arm_math.h ****    */
2730:Core/Inc/arm_math.h ****   void arm_offset_q7(
2731:Core/Inc/arm_math.h ****   q7_t * pSrc,
2732:Core/Inc/arm_math.h ****   q7_t offset,
2733:Core/Inc/arm_math.h ****   q7_t * pDst,
2734:Core/Inc/arm_math.h ****   uint32_t blockSize);
2735:Core/Inc/arm_math.h **** 
2736:Core/Inc/arm_math.h **** 
2737:Core/Inc/arm_math.h ****   /**
2738:Core/Inc/arm_math.h ****    * @brief  Adds a constant offset to a Q15 vector.
2739:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2740:Core/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2741:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2742:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2743:Core/Inc/arm_math.h ****    */
2744:Core/Inc/arm_math.h ****   void arm_offset_q15(
2745:Core/Inc/arm_math.h ****   q15_t * pSrc,
2746:Core/Inc/arm_math.h ****   q15_t offset,
2747:Core/Inc/arm_math.h ****   q15_t * pDst,
2748:Core/Inc/arm_math.h ****   uint32_t blockSize);
2749:Core/Inc/arm_math.h **** 
2750:Core/Inc/arm_math.h **** 
2751:Core/Inc/arm_math.h ****   /**
2752:Core/Inc/arm_math.h ****    * @brief  Adds a constant offset to a Q31 vector.
2753:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2754:Core/Inc/arm_math.h ****    * @param[in]  offset     is the offset to be added
2755:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2756:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2757:Core/Inc/arm_math.h ****    */
2758:Core/Inc/arm_math.h ****   void arm_offset_q31(
2759:Core/Inc/arm_math.h ****   q31_t * pSrc,
2760:Core/Inc/arm_math.h ****   q31_t offset,
2761:Core/Inc/arm_math.h ****   q31_t * pDst,
2762:Core/Inc/arm_math.h ****   uint32_t blockSize);
2763:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 53


2764:Core/Inc/arm_math.h **** 
2765:Core/Inc/arm_math.h ****   /**
2766:Core/Inc/arm_math.h ****    * @brief  Negates the elements of a floating-point vector.
2767:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2768:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2769:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2770:Core/Inc/arm_math.h ****    */
2771:Core/Inc/arm_math.h ****   void arm_negate_f32(
2772:Core/Inc/arm_math.h ****   float32_t * pSrc,
2773:Core/Inc/arm_math.h ****   float32_t * pDst,
2774:Core/Inc/arm_math.h ****   uint32_t blockSize);
2775:Core/Inc/arm_math.h **** 
2776:Core/Inc/arm_math.h **** 
2777:Core/Inc/arm_math.h ****   /**
2778:Core/Inc/arm_math.h ****    * @brief  Negates the elements of a Q7 vector.
2779:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2780:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2781:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2782:Core/Inc/arm_math.h ****    */
2783:Core/Inc/arm_math.h ****   void arm_negate_q7(
2784:Core/Inc/arm_math.h ****   q7_t * pSrc,
2785:Core/Inc/arm_math.h ****   q7_t * pDst,
2786:Core/Inc/arm_math.h ****   uint32_t blockSize);
2787:Core/Inc/arm_math.h **** 
2788:Core/Inc/arm_math.h **** 
2789:Core/Inc/arm_math.h ****   /**
2790:Core/Inc/arm_math.h ****    * @brief  Negates the elements of a Q15 vector.
2791:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2792:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2793:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2794:Core/Inc/arm_math.h ****    */
2795:Core/Inc/arm_math.h ****   void arm_negate_q15(
2796:Core/Inc/arm_math.h ****   q15_t * pSrc,
2797:Core/Inc/arm_math.h ****   q15_t * pDst,
2798:Core/Inc/arm_math.h ****   uint32_t blockSize);
2799:Core/Inc/arm_math.h **** 
2800:Core/Inc/arm_math.h **** 
2801:Core/Inc/arm_math.h ****   /**
2802:Core/Inc/arm_math.h ****    * @brief  Negates the elements of a Q31 vector.
2803:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the input vector
2804:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the output vector
2805:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples in the vector
2806:Core/Inc/arm_math.h ****    */
2807:Core/Inc/arm_math.h ****   void arm_negate_q31(
2808:Core/Inc/arm_math.h ****   q31_t * pSrc,
2809:Core/Inc/arm_math.h ****   q31_t * pDst,
2810:Core/Inc/arm_math.h ****   uint32_t blockSize);
2811:Core/Inc/arm_math.h **** 
2812:Core/Inc/arm_math.h **** 
2813:Core/Inc/arm_math.h ****   /**
2814:Core/Inc/arm_math.h ****    * @brief  Copies the elements of a floating-point vector.
2815:Core/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2816:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2817:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2818:Core/Inc/arm_math.h ****    */
2819:Core/Inc/arm_math.h ****   void arm_copy_f32(
2820:Core/Inc/arm_math.h ****   float32_t * pSrc,
ARM GAS  /tmp/ccpEjOub.s 			page 54


2821:Core/Inc/arm_math.h ****   float32_t * pDst,
2822:Core/Inc/arm_math.h ****   uint32_t blockSize);
2823:Core/Inc/arm_math.h **** 
2824:Core/Inc/arm_math.h **** 
2825:Core/Inc/arm_math.h ****   /**
2826:Core/Inc/arm_math.h ****    * @brief  Copies the elements of a Q7 vector.
2827:Core/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2828:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2829:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2830:Core/Inc/arm_math.h ****    */
2831:Core/Inc/arm_math.h ****   void arm_copy_q7(
2832:Core/Inc/arm_math.h ****   q7_t * pSrc,
2833:Core/Inc/arm_math.h ****   q7_t * pDst,
2834:Core/Inc/arm_math.h ****   uint32_t blockSize);
2835:Core/Inc/arm_math.h **** 
2836:Core/Inc/arm_math.h **** 
2837:Core/Inc/arm_math.h ****   /**
2838:Core/Inc/arm_math.h ****    * @brief  Copies the elements of a Q15 vector.
2839:Core/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2840:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2841:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2842:Core/Inc/arm_math.h ****    */
2843:Core/Inc/arm_math.h ****   void arm_copy_q15(
2844:Core/Inc/arm_math.h ****   q15_t * pSrc,
2845:Core/Inc/arm_math.h ****   q15_t * pDst,
2846:Core/Inc/arm_math.h ****   uint32_t blockSize);
2847:Core/Inc/arm_math.h **** 
2848:Core/Inc/arm_math.h **** 
2849:Core/Inc/arm_math.h ****   /**
2850:Core/Inc/arm_math.h ****    * @brief  Copies the elements of a Q31 vector.
2851:Core/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
2852:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2853:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2854:Core/Inc/arm_math.h ****    */
2855:Core/Inc/arm_math.h ****   void arm_copy_q31(
2856:Core/Inc/arm_math.h ****   q31_t * pSrc,
2857:Core/Inc/arm_math.h ****   q31_t * pDst,
2858:Core/Inc/arm_math.h ****   uint32_t blockSize);
2859:Core/Inc/arm_math.h **** 
2860:Core/Inc/arm_math.h **** 
2861:Core/Inc/arm_math.h ****   /**
2862:Core/Inc/arm_math.h ****    * @brief  Fills a constant value into a floating-point vector.
2863:Core/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2864:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2865:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2866:Core/Inc/arm_math.h ****    */
2867:Core/Inc/arm_math.h ****   void arm_fill_f32(
2868:Core/Inc/arm_math.h ****   float32_t value,
2869:Core/Inc/arm_math.h ****   float32_t * pDst,
2870:Core/Inc/arm_math.h ****   uint32_t blockSize);
2871:Core/Inc/arm_math.h **** 
2872:Core/Inc/arm_math.h **** 
2873:Core/Inc/arm_math.h ****   /**
2874:Core/Inc/arm_math.h ****    * @brief  Fills a constant value into a Q7 vector.
2875:Core/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2876:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2877:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
ARM GAS  /tmp/ccpEjOub.s 			page 55


2878:Core/Inc/arm_math.h ****    */
2879:Core/Inc/arm_math.h ****   void arm_fill_q7(
2880:Core/Inc/arm_math.h ****   q7_t value,
2881:Core/Inc/arm_math.h ****   q7_t * pDst,
2882:Core/Inc/arm_math.h ****   uint32_t blockSize);
2883:Core/Inc/arm_math.h **** 
2884:Core/Inc/arm_math.h **** 
2885:Core/Inc/arm_math.h ****   /**
2886:Core/Inc/arm_math.h ****    * @brief  Fills a constant value into a Q15 vector.
2887:Core/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2888:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2889:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2890:Core/Inc/arm_math.h ****    */
2891:Core/Inc/arm_math.h ****   void arm_fill_q15(
2892:Core/Inc/arm_math.h ****   q15_t value,
2893:Core/Inc/arm_math.h ****   q15_t * pDst,
2894:Core/Inc/arm_math.h ****   uint32_t blockSize);
2895:Core/Inc/arm_math.h **** 
2896:Core/Inc/arm_math.h **** 
2897:Core/Inc/arm_math.h ****   /**
2898:Core/Inc/arm_math.h ****    * @brief  Fills a constant value into a Q31 vector.
2899:Core/Inc/arm_math.h ****    * @param[in]  value      input value to be filled
2900:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
2901:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
2902:Core/Inc/arm_math.h ****    */
2903:Core/Inc/arm_math.h ****   void arm_fill_q31(
2904:Core/Inc/arm_math.h ****   q31_t value,
2905:Core/Inc/arm_math.h ****   q31_t * pDst,
2906:Core/Inc/arm_math.h ****   uint32_t blockSize);
2907:Core/Inc/arm_math.h **** 
2908:Core/Inc/arm_math.h **** 
2909:Core/Inc/arm_math.h **** /**
2910:Core/Inc/arm_math.h ****  * @brief Convolution of floating-point sequences.
2911:Core/Inc/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2912:Core/Inc/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2913:Core/Inc/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2914:Core/Inc/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2915:Core/Inc/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2916:Core/Inc/arm_math.h ****  */
2917:Core/Inc/arm_math.h ****   void arm_conv_f32(
2918:Core/Inc/arm_math.h ****   float32_t * pSrcA,
2919:Core/Inc/arm_math.h ****   uint32_t srcALen,
2920:Core/Inc/arm_math.h ****   float32_t * pSrcB,
2921:Core/Inc/arm_math.h ****   uint32_t srcBLen,
2922:Core/Inc/arm_math.h ****   float32_t * pDst);
2923:Core/Inc/arm_math.h **** 
2924:Core/Inc/arm_math.h **** 
2925:Core/Inc/arm_math.h ****   /**
2926:Core/Inc/arm_math.h ****    * @brief Convolution of Q15 sequences.
2927:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2928:Core/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2929:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2930:Core/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2931:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2932:Core/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2933:Core/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2934:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 56


2935:Core/Inc/arm_math.h ****   void arm_conv_opt_q15(
2936:Core/Inc/arm_math.h ****   q15_t * pSrcA,
2937:Core/Inc/arm_math.h ****   uint32_t srcALen,
2938:Core/Inc/arm_math.h ****   q15_t * pSrcB,
2939:Core/Inc/arm_math.h ****   uint32_t srcBLen,
2940:Core/Inc/arm_math.h ****   q15_t * pDst,
2941:Core/Inc/arm_math.h ****   q15_t * pScratch1,
2942:Core/Inc/arm_math.h ****   q15_t * pScratch2);
2943:Core/Inc/arm_math.h **** 
2944:Core/Inc/arm_math.h **** 
2945:Core/Inc/arm_math.h **** /**
2946:Core/Inc/arm_math.h ****  * @brief Convolution of Q15 sequences.
2947:Core/Inc/arm_math.h ****  * @param[in]  pSrcA    points to the first input sequence.
2948:Core/Inc/arm_math.h ****  * @param[in]  srcALen  length of the first input sequence.
2949:Core/Inc/arm_math.h ****  * @param[in]  pSrcB    points to the second input sequence.
2950:Core/Inc/arm_math.h ****  * @param[in]  srcBLen  length of the second input sequence.
2951:Core/Inc/arm_math.h ****  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+
2952:Core/Inc/arm_math.h ****  */
2953:Core/Inc/arm_math.h ****   void arm_conv_q15(
2954:Core/Inc/arm_math.h ****   q15_t * pSrcA,
2955:Core/Inc/arm_math.h ****   uint32_t srcALen,
2956:Core/Inc/arm_math.h ****   q15_t * pSrcB,
2957:Core/Inc/arm_math.h ****   uint32_t srcBLen,
2958:Core/Inc/arm_math.h ****   q15_t * pDst);
2959:Core/Inc/arm_math.h **** 
2960:Core/Inc/arm_math.h **** 
2961:Core/Inc/arm_math.h ****   /**
2962:Core/Inc/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
2963:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
2964:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
2965:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
2966:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
2967:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
2968:Core/Inc/arm_math.h ****    */
2969:Core/Inc/arm_math.h ****   void arm_conv_fast_q15(
2970:Core/Inc/arm_math.h ****           q15_t * pSrcA,
2971:Core/Inc/arm_math.h ****           uint32_t srcALen,
2972:Core/Inc/arm_math.h ****           q15_t * pSrcB,
2973:Core/Inc/arm_math.h ****           uint32_t srcBLen,
2974:Core/Inc/arm_math.h ****           q15_t * pDst);
2975:Core/Inc/arm_math.h **** 
2976:Core/Inc/arm_math.h **** 
2977:Core/Inc/arm_math.h ****   /**
2978:Core/Inc/arm_math.h ****    * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
2979:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
2980:Core/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
2981:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
2982:Core/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
2983:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
2984:Core/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen,
2985:Core/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
2986:Core/Inc/arm_math.h ****    */
2987:Core/Inc/arm_math.h ****   void arm_conv_fast_opt_q15(
2988:Core/Inc/arm_math.h ****   q15_t * pSrcA,
2989:Core/Inc/arm_math.h ****   uint32_t srcALen,
2990:Core/Inc/arm_math.h ****   q15_t * pSrcB,
2991:Core/Inc/arm_math.h ****   uint32_t srcBLen,
ARM GAS  /tmp/ccpEjOub.s 			page 57


2992:Core/Inc/arm_math.h ****   q15_t * pDst,
2993:Core/Inc/arm_math.h ****   q15_t * pScratch1,
2994:Core/Inc/arm_math.h ****   q15_t * pScratch2);
2995:Core/Inc/arm_math.h **** 
2996:Core/Inc/arm_math.h **** 
2997:Core/Inc/arm_math.h ****   /**
2998:Core/Inc/arm_math.h ****    * @brief Convolution of Q31 sequences.
2999:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3000:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3001:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3002:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3003:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3004:Core/Inc/arm_math.h ****    */
3005:Core/Inc/arm_math.h ****   void arm_conv_q31(
3006:Core/Inc/arm_math.h ****   q31_t * pSrcA,
3007:Core/Inc/arm_math.h ****   uint32_t srcALen,
3008:Core/Inc/arm_math.h ****   q31_t * pSrcB,
3009:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3010:Core/Inc/arm_math.h ****   q31_t * pDst);
3011:Core/Inc/arm_math.h **** 
3012:Core/Inc/arm_math.h **** 
3013:Core/Inc/arm_math.h ****   /**
3014:Core/Inc/arm_math.h ****    * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3015:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3016:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3017:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3018:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3019:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3020:Core/Inc/arm_math.h ****    */
3021:Core/Inc/arm_math.h ****   void arm_conv_fast_q31(
3022:Core/Inc/arm_math.h ****   q31_t * pSrcA,
3023:Core/Inc/arm_math.h ****   uint32_t srcALen,
3024:Core/Inc/arm_math.h ****   q31_t * pSrcB,
3025:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3026:Core/Inc/arm_math.h ****   q31_t * pDst);
3027:Core/Inc/arm_math.h **** 
3028:Core/Inc/arm_math.h **** 
3029:Core/Inc/arm_math.h ****     /**
3030:Core/Inc/arm_math.h ****    * @brief Convolution of Q7 sequences.
3031:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
3032:Core/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
3033:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
3034:Core/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
3035:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1.
3036:Core/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
3037:Core/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
3038:Core/Inc/arm_math.h ****    */
3039:Core/Inc/arm_math.h ****   void arm_conv_opt_q7(
3040:Core/Inc/arm_math.h ****   q7_t * pSrcA,
3041:Core/Inc/arm_math.h ****   uint32_t srcALen,
3042:Core/Inc/arm_math.h ****   q7_t * pSrcB,
3043:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3044:Core/Inc/arm_math.h ****   q7_t * pDst,
3045:Core/Inc/arm_math.h ****   q15_t * pScratch1,
3046:Core/Inc/arm_math.h ****   q15_t * pScratch2);
3047:Core/Inc/arm_math.h **** 
3048:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 58


3049:Core/Inc/arm_math.h ****   /**
3050:Core/Inc/arm_math.h ****    * @brief Convolution of Q7 sequences.
3051:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
3052:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
3053:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
3054:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
3055:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
3056:Core/Inc/arm_math.h ****    */
3057:Core/Inc/arm_math.h ****   void arm_conv_q7(
3058:Core/Inc/arm_math.h ****   q7_t * pSrcA,
3059:Core/Inc/arm_math.h ****   uint32_t srcALen,
3060:Core/Inc/arm_math.h ****   q7_t * pSrcB,
3061:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3062:Core/Inc/arm_math.h ****   q7_t * pDst);
3063:Core/Inc/arm_math.h **** 
3064:Core/Inc/arm_math.h **** 
3065:Core/Inc/arm_math.h ****   /**
3066:Core/Inc/arm_math.h ****    * @brief Partial convolution of floating-point sequences.
3067:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3068:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3069:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3070:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3071:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3072:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3073:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3074:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3075:Core/Inc/arm_math.h ****    */
3076:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_f32(
3077:Core/Inc/arm_math.h ****   float32_t * pSrcA,
3078:Core/Inc/arm_math.h ****   uint32_t srcALen,
3079:Core/Inc/arm_math.h ****   float32_t * pSrcB,
3080:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3081:Core/Inc/arm_math.h ****   float32_t * pDst,
3082:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3083:Core/Inc/arm_math.h ****   uint32_t numPoints);
3084:Core/Inc/arm_math.h **** 
3085:Core/Inc/arm_math.h **** 
3086:Core/Inc/arm_math.h ****   /**
3087:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3088:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3089:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3090:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3091:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3092:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3093:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3094:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3095:Core/Inc/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
3096:Core/Inc/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3097:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3098:Core/Inc/arm_math.h ****    */
3099:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_opt_q15(
3100:Core/Inc/arm_math.h ****   q15_t * pSrcA,
3101:Core/Inc/arm_math.h ****   uint32_t srcALen,
3102:Core/Inc/arm_math.h ****   q15_t * pSrcB,
3103:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3104:Core/Inc/arm_math.h ****   q15_t * pDst,
3105:Core/Inc/arm_math.h ****   uint32_t firstIndex,
ARM GAS  /tmp/ccpEjOub.s 			page 59


3106:Core/Inc/arm_math.h ****   uint32_t numPoints,
3107:Core/Inc/arm_math.h ****   q15_t * pScratch1,
3108:Core/Inc/arm_math.h ****   q15_t * pScratch2);
3109:Core/Inc/arm_math.h **** 
3110:Core/Inc/arm_math.h **** 
3111:Core/Inc/arm_math.h ****   /**
3112:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences.
3113:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3114:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3115:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3116:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3117:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3118:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3119:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3120:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3121:Core/Inc/arm_math.h ****    */
3122:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_q15(
3123:Core/Inc/arm_math.h ****   q15_t * pSrcA,
3124:Core/Inc/arm_math.h ****   uint32_t srcALen,
3125:Core/Inc/arm_math.h ****   q15_t * pSrcB,
3126:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3127:Core/Inc/arm_math.h ****   q15_t * pDst,
3128:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3129:Core/Inc/arm_math.h ****   uint32_t numPoints);
3130:Core/Inc/arm_math.h **** 
3131:Core/Inc/arm_math.h **** 
3132:Core/Inc/arm_math.h ****   /**
3133:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3134:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3135:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3136:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3137:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3138:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3139:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3140:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3141:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3142:Core/Inc/arm_math.h ****    */
3143:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_fast_q15(
3144:Core/Inc/arm_math.h ****   q15_t * pSrcA,
3145:Core/Inc/arm_math.h ****   uint32_t srcALen,
3146:Core/Inc/arm_math.h ****   q15_t * pSrcB,
3147:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3148:Core/Inc/arm_math.h ****   q15_t * pDst,
3149:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3150:Core/Inc/arm_math.h ****   uint32_t numPoints);
3151:Core/Inc/arm_math.h **** 
3152:Core/Inc/arm_math.h **** 
3153:Core/Inc/arm_math.h ****   /**
3154:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
3155:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3156:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3157:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3158:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3159:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3160:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3161:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3162:Core/Inc/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen
ARM GAS  /tmp/ccpEjOub.s 			page 60


3163:Core/Inc/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen).
3164:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3165:Core/Inc/arm_math.h ****    */
3166:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_fast_opt_q15(
3167:Core/Inc/arm_math.h ****   q15_t * pSrcA,
3168:Core/Inc/arm_math.h ****   uint32_t srcALen,
3169:Core/Inc/arm_math.h ****   q15_t * pSrcB,
3170:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3171:Core/Inc/arm_math.h ****   q15_t * pDst,
3172:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3173:Core/Inc/arm_math.h ****   uint32_t numPoints,
3174:Core/Inc/arm_math.h ****   q15_t * pScratch1,
3175:Core/Inc/arm_math.h ****   q15_t * pScratch2);
3176:Core/Inc/arm_math.h **** 
3177:Core/Inc/arm_math.h **** 
3178:Core/Inc/arm_math.h ****   /**
3179:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q31 sequences.
3180:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3181:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3182:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3183:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3184:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3185:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3186:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3187:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3188:Core/Inc/arm_math.h ****    */
3189:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_q31(
3190:Core/Inc/arm_math.h ****   q31_t * pSrcA,
3191:Core/Inc/arm_math.h ****   uint32_t srcALen,
3192:Core/Inc/arm_math.h ****   q31_t * pSrcB,
3193:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3194:Core/Inc/arm_math.h ****   q31_t * pDst,
3195:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3196:Core/Inc/arm_math.h ****   uint32_t numPoints);
3197:Core/Inc/arm_math.h **** 
3198:Core/Inc/arm_math.h **** 
3199:Core/Inc/arm_math.h ****   /**
3200:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
3201:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3202:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3203:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3204:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3205:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3206:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3207:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3208:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3209:Core/Inc/arm_math.h ****    */
3210:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_fast_q31(
3211:Core/Inc/arm_math.h ****   q31_t * pSrcA,
3212:Core/Inc/arm_math.h ****   uint32_t srcALen,
3213:Core/Inc/arm_math.h ****   q31_t * pSrcB,
3214:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3215:Core/Inc/arm_math.h ****   q31_t * pDst,
3216:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3217:Core/Inc/arm_math.h ****   uint32_t numPoints);
3218:Core/Inc/arm_math.h **** 
3219:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 61


3220:Core/Inc/arm_math.h ****   /**
3221:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q7 sequences
3222:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3223:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3224:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3225:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3226:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3227:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3228:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3229:Core/Inc/arm_math.h ****    * @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) 
3230:Core/Inc/arm_math.h ****    * @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)
3231:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3232:Core/Inc/arm_math.h ****    */
3233:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_opt_q7(
3234:Core/Inc/arm_math.h ****   q7_t * pSrcA,
3235:Core/Inc/arm_math.h ****   uint32_t srcALen,
3236:Core/Inc/arm_math.h ****   q7_t * pSrcB,
3237:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3238:Core/Inc/arm_math.h ****   q7_t * pDst,
3239:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3240:Core/Inc/arm_math.h ****   uint32_t numPoints,
3241:Core/Inc/arm_math.h ****   q15_t * pScratch1,
3242:Core/Inc/arm_math.h ****   q15_t * pScratch2);
3243:Core/Inc/arm_math.h **** 
3244:Core/Inc/arm_math.h **** 
3245:Core/Inc/arm_math.h **** /**
3246:Core/Inc/arm_math.h ****    * @brief Partial convolution of Q7 sequences.
3247:Core/Inc/arm_math.h ****    * @param[in]  pSrcA       points to the first input sequence.
3248:Core/Inc/arm_math.h ****    * @param[in]  srcALen     length of the first input sequence.
3249:Core/Inc/arm_math.h ****    * @param[in]  pSrcB       points to the second input sequence.
3250:Core/Inc/arm_math.h ****    * @param[in]  srcBLen     length of the second input sequence.
3251:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
3252:Core/Inc/arm_math.h ****    * @param[in]  firstIndex  is the first output sample to start with.
3253:Core/Inc/arm_math.h ****    * @param[in]  numPoints   is the number of output points to be computed.
3254:Core/Inc/arm_math.h ****    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUM
3255:Core/Inc/arm_math.h ****    */
3256:Core/Inc/arm_math.h ****   arm_status arm_conv_partial_q7(
3257:Core/Inc/arm_math.h ****   q7_t * pSrcA,
3258:Core/Inc/arm_math.h ****   uint32_t srcALen,
3259:Core/Inc/arm_math.h ****   q7_t * pSrcB,
3260:Core/Inc/arm_math.h ****   uint32_t srcBLen,
3261:Core/Inc/arm_math.h ****   q7_t * pDst,
3262:Core/Inc/arm_math.h ****   uint32_t firstIndex,
3263:Core/Inc/arm_math.h ****   uint32_t numPoints);
3264:Core/Inc/arm_math.h **** 
3265:Core/Inc/arm_math.h **** 
3266:Core/Inc/arm_math.h ****   /**
3267:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR decimator.
3268:Core/Inc/arm_math.h ****    */
3269:Core/Inc/arm_math.h ****   typedef struct
3270:Core/Inc/arm_math.h ****   {
3271:Core/Inc/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3272:Core/Inc/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3273:Core/Inc/arm_math.h ****     q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3274:Core/Inc/arm_math.h ****     q15_t *pState;              /**< points to the state variable array. The array is of length num
3275:Core/Inc/arm_math.h ****   } arm_fir_decimate_instance_q15;
3276:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 62


3277:Core/Inc/arm_math.h ****   /**
3278:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR decimator.
3279:Core/Inc/arm_math.h ****    */
3280:Core/Inc/arm_math.h ****   typedef struct
3281:Core/Inc/arm_math.h ****   {
3282:Core/Inc/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3283:Core/Inc/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3284:Core/Inc/arm_math.h ****     q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTap
3285:Core/Inc/arm_math.h ****     q31_t *pState;              /**< points to the state variable array. The array is of length num
3286:Core/Inc/arm_math.h ****   } arm_fir_decimate_instance_q31;
3287:Core/Inc/arm_math.h **** 
3288:Core/Inc/arm_math.h ****   /**
3289:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR decimator.
3290:Core/Inc/arm_math.h ****    */
3291:Core/Inc/arm_math.h ****   typedef struct
3292:Core/Inc/arm_math.h ****   {
3293:Core/Inc/arm_math.h ****     uint8_t M;                  /**< decimation factor. */
3294:Core/Inc/arm_math.h ****     uint16_t numTaps;           /**< number of coefficients in the filter. */
3295:Core/Inc/arm_math.h ****     float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTap
3296:Core/Inc/arm_math.h ****     float32_t *pState;          /**< points to the state variable array. The array is of length num
3297:Core/Inc/arm_math.h ****   } arm_fir_decimate_instance_f32;
3298:Core/Inc/arm_math.h **** 
3299:Core/Inc/arm_math.h **** 
3300:Core/Inc/arm_math.h ****   /**
3301:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR decimator.
3302:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
3303:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3304:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3305:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3306:Core/Inc/arm_math.h ****    */
3307:Core/Inc/arm_math.h ****   void arm_fir_decimate_f32(
3308:Core/Inc/arm_math.h ****   const arm_fir_decimate_instance_f32 * S,
3309:Core/Inc/arm_math.h ****   float32_t * pSrc,
3310:Core/Inc/arm_math.h ****   float32_t * pDst,
3311:Core/Inc/arm_math.h ****   uint32_t blockSize);
3312:Core/Inc/arm_math.h **** 
3313:Core/Inc/arm_math.h **** 
3314:Core/Inc/arm_math.h ****   /**
3315:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point FIR decimator.
3316:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
3317:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3318:Core/Inc/arm_math.h ****    * @param[in]     M          decimation factor.
3319:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3320:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3321:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3322:Core/Inc/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3323:Core/Inc/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3324:Core/Inc/arm_math.h ****    */
3325:Core/Inc/arm_math.h ****   arm_status arm_fir_decimate_init_f32(
3326:Core/Inc/arm_math.h ****   arm_fir_decimate_instance_f32 * S,
3327:Core/Inc/arm_math.h ****   uint16_t numTaps,
3328:Core/Inc/arm_math.h ****   uint8_t M,
3329:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
3330:Core/Inc/arm_math.h ****   float32_t * pState,
3331:Core/Inc/arm_math.h ****   uint32_t blockSize);
3332:Core/Inc/arm_math.h **** 
3333:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 63


3334:Core/Inc/arm_math.h ****   /**
3335:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator.
3336:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3337:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3338:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3339:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3340:Core/Inc/arm_math.h ****    */
3341:Core/Inc/arm_math.h ****   void arm_fir_decimate_q15(
3342:Core/Inc/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3343:Core/Inc/arm_math.h ****   q15_t * pSrc,
3344:Core/Inc/arm_math.h ****   q15_t * pDst,
3345:Core/Inc/arm_math.h ****   uint32_t blockSize);
3346:Core/Inc/arm_math.h **** 
3347:Core/Inc/arm_math.h **** 
3348:Core/Inc/arm_math.h ****   /**
3349:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3350:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR decimator structure.
3351:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3352:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3353:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3354:Core/Inc/arm_math.h ****    */
3355:Core/Inc/arm_math.h ****   void arm_fir_decimate_fast_q15(
3356:Core/Inc/arm_math.h ****   const arm_fir_decimate_instance_q15 * S,
3357:Core/Inc/arm_math.h ****   q15_t * pSrc,
3358:Core/Inc/arm_math.h ****   q15_t * pDst,
3359:Core/Inc/arm_math.h ****   uint32_t blockSize);
3360:Core/Inc/arm_math.h **** 
3361:Core/Inc/arm_math.h **** 
3362:Core/Inc/arm_math.h ****   /**
3363:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 FIR decimator.
3364:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR decimator structure.
3365:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3366:Core/Inc/arm_math.h ****    * @param[in]     M          decimation factor.
3367:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3368:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3369:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3370:Core/Inc/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3371:Core/Inc/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3372:Core/Inc/arm_math.h ****    */
3373:Core/Inc/arm_math.h ****   arm_status arm_fir_decimate_init_q15(
3374:Core/Inc/arm_math.h ****   arm_fir_decimate_instance_q15 * S,
3375:Core/Inc/arm_math.h ****   uint16_t numTaps,
3376:Core/Inc/arm_math.h ****   uint8_t M,
3377:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
3378:Core/Inc/arm_math.h ****   q15_t * pState,
3379:Core/Inc/arm_math.h ****   uint32_t blockSize);
3380:Core/Inc/arm_math.h **** 
3381:Core/Inc/arm_math.h **** 
3382:Core/Inc/arm_math.h ****   /**
3383:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator.
3384:Core/Inc/arm_math.h ****    * @param[in]  S     points to an instance of the Q31 FIR decimator structure.
3385:Core/Inc/arm_math.h ****    * @param[in]  pSrc  points to the block of input data.
3386:Core/Inc/arm_math.h ****    * @param[out] pDst  points to the block of output data
3387:Core/Inc/arm_math.h ****    * @param[in] blockSize number of input samples to process per call.
3388:Core/Inc/arm_math.h ****    */
3389:Core/Inc/arm_math.h ****   void arm_fir_decimate_q31(
3390:Core/Inc/arm_math.h ****   const arm_fir_decimate_instance_q31 * S,
ARM GAS  /tmp/ccpEjOub.s 			page 64


3391:Core/Inc/arm_math.h ****   q31_t * pSrc,
3392:Core/Inc/arm_math.h ****   q31_t * pDst,
3393:Core/Inc/arm_math.h ****   uint32_t blockSize);
3394:Core/Inc/arm_math.h **** 
3395:Core/Inc/arm_math.h ****   /**
3396:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M
3397:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR decimator structure.
3398:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3399:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3400:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3401:Core/Inc/arm_math.h ****    */
3402:Core/Inc/arm_math.h ****   void arm_fir_decimate_fast_q31(
3403:Core/Inc/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3404:Core/Inc/arm_math.h ****   q31_t * pSrc,
3405:Core/Inc/arm_math.h ****   q31_t * pDst,
3406:Core/Inc/arm_math.h ****   uint32_t blockSize);
3407:Core/Inc/arm_math.h **** 
3408:Core/Inc/arm_math.h **** 
3409:Core/Inc/arm_math.h ****   /**
3410:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 FIR decimator.
3411:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR decimator structure.
3412:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of coefficients in the filter.
3413:Core/Inc/arm_math.h ****    * @param[in]     M          decimation factor.
3414:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3415:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3416:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3417:Core/Inc/arm_math.h ****    * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_L
3418:Core/Inc/arm_math.h ****    * <code>blockSize</code> is not a multiple of <code>M</code>.
3419:Core/Inc/arm_math.h ****    */
3420:Core/Inc/arm_math.h ****   arm_status arm_fir_decimate_init_q31(
3421:Core/Inc/arm_math.h ****   arm_fir_decimate_instance_q31 * S,
3422:Core/Inc/arm_math.h ****   uint16_t numTaps,
3423:Core/Inc/arm_math.h ****   uint8_t M,
3424:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
3425:Core/Inc/arm_math.h ****   q31_t * pState,
3426:Core/Inc/arm_math.h ****   uint32_t blockSize);
3427:Core/Inc/arm_math.h **** 
3428:Core/Inc/arm_math.h **** 
3429:Core/Inc/arm_math.h ****   /**
3430:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR interpolator.
3431:Core/Inc/arm_math.h ****    */
3432:Core/Inc/arm_math.h ****   typedef struct
3433:Core/Inc/arm_math.h ****   {
3434:Core/Inc/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3435:Core/Inc/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3436:Core/Inc/arm_math.h ****     q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
3437:Core/Inc/arm_math.h ****     q15_t *pState;                  /**< points to the state variable array. The array is of length
3438:Core/Inc/arm_math.h ****   } arm_fir_interpolate_instance_q15;
3439:Core/Inc/arm_math.h **** 
3440:Core/Inc/arm_math.h ****   /**
3441:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR interpolator.
3442:Core/Inc/arm_math.h ****    */
3443:Core/Inc/arm_math.h ****   typedef struct
3444:Core/Inc/arm_math.h ****   {
3445:Core/Inc/arm_math.h ****     uint8_t L;                      /**< upsample factor. */
3446:Core/Inc/arm_math.h ****     uint16_t phaseLength;           /**< length of each polyphase filter component. */
3447:Core/Inc/arm_math.h ****     q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*
ARM GAS  /tmp/ccpEjOub.s 			page 65


3448:Core/Inc/arm_math.h ****     q31_t *pState;                  /**< points to the state variable array. The array is of length
3449:Core/Inc/arm_math.h ****   } arm_fir_interpolate_instance_q31;
3450:Core/Inc/arm_math.h **** 
3451:Core/Inc/arm_math.h ****   /**
3452:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR interpolator.
3453:Core/Inc/arm_math.h ****    */
3454:Core/Inc/arm_math.h ****   typedef struct
3455:Core/Inc/arm_math.h ****   {
3456:Core/Inc/arm_math.h ****     uint8_t L;                     /**< upsample factor. */
3457:Core/Inc/arm_math.h ****     uint16_t phaseLength;          /**< length of each polyphase filter component. */
3458:Core/Inc/arm_math.h ****     float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*p
3459:Core/Inc/arm_math.h ****     float32_t *pState;             /**< points to the state variable array. The array is of length 
3460:Core/Inc/arm_math.h ****   } arm_fir_interpolate_instance_f32;
3461:Core/Inc/arm_math.h **** 
3462:Core/Inc/arm_math.h **** 
3463:Core/Inc/arm_math.h ****   /**
3464:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR interpolator.
3465:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3466:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3467:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3468:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3469:Core/Inc/arm_math.h ****    */
3470:Core/Inc/arm_math.h ****   void arm_fir_interpolate_q15(
3471:Core/Inc/arm_math.h ****   const arm_fir_interpolate_instance_q15 * S,
3472:Core/Inc/arm_math.h ****   q15_t * pSrc,
3473:Core/Inc/arm_math.h ****   q15_t * pDst,
3474:Core/Inc/arm_math.h ****   uint32_t blockSize);
3475:Core/Inc/arm_math.h **** 
3476:Core/Inc/arm_math.h **** 
3477:Core/Inc/arm_math.h ****   /**
3478:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 FIR interpolator.
3479:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 FIR interpolator structure.
3480:Core/Inc/arm_math.h ****    * @param[in]     L          upsample factor.
3481:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3482:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3483:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3484:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3485:Core/Inc/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3486:Core/Inc/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3487:Core/Inc/arm_math.h ****    */
3488:Core/Inc/arm_math.h ****   arm_status arm_fir_interpolate_init_q15(
3489:Core/Inc/arm_math.h ****   arm_fir_interpolate_instance_q15 * S,
3490:Core/Inc/arm_math.h ****   uint8_t L,
3491:Core/Inc/arm_math.h ****   uint16_t numTaps,
3492:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
3493:Core/Inc/arm_math.h ****   q15_t * pState,
3494:Core/Inc/arm_math.h ****   uint32_t blockSize);
3495:Core/Inc/arm_math.h **** 
3496:Core/Inc/arm_math.h **** 
3497:Core/Inc/arm_math.h ****   /**
3498:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR interpolator.
3499:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR interpolator structure.
3500:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3501:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3502:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3503:Core/Inc/arm_math.h ****    */
3504:Core/Inc/arm_math.h ****   void arm_fir_interpolate_q31(
ARM GAS  /tmp/ccpEjOub.s 			page 66


3505:Core/Inc/arm_math.h ****   const arm_fir_interpolate_instance_q31 * S,
3506:Core/Inc/arm_math.h ****   q31_t * pSrc,
3507:Core/Inc/arm_math.h ****   q31_t * pDst,
3508:Core/Inc/arm_math.h ****   uint32_t blockSize);
3509:Core/Inc/arm_math.h **** 
3510:Core/Inc/arm_math.h **** 
3511:Core/Inc/arm_math.h ****   /**
3512:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 FIR interpolator.
3513:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 FIR interpolator structure.
3514:Core/Inc/arm_math.h ****    * @param[in]     L          upsample factor.
3515:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3516:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3517:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3518:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3519:Core/Inc/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3520:Core/Inc/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3521:Core/Inc/arm_math.h ****    */
3522:Core/Inc/arm_math.h ****   arm_status arm_fir_interpolate_init_q31(
3523:Core/Inc/arm_math.h ****   arm_fir_interpolate_instance_q31 * S,
3524:Core/Inc/arm_math.h ****   uint8_t L,
3525:Core/Inc/arm_math.h ****   uint16_t numTaps,
3526:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
3527:Core/Inc/arm_math.h ****   q31_t * pState,
3528:Core/Inc/arm_math.h ****   uint32_t blockSize);
3529:Core/Inc/arm_math.h **** 
3530:Core/Inc/arm_math.h **** 
3531:Core/Inc/arm_math.h ****   /**
3532:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR interpolator.
3533:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR interpolator structure.
3534:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3535:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3536:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of input samples to process per call.
3537:Core/Inc/arm_math.h ****    */
3538:Core/Inc/arm_math.h ****   void arm_fir_interpolate_f32(
3539:Core/Inc/arm_math.h ****   const arm_fir_interpolate_instance_f32 * S,
3540:Core/Inc/arm_math.h ****   float32_t * pSrc,
3541:Core/Inc/arm_math.h ****   float32_t * pDst,
3542:Core/Inc/arm_math.h ****   uint32_t blockSize);
3543:Core/Inc/arm_math.h **** 
3544:Core/Inc/arm_math.h **** 
3545:Core/Inc/arm_math.h ****   /**
3546:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point FIR interpolator.
3547:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point FIR interpolator structu
3548:Core/Inc/arm_math.h ****    * @param[in]     L          upsample factor.
3549:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of filter coefficients in the filter.
3550:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficient buffer.
3551:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3552:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of input samples to process per call.
3553:Core/Inc/arm_math.h ****    * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MA
3554:Core/Inc/arm_math.h ****    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</
3555:Core/Inc/arm_math.h ****    */
3556:Core/Inc/arm_math.h ****   arm_status arm_fir_interpolate_init_f32(
3557:Core/Inc/arm_math.h ****   arm_fir_interpolate_instance_f32 * S,
3558:Core/Inc/arm_math.h ****   uint8_t L,
3559:Core/Inc/arm_math.h ****   uint16_t numTaps,
3560:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
3561:Core/Inc/arm_math.h ****   float32_t * pState,
ARM GAS  /tmp/ccpEjOub.s 			page 67


3562:Core/Inc/arm_math.h ****   uint32_t blockSize);
3563:Core/Inc/arm_math.h **** 
3564:Core/Inc/arm_math.h **** 
3565:Core/Inc/arm_math.h ****   /**
3566:Core/Inc/arm_math.h ****    * @brief Instance structure for the high precision Q31 Biquad cascade filter.
3567:Core/Inc/arm_math.h ****    */
3568:Core/Inc/arm_math.h ****   typedef struct
3569:Core/Inc/arm_math.h ****   {
3570:Core/Inc/arm_math.h ****     uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*num
3571:Core/Inc/arm_math.h ****     q63_t *pState;           /**< points to the array of state coefficients.  The array is of lengt
3572:Core/Inc/arm_math.h ****     q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*nu
3573:Core/Inc/arm_math.h ****     uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
3574:Core/Inc/arm_math.h ****   } arm_biquad_cas_df1_32x64_ins_q31;
3575:Core/Inc/arm_math.h **** 
3576:Core/Inc/arm_math.h **** 
3577:Core/Inc/arm_math.h ****   /**
3578:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter s
3579:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3580:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3581:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3582:Core/Inc/arm_math.h ****    */
3583:Core/Inc/arm_math.h ****   void arm_biquad_cas_df1_32x64_q31(
3584:Core/Inc/arm_math.h ****   const arm_biquad_cas_df1_32x64_ins_q31 * S,
3585:Core/Inc/arm_math.h ****   q31_t * pSrc,
3586:Core/Inc/arm_math.h ****   q31_t * pDst,
3587:Core/Inc/arm_math.h ****   uint32_t blockSize);
3588:Core/Inc/arm_math.h **** 
3589:Core/Inc/arm_math.h **** 
3590:Core/Inc/arm_math.h ****   /**
3591:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filte
3592:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3593:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3594:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3595:Core/Inc/arm_math.h ****    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficie
3596:Core/Inc/arm_math.h ****    */
3597:Core/Inc/arm_math.h ****   void arm_biquad_cas_df1_32x64_init_q31(
3598:Core/Inc/arm_math.h ****   arm_biquad_cas_df1_32x64_ins_q31 * S,
3599:Core/Inc/arm_math.h ****   uint8_t numStages,
3600:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
3601:Core/Inc/arm_math.h ****   q63_t * pState,
3602:Core/Inc/arm_math.h ****   uint8_t postShift);
3603:Core/Inc/arm_math.h **** 
3604:Core/Inc/arm_math.h **** 
3605:Core/Inc/arm_math.h ****   /**
3606:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3607:Core/Inc/arm_math.h ****    */
3608:Core/Inc/arm_math.h ****   typedef struct
3609:Core/Inc/arm_math.h ****   {
3610:Core/Inc/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3611:Core/Inc/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3612:Core/Inc/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3613:Core/Inc/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f32;
3614:Core/Inc/arm_math.h **** 
3615:Core/Inc/arm_math.h ****   /**
3616:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3617:Core/Inc/arm_math.h ****    */
3618:Core/Inc/arm_math.h ****   typedef struct
ARM GAS  /tmp/ccpEjOub.s 			page 68


3619:Core/Inc/arm_math.h ****   {
3620:Core/Inc/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3621:Core/Inc/arm_math.h ****     float32_t *pState;         /**< points to the array of state coefficients.  The array is of len
3622:Core/Inc/arm_math.h ****     float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3623:Core/Inc/arm_math.h ****   } arm_biquad_cascade_stereo_df2T_instance_f32;
3624:Core/Inc/arm_math.h **** 
3625:Core/Inc/arm_math.h ****   /**
3626:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filt
3627:Core/Inc/arm_math.h ****    */
3628:Core/Inc/arm_math.h ****   typedef struct
3629:Core/Inc/arm_math.h ****   {
3630:Core/Inc/arm_math.h ****     uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*n
3631:Core/Inc/arm_math.h ****     float64_t *pState;         /**< points to the array of state coefficients.  The array is of len
3632:Core/Inc/arm_math.h ****     float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*
3633:Core/Inc/arm_math.h ****   } arm_biquad_cascade_df2T_instance_f64;
3634:Core/Inc/arm_math.h **** 
3635:Core/Inc/arm_math.h **** 
3636:Core/Inc/arm_math.h ****   /**
3637:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3638:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3639:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3640:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3641:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3642:Core/Inc/arm_math.h ****    */
3643:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_f32(
3644:Core/Inc/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f32 * S,
3645:Core/Inc/arm_math.h ****   float32_t * pSrc,
3646:Core/Inc/arm_math.h ****   float32_t * pDst,
3647:Core/Inc/arm_math.h ****   uint32_t blockSize);
3648:Core/Inc/arm_math.h **** 
3649:Core/Inc/arm_math.h **** 
3650:Core/Inc/arm_math.h ****   /**
3651:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3652:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3653:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3654:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3655:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3656:Core/Inc/arm_math.h ****    */
3657:Core/Inc/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_f32(
3658:Core/Inc/arm_math.h ****   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3659:Core/Inc/arm_math.h ****   float32_t * pSrc,
3660:Core/Inc/arm_math.h ****   float32_t * pDst,
3661:Core/Inc/arm_math.h ****   uint32_t blockSize);
3662:Core/Inc/arm_math.h **** 
3663:Core/Inc/arm_math.h **** 
3664:Core/Inc/arm_math.h ****   /**
3665:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point transposed direct form II Biquad cascade fil
3666:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the filter data structure.
3667:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3668:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3669:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3670:Core/Inc/arm_math.h ****    */
3671:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_f64(
3672:Core/Inc/arm_math.h ****   const arm_biquad_cascade_df2T_instance_f64 * S,
3673:Core/Inc/arm_math.h ****   float64_t * pSrc,
3674:Core/Inc/arm_math.h ****   float64_t * pDst,
3675:Core/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /tmp/ccpEjOub.s 			page 69


3676:Core/Inc/arm_math.h **** 
3677:Core/Inc/arm_math.h **** 
3678:Core/Inc/arm_math.h ****   /**
3679:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3680:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3681:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3682:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3683:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3684:Core/Inc/arm_math.h ****    */
3685:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_init_f32(
3686:Core/Inc/arm_math.h ****   arm_biquad_cascade_df2T_instance_f32 * S,
3687:Core/Inc/arm_math.h ****   uint8_t numStages,
3688:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
3689:Core/Inc/arm_math.h ****   float32_t * pState);
3690:Core/Inc/arm_math.h **** 
3691:Core/Inc/arm_math.h **** 
3692:Core/Inc/arm_math.h ****   /**
3693:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3694:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3695:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3696:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3697:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3698:Core/Inc/arm_math.h ****    */
3699:Core/Inc/arm_math.h ****   void arm_biquad_cascade_stereo_df2T_init_f32(
3700:Core/Inc/arm_math.h ****   arm_biquad_cascade_stereo_df2T_instance_f32 * S,
3701:Core/Inc/arm_math.h ****   uint8_t numStages,
3702:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
3703:Core/Inc/arm_math.h ****   float32_t * pState);
3704:Core/Inc/arm_math.h **** 
3705:Core/Inc/arm_math.h **** 
3706:Core/Inc/arm_math.h ****   /**
3707:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascad
3708:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the filter data structure.
3709:Core/Inc/arm_math.h ****    * @param[in]     numStages  number of 2nd order stages in the filter.
3710:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the filter coefficients.
3711:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
3712:Core/Inc/arm_math.h ****    */
3713:Core/Inc/arm_math.h ****   void arm_biquad_cascade_df2T_init_f64(
3714:Core/Inc/arm_math.h ****   arm_biquad_cascade_df2T_instance_f64 * S,
3715:Core/Inc/arm_math.h ****   uint8_t numStages,
3716:Core/Inc/arm_math.h ****   float64_t * pCoeffs,
3717:Core/Inc/arm_math.h ****   float64_t * pState);
3718:Core/Inc/arm_math.h **** 
3719:Core/Inc/arm_math.h **** 
3720:Core/Inc/arm_math.h ****   /**
3721:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 FIR lattice filter.
3722:Core/Inc/arm_math.h ****    */
3723:Core/Inc/arm_math.h ****   typedef struct
3724:Core/Inc/arm_math.h ****   {
3725:Core/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3726:Core/Inc/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3727:Core/Inc/arm_math.h ****     q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3728:Core/Inc/arm_math.h ****   } arm_fir_lattice_instance_q15;
3729:Core/Inc/arm_math.h **** 
3730:Core/Inc/arm_math.h ****   /**
3731:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 FIR lattice filter.
3732:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 70


3733:Core/Inc/arm_math.h ****   typedef struct
3734:Core/Inc/arm_math.h ****   {
3735:Core/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3736:Core/Inc/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3737:Core/Inc/arm_math.h ****     q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of leng
3738:Core/Inc/arm_math.h ****   } arm_fir_lattice_instance_q31;
3739:Core/Inc/arm_math.h **** 
3740:Core/Inc/arm_math.h ****   /**
3741:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point FIR lattice filter.
3742:Core/Inc/arm_math.h ****    */
3743:Core/Inc/arm_math.h ****   typedef struct
3744:Core/Inc/arm_math.h ****   {
3745:Core/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of filter stages. */
3746:Core/Inc/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3747:Core/Inc/arm_math.h ****     float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of leng
3748:Core/Inc/arm_math.h ****   } arm_fir_lattice_instance_f32;
3749:Core/Inc/arm_math.h **** 
3750:Core/Inc/arm_math.h **** 
3751:Core/Inc/arm_math.h ****   /**
3752:Core/Inc/arm_math.h ****    * @brief Initialization function for the Q15 FIR lattice filter.
3753:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q15 FIR lattice structure.
3754:Core/Inc/arm_math.h ****    * @param[in] numStages  number of filter stages.
3755:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3756:Core/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages.
3757:Core/Inc/arm_math.h ****    */
3758:Core/Inc/arm_math.h ****   void arm_fir_lattice_init_q15(
3759:Core/Inc/arm_math.h ****   arm_fir_lattice_instance_q15 * S,
3760:Core/Inc/arm_math.h ****   uint16_t numStages,
3761:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
3762:Core/Inc/arm_math.h ****   q15_t * pState);
3763:Core/Inc/arm_math.h **** 
3764:Core/Inc/arm_math.h **** 
3765:Core/Inc/arm_math.h ****   /**
3766:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 FIR lattice filter.
3767:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 FIR lattice structure.
3768:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3769:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3770:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3771:Core/Inc/arm_math.h ****    */
3772:Core/Inc/arm_math.h ****   void arm_fir_lattice_q15(
3773:Core/Inc/arm_math.h ****   const arm_fir_lattice_instance_q15 * S,
3774:Core/Inc/arm_math.h ****   q15_t * pSrc,
3775:Core/Inc/arm_math.h ****   q15_t * pDst,
3776:Core/Inc/arm_math.h ****   uint32_t blockSize);
3777:Core/Inc/arm_math.h **** 
3778:Core/Inc/arm_math.h **** 
3779:Core/Inc/arm_math.h ****   /**
3780:Core/Inc/arm_math.h ****    * @brief Initialization function for the Q31 FIR lattice filter.
3781:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 FIR lattice structure.
3782:Core/Inc/arm_math.h ****    * @param[in] numStages  number of filter stages.
3783:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3784:Core/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.   The array is of length numStages.
3785:Core/Inc/arm_math.h ****    */
3786:Core/Inc/arm_math.h ****   void arm_fir_lattice_init_q31(
3787:Core/Inc/arm_math.h ****   arm_fir_lattice_instance_q31 * S,
3788:Core/Inc/arm_math.h ****   uint16_t numStages,
3789:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
ARM GAS  /tmp/ccpEjOub.s 			page 71


3790:Core/Inc/arm_math.h ****   q31_t * pState);
3791:Core/Inc/arm_math.h **** 
3792:Core/Inc/arm_math.h **** 
3793:Core/Inc/arm_math.h ****   /**
3794:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 FIR lattice filter.
3795:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 FIR lattice structure.
3796:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3797:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3798:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3799:Core/Inc/arm_math.h ****    */
3800:Core/Inc/arm_math.h ****   void arm_fir_lattice_q31(
3801:Core/Inc/arm_math.h ****   const arm_fir_lattice_instance_q31 * S,
3802:Core/Inc/arm_math.h ****   q31_t * pSrc,
3803:Core/Inc/arm_math.h ****   q31_t * pDst,
3804:Core/Inc/arm_math.h ****   uint32_t blockSize);
3805:Core/Inc/arm_math.h **** 
3806:Core/Inc/arm_math.h **** 
3807:Core/Inc/arm_math.h **** /**
3808:Core/Inc/arm_math.h ****  * @brief Initialization function for the floating-point FIR lattice filter.
3809:Core/Inc/arm_math.h ****  * @param[in] S          points to an instance of the floating-point FIR lattice structure.
3810:Core/Inc/arm_math.h ****  * @param[in] numStages  number of filter stages.
3811:Core/Inc/arm_math.h ****  * @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages.
3812:Core/Inc/arm_math.h ****  * @param[in] pState     points to the state buffer.  The array is of length numStages.
3813:Core/Inc/arm_math.h ****  */
3814:Core/Inc/arm_math.h ****   void arm_fir_lattice_init_f32(
3815:Core/Inc/arm_math.h ****   arm_fir_lattice_instance_f32 * S,
3816:Core/Inc/arm_math.h ****   uint16_t numStages,
3817:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
3818:Core/Inc/arm_math.h ****   float32_t * pState);
3819:Core/Inc/arm_math.h **** 
3820:Core/Inc/arm_math.h **** 
3821:Core/Inc/arm_math.h ****   /**
3822:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point FIR lattice filter.
3823:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point FIR lattice structure.
3824:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3825:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data
3826:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3827:Core/Inc/arm_math.h ****    */
3828:Core/Inc/arm_math.h ****   void arm_fir_lattice_f32(
3829:Core/Inc/arm_math.h ****   const arm_fir_lattice_instance_f32 * S,
3830:Core/Inc/arm_math.h ****   float32_t * pSrc,
3831:Core/Inc/arm_math.h ****   float32_t * pDst,
3832:Core/Inc/arm_math.h ****   uint32_t blockSize);
3833:Core/Inc/arm_math.h **** 
3834:Core/Inc/arm_math.h **** 
3835:Core/Inc/arm_math.h ****   /**
3836:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 IIR lattice filter.
3837:Core/Inc/arm_math.h ****    */
3838:Core/Inc/arm_math.h ****   typedef struct
3839:Core/Inc/arm_math.h ****   {
3840:Core/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3841:Core/Inc/arm_math.h ****     q15_t *pState;                       /**< points to the state variable array. The array is of l
3842:Core/Inc/arm_math.h ****     q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3843:Core/Inc/arm_math.h ****     q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3844:Core/Inc/arm_math.h ****   } arm_iir_lattice_instance_q15;
3845:Core/Inc/arm_math.h **** 
3846:Core/Inc/arm_math.h ****   /**
ARM GAS  /tmp/ccpEjOub.s 			page 72


3847:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 IIR lattice filter.
3848:Core/Inc/arm_math.h ****    */
3849:Core/Inc/arm_math.h ****   typedef struct
3850:Core/Inc/arm_math.h ****   {
3851:Core/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3852:Core/Inc/arm_math.h ****     q31_t *pState;                       /**< points to the state variable array. The array is of l
3853:Core/Inc/arm_math.h ****     q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array
3854:Core/Inc/arm_math.h ****     q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is 
3855:Core/Inc/arm_math.h ****   } arm_iir_lattice_instance_q31;
3856:Core/Inc/arm_math.h **** 
3857:Core/Inc/arm_math.h ****   /**
3858:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point IIR lattice filter.
3859:Core/Inc/arm_math.h ****    */
3860:Core/Inc/arm_math.h ****   typedef struct
3861:Core/Inc/arm_math.h ****   {
3862:Core/Inc/arm_math.h ****     uint16_t numStages;                  /**< number of stages in the filter. */
3863:Core/Inc/arm_math.h ****     float32_t *pState;                   /**< points to the state variable array. The array is of l
3864:Core/Inc/arm_math.h ****     float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array
3865:Core/Inc/arm_math.h ****     float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is 
3866:Core/Inc/arm_math.h ****   } arm_iir_lattice_instance_f32;
3867:Core/Inc/arm_math.h **** 
3868:Core/Inc/arm_math.h **** 
3869:Core/Inc/arm_math.h ****   /**
3870:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point IIR lattice filter.
3871:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point IIR lattice structure.
3872:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3873:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3874:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3875:Core/Inc/arm_math.h ****    */
3876:Core/Inc/arm_math.h ****   void arm_iir_lattice_f32(
3877:Core/Inc/arm_math.h ****   const arm_iir_lattice_instance_f32 * S,
3878:Core/Inc/arm_math.h ****   float32_t * pSrc,
3879:Core/Inc/arm_math.h ****   float32_t * pDst,
3880:Core/Inc/arm_math.h ****   uint32_t blockSize);
3881:Core/Inc/arm_math.h **** 
3882:Core/Inc/arm_math.h **** 
3883:Core/Inc/arm_math.h ****   /**
3884:Core/Inc/arm_math.h ****    * @brief Initialization function for the floating-point IIR lattice filter.
3885:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the floating-point IIR lattice structure.
3886:Core/Inc/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3887:Core/Inc/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3888:Core/Inc/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3889:Core/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-
3890:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3891:Core/Inc/arm_math.h ****    */
3892:Core/Inc/arm_math.h ****   void arm_iir_lattice_init_f32(
3893:Core/Inc/arm_math.h ****   arm_iir_lattice_instance_f32 * S,
3894:Core/Inc/arm_math.h ****   uint16_t numStages,
3895:Core/Inc/arm_math.h ****   float32_t * pkCoeffs,
3896:Core/Inc/arm_math.h ****   float32_t * pvCoeffs,
3897:Core/Inc/arm_math.h ****   float32_t * pState,
3898:Core/Inc/arm_math.h ****   uint32_t blockSize);
3899:Core/Inc/arm_math.h **** 
3900:Core/Inc/arm_math.h **** 
3901:Core/Inc/arm_math.h ****   /**
3902:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 IIR lattice filter.
3903:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 IIR lattice structure.
ARM GAS  /tmp/ccpEjOub.s 			page 73


3904:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3905:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3906:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3907:Core/Inc/arm_math.h ****    */
3908:Core/Inc/arm_math.h ****   void arm_iir_lattice_q31(
3909:Core/Inc/arm_math.h ****   const arm_iir_lattice_instance_q31 * S,
3910:Core/Inc/arm_math.h ****   q31_t * pSrc,
3911:Core/Inc/arm_math.h ****   q31_t * pDst,
3912:Core/Inc/arm_math.h ****   uint32_t blockSize);
3913:Core/Inc/arm_math.h **** 
3914:Core/Inc/arm_math.h **** 
3915:Core/Inc/arm_math.h ****   /**
3916:Core/Inc/arm_math.h ****    * @brief Initialization function for the Q31 IIR lattice filter.
3917:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 IIR lattice structure.
3918:Core/Inc/arm_math.h ****    * @param[in] numStages  number of stages in the filter.
3919:Core/Inc/arm_math.h ****    * @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length num
3920:Core/Inc/arm_math.h ****    * @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStag
3921:Core/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize.
3922:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
3923:Core/Inc/arm_math.h ****    */
3924:Core/Inc/arm_math.h ****   void arm_iir_lattice_init_q31(
3925:Core/Inc/arm_math.h ****   arm_iir_lattice_instance_q31 * S,
3926:Core/Inc/arm_math.h ****   uint16_t numStages,
3927:Core/Inc/arm_math.h ****   q31_t * pkCoeffs,
3928:Core/Inc/arm_math.h ****   q31_t * pvCoeffs,
3929:Core/Inc/arm_math.h ****   q31_t * pState,
3930:Core/Inc/arm_math.h ****   uint32_t blockSize);
3931:Core/Inc/arm_math.h **** 
3932:Core/Inc/arm_math.h **** 
3933:Core/Inc/arm_math.h ****   /**
3934:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 IIR lattice filter.
3935:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 IIR lattice structure.
3936:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3937:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data.
3938:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3939:Core/Inc/arm_math.h ****    */
3940:Core/Inc/arm_math.h ****   void arm_iir_lattice_q15(
3941:Core/Inc/arm_math.h ****   const arm_iir_lattice_instance_q15 * S,
3942:Core/Inc/arm_math.h ****   q15_t * pSrc,
3943:Core/Inc/arm_math.h ****   q15_t * pDst,
3944:Core/Inc/arm_math.h ****   uint32_t blockSize);
3945:Core/Inc/arm_math.h **** 
3946:Core/Inc/arm_math.h **** 
3947:Core/Inc/arm_math.h **** /**
3948:Core/Inc/arm_math.h ****  * @brief Initialization function for the Q15 IIR lattice filter.
3949:Core/Inc/arm_math.h ****  * @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure.
3950:Core/Inc/arm_math.h ****  * @param[in] numStages  number of stages in the filter.
3951:Core/Inc/arm_math.h ****  * @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages
3952:Core/Inc/arm_math.h ****  * @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1.
3953:Core/Inc/arm_math.h ****  * @param[in] pState     points to state buffer.  The array is of length numStages+blockSize.
3954:Core/Inc/arm_math.h ****  * @param[in] blockSize  number of samples to process per call.
3955:Core/Inc/arm_math.h ****  */
3956:Core/Inc/arm_math.h ****   void arm_iir_lattice_init_q15(
3957:Core/Inc/arm_math.h ****   arm_iir_lattice_instance_q15 * S,
3958:Core/Inc/arm_math.h ****   uint16_t numStages,
3959:Core/Inc/arm_math.h ****   q15_t * pkCoeffs,
3960:Core/Inc/arm_math.h ****   q15_t * pvCoeffs,
ARM GAS  /tmp/ccpEjOub.s 			page 74


3961:Core/Inc/arm_math.h ****   q15_t * pState,
3962:Core/Inc/arm_math.h ****   uint32_t blockSize);
3963:Core/Inc/arm_math.h **** 
3964:Core/Inc/arm_math.h **** 
3965:Core/Inc/arm_math.h ****   /**
3966:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point LMS filter.
3967:Core/Inc/arm_math.h ****    */
3968:Core/Inc/arm_math.h ****   typedef struct
3969:Core/Inc/arm_math.h ****   {
3970:Core/Inc/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
3971:Core/Inc/arm_math.h ****     float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+bl
3972:Core/Inc/arm_math.h ****     float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
3973:Core/Inc/arm_math.h ****     float32_t mu;        /**< step size that controls filter coefficient updates. */
3974:Core/Inc/arm_math.h ****   } arm_lms_instance_f32;
3975:Core/Inc/arm_math.h **** 
3976:Core/Inc/arm_math.h **** 
3977:Core/Inc/arm_math.h ****   /**
3978:Core/Inc/arm_math.h ****    * @brief Processing function for floating-point LMS filter.
3979:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point LMS filter structure.
3980:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
3981:Core/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
3982:Core/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
3983:Core/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
3984:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
3985:Core/Inc/arm_math.h ****    */
3986:Core/Inc/arm_math.h ****   void arm_lms_f32(
3987:Core/Inc/arm_math.h ****   const arm_lms_instance_f32 * S,
3988:Core/Inc/arm_math.h ****   float32_t * pSrc,
3989:Core/Inc/arm_math.h ****   float32_t * pRef,
3990:Core/Inc/arm_math.h ****   float32_t * pOut,
3991:Core/Inc/arm_math.h ****   float32_t * pErr,
3992:Core/Inc/arm_math.h ****   uint32_t blockSize);
3993:Core/Inc/arm_math.h **** 
3994:Core/Inc/arm_math.h **** 
3995:Core/Inc/arm_math.h ****   /**
3996:Core/Inc/arm_math.h ****    * @brief Initialization function for floating-point LMS filter.
3997:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
3998:Core/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
3999:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4000:Core/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4001:Core/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4002:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4003:Core/Inc/arm_math.h ****    */
4004:Core/Inc/arm_math.h ****   void arm_lms_init_f32(
4005:Core/Inc/arm_math.h ****   arm_lms_instance_f32 * S,
4006:Core/Inc/arm_math.h ****   uint16_t numTaps,
4007:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
4008:Core/Inc/arm_math.h ****   float32_t * pState,
4009:Core/Inc/arm_math.h ****   float32_t mu,
4010:Core/Inc/arm_math.h ****   uint32_t blockSize);
4011:Core/Inc/arm_math.h **** 
4012:Core/Inc/arm_math.h **** 
4013:Core/Inc/arm_math.h ****   /**
4014:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 LMS filter.
4015:Core/Inc/arm_math.h ****    */
4016:Core/Inc/arm_math.h ****   typedef struct
4017:Core/Inc/arm_math.h ****   {
ARM GAS  /tmp/ccpEjOub.s 			page 75


4018:Core/Inc/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4019:Core/Inc/arm_math.h ****     q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4020:Core/Inc/arm_math.h ****     q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4021:Core/Inc/arm_math.h ****     q15_t mu;            /**< step size that controls filter coefficient updates. */
4022:Core/Inc/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4023:Core/Inc/arm_math.h ****   } arm_lms_instance_q15;
4024:Core/Inc/arm_math.h **** 
4025:Core/Inc/arm_math.h **** 
4026:Core/Inc/arm_math.h ****   /**
4027:Core/Inc/arm_math.h ****    * @brief Initialization function for the Q15 LMS filter.
4028:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q15 LMS filter structure.
4029:Core/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4030:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to the coefficient buffer.
4031:Core/Inc/arm_math.h ****    * @param[in] pState     points to the state buffer.
4032:Core/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4033:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4034:Core/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4035:Core/Inc/arm_math.h ****    */
4036:Core/Inc/arm_math.h ****   void arm_lms_init_q15(
4037:Core/Inc/arm_math.h ****   arm_lms_instance_q15 * S,
4038:Core/Inc/arm_math.h ****   uint16_t numTaps,
4039:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
4040:Core/Inc/arm_math.h ****   q15_t * pState,
4041:Core/Inc/arm_math.h ****   q15_t mu,
4042:Core/Inc/arm_math.h ****   uint32_t blockSize,
4043:Core/Inc/arm_math.h ****   uint32_t postShift);
4044:Core/Inc/arm_math.h **** 
4045:Core/Inc/arm_math.h **** 
4046:Core/Inc/arm_math.h ****   /**
4047:Core/Inc/arm_math.h ****    * @brief Processing function for Q15 LMS filter.
4048:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4049:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4050:Core/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4051:Core/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4052:Core/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4053:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4054:Core/Inc/arm_math.h ****    */
4055:Core/Inc/arm_math.h ****   void arm_lms_q15(
4056:Core/Inc/arm_math.h ****   const arm_lms_instance_q15 * S,
4057:Core/Inc/arm_math.h ****   q15_t * pSrc,
4058:Core/Inc/arm_math.h ****   q15_t * pRef,
4059:Core/Inc/arm_math.h ****   q15_t * pOut,
4060:Core/Inc/arm_math.h ****   q15_t * pErr,
4061:Core/Inc/arm_math.h ****   uint32_t blockSize);
4062:Core/Inc/arm_math.h **** 
4063:Core/Inc/arm_math.h **** 
4064:Core/Inc/arm_math.h ****   /**
4065:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 LMS filter.
4066:Core/Inc/arm_math.h ****    */
4067:Core/Inc/arm_math.h ****   typedef struct
4068:Core/Inc/arm_math.h ****   {
4069:Core/Inc/arm_math.h ****     uint16_t numTaps;    /**< number of coefficients in the filter. */
4070:Core/Inc/arm_math.h ****     q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+bl
4071:Core/Inc/arm_math.h ****     q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
4072:Core/Inc/arm_math.h ****     q31_t mu;            /**< step size that controls filter coefficient updates. */
4073:Core/Inc/arm_math.h ****     uint32_t postShift;  /**< bit shift applied to coefficients. */
4074:Core/Inc/arm_math.h ****   } arm_lms_instance_q31;
ARM GAS  /tmp/ccpEjOub.s 			page 76


4075:Core/Inc/arm_math.h **** 
4076:Core/Inc/arm_math.h **** 
4077:Core/Inc/arm_math.h ****   /**
4078:Core/Inc/arm_math.h ****    * @brief Processing function for Q31 LMS filter.
4079:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 LMS filter structure.
4080:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4081:Core/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4082:Core/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4083:Core/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4084:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4085:Core/Inc/arm_math.h ****    */
4086:Core/Inc/arm_math.h ****   void arm_lms_q31(
4087:Core/Inc/arm_math.h ****   const arm_lms_instance_q31 * S,
4088:Core/Inc/arm_math.h ****   q31_t * pSrc,
4089:Core/Inc/arm_math.h ****   q31_t * pRef,
4090:Core/Inc/arm_math.h ****   q31_t * pOut,
4091:Core/Inc/arm_math.h ****   q31_t * pErr,
4092:Core/Inc/arm_math.h ****   uint32_t blockSize);
4093:Core/Inc/arm_math.h **** 
4094:Core/Inc/arm_math.h **** 
4095:Core/Inc/arm_math.h ****   /**
4096:Core/Inc/arm_math.h ****    * @brief Initialization function for Q31 LMS filter.
4097:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 LMS filter structure.
4098:Core/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4099:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4100:Core/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4101:Core/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4102:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4103:Core/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4104:Core/Inc/arm_math.h ****    */
4105:Core/Inc/arm_math.h ****   void arm_lms_init_q31(
4106:Core/Inc/arm_math.h ****   arm_lms_instance_q31 * S,
4107:Core/Inc/arm_math.h ****   uint16_t numTaps,
4108:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
4109:Core/Inc/arm_math.h ****   q31_t * pState,
4110:Core/Inc/arm_math.h ****   q31_t mu,
4111:Core/Inc/arm_math.h ****   uint32_t blockSize,
4112:Core/Inc/arm_math.h ****   uint32_t postShift);
4113:Core/Inc/arm_math.h **** 
4114:Core/Inc/arm_math.h **** 
4115:Core/Inc/arm_math.h ****   /**
4116:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point normalized LMS filter.
4117:Core/Inc/arm_math.h ****    */
4118:Core/Inc/arm_math.h ****   typedef struct
4119:Core/Inc/arm_math.h ****   {
4120:Core/Inc/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4121:Core/Inc/arm_math.h ****     float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+b
4122:Core/Inc/arm_math.h ****     float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
4123:Core/Inc/arm_math.h ****     float32_t mu;         /**< step size that control filter coefficient updates. */
4124:Core/Inc/arm_math.h ****     float32_t energy;     /**< saves previous frame energy. */
4125:Core/Inc/arm_math.h ****     float32_t x0;         /**< saves previous input sample. */
4126:Core/Inc/arm_math.h ****   } arm_lms_norm_instance_f32;
4127:Core/Inc/arm_math.h **** 
4128:Core/Inc/arm_math.h **** 
4129:Core/Inc/arm_math.h ****   /**
4130:Core/Inc/arm_math.h ****    * @brief Processing function for floating-point normalized LMS filter.
4131:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the floating-point normalized LMS filter struc
ARM GAS  /tmp/ccpEjOub.s 			page 77


4132:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4133:Core/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4134:Core/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4135:Core/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4136:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4137:Core/Inc/arm_math.h ****    */
4138:Core/Inc/arm_math.h ****   void arm_lms_norm_f32(
4139:Core/Inc/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4140:Core/Inc/arm_math.h ****   float32_t * pSrc,
4141:Core/Inc/arm_math.h ****   float32_t * pRef,
4142:Core/Inc/arm_math.h ****   float32_t * pOut,
4143:Core/Inc/arm_math.h ****   float32_t * pErr,
4144:Core/Inc/arm_math.h ****   uint32_t blockSize);
4145:Core/Inc/arm_math.h **** 
4146:Core/Inc/arm_math.h **** 
4147:Core/Inc/arm_math.h ****   /**
4148:Core/Inc/arm_math.h ****    * @brief Initialization function for floating-point normalized LMS filter.
4149:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the floating-point LMS filter structure.
4150:Core/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4151:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4152:Core/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4153:Core/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4154:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4155:Core/Inc/arm_math.h ****    */
4156:Core/Inc/arm_math.h ****   void arm_lms_norm_init_f32(
4157:Core/Inc/arm_math.h ****   arm_lms_norm_instance_f32 * S,
4158:Core/Inc/arm_math.h ****   uint16_t numTaps,
4159:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
4160:Core/Inc/arm_math.h ****   float32_t * pState,
4161:Core/Inc/arm_math.h ****   float32_t mu,
4162:Core/Inc/arm_math.h ****   uint32_t blockSize);
4163:Core/Inc/arm_math.h **** 
4164:Core/Inc/arm_math.h **** 
4165:Core/Inc/arm_math.h ****   /**
4166:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 normalized LMS filter.
4167:Core/Inc/arm_math.h ****    */
4168:Core/Inc/arm_math.h ****   typedef struct
4169:Core/Inc/arm_math.h ****   {
4170:Core/Inc/arm_math.h ****     uint16_t numTaps;     /**< number of coefficients in the filter. */
4171:Core/Inc/arm_math.h ****     q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4172:Core/Inc/arm_math.h ****     q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4173:Core/Inc/arm_math.h ****     q31_t mu;             /**< step size that controls filter coefficient updates. */
4174:Core/Inc/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4175:Core/Inc/arm_math.h ****     q31_t *recipTable;    /**< points to the reciprocal initial value table. */
4176:Core/Inc/arm_math.h ****     q31_t energy;         /**< saves previous frame energy. */
4177:Core/Inc/arm_math.h ****     q31_t x0;             /**< saves previous input sample. */
4178:Core/Inc/arm_math.h ****   } arm_lms_norm_instance_q31;
4179:Core/Inc/arm_math.h **** 
4180:Core/Inc/arm_math.h **** 
4181:Core/Inc/arm_math.h ****   /**
4182:Core/Inc/arm_math.h ****    * @brief Processing function for Q31 normalized LMS filter.
4183:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q31 normalized LMS filter structure.
4184:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4185:Core/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4186:Core/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4187:Core/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4188:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
ARM GAS  /tmp/ccpEjOub.s 			page 78


4189:Core/Inc/arm_math.h ****    */
4190:Core/Inc/arm_math.h ****   void arm_lms_norm_q31(
4191:Core/Inc/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4192:Core/Inc/arm_math.h ****   q31_t * pSrc,
4193:Core/Inc/arm_math.h ****   q31_t * pRef,
4194:Core/Inc/arm_math.h ****   q31_t * pOut,
4195:Core/Inc/arm_math.h ****   q31_t * pErr,
4196:Core/Inc/arm_math.h ****   uint32_t blockSize);
4197:Core/Inc/arm_math.h **** 
4198:Core/Inc/arm_math.h **** 
4199:Core/Inc/arm_math.h ****   /**
4200:Core/Inc/arm_math.h ****    * @brief Initialization function for Q31 normalized LMS filter.
4201:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q31 normalized LMS filter structure.
4202:Core/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4203:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4204:Core/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4205:Core/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4206:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4207:Core/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4208:Core/Inc/arm_math.h ****    */
4209:Core/Inc/arm_math.h ****   void arm_lms_norm_init_q31(
4210:Core/Inc/arm_math.h ****   arm_lms_norm_instance_q31 * S,
4211:Core/Inc/arm_math.h ****   uint16_t numTaps,
4212:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
4213:Core/Inc/arm_math.h ****   q31_t * pState,
4214:Core/Inc/arm_math.h ****   q31_t mu,
4215:Core/Inc/arm_math.h ****   uint32_t blockSize,
4216:Core/Inc/arm_math.h ****   uint8_t postShift);
4217:Core/Inc/arm_math.h **** 
4218:Core/Inc/arm_math.h **** 
4219:Core/Inc/arm_math.h ****   /**
4220:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 normalized LMS filter.
4221:Core/Inc/arm_math.h ****    */
4222:Core/Inc/arm_math.h ****   typedef struct
4223:Core/Inc/arm_math.h ****   {
4224:Core/Inc/arm_math.h ****     uint16_t numTaps;     /**< Number of coefficients in the filter. */
4225:Core/Inc/arm_math.h ****     q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+b
4226:Core/Inc/arm_math.h ****     q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
4227:Core/Inc/arm_math.h ****     q15_t mu;             /**< step size that controls filter coefficient updates. */
4228:Core/Inc/arm_math.h ****     uint8_t postShift;    /**< bit shift applied to coefficients. */
4229:Core/Inc/arm_math.h ****     q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
4230:Core/Inc/arm_math.h ****     q15_t energy;         /**< saves previous frame energy. */
4231:Core/Inc/arm_math.h ****     q15_t x0;             /**< saves previous input sample. */
4232:Core/Inc/arm_math.h ****   } arm_lms_norm_instance_q15;
4233:Core/Inc/arm_math.h **** 
4234:Core/Inc/arm_math.h **** 
4235:Core/Inc/arm_math.h ****   /**
4236:Core/Inc/arm_math.h ****    * @brief Processing function for Q15 normalized LMS filter.
4237:Core/Inc/arm_math.h ****    * @param[in]  S          points to an instance of the Q15 normalized LMS filter structure.
4238:Core/Inc/arm_math.h ****    * @param[in]  pSrc       points to the block of input data.
4239:Core/Inc/arm_math.h ****    * @param[in]  pRef       points to the block of reference data.
4240:Core/Inc/arm_math.h ****    * @param[out] pOut       points to the block of output data.
4241:Core/Inc/arm_math.h ****    * @param[out] pErr       points to the block of error data.
4242:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process.
4243:Core/Inc/arm_math.h ****    */
4244:Core/Inc/arm_math.h ****   void arm_lms_norm_q15(
4245:Core/Inc/arm_math.h ****   arm_lms_norm_instance_q15 * S,
ARM GAS  /tmp/ccpEjOub.s 			page 79


4246:Core/Inc/arm_math.h ****   q15_t * pSrc,
4247:Core/Inc/arm_math.h ****   q15_t * pRef,
4248:Core/Inc/arm_math.h ****   q15_t * pOut,
4249:Core/Inc/arm_math.h ****   q15_t * pErr,
4250:Core/Inc/arm_math.h ****   uint32_t blockSize);
4251:Core/Inc/arm_math.h **** 
4252:Core/Inc/arm_math.h **** 
4253:Core/Inc/arm_math.h ****   /**
4254:Core/Inc/arm_math.h ****    * @brief Initialization function for Q15 normalized LMS filter.
4255:Core/Inc/arm_math.h ****    * @param[in] S          points to an instance of the Q15 normalized LMS filter structure.
4256:Core/Inc/arm_math.h ****    * @param[in] numTaps    number of filter coefficients.
4257:Core/Inc/arm_math.h ****    * @param[in] pCoeffs    points to coefficient buffer.
4258:Core/Inc/arm_math.h ****    * @param[in] pState     points to state buffer.
4259:Core/Inc/arm_math.h ****    * @param[in] mu         step size that controls filter coefficient updates.
4260:Core/Inc/arm_math.h ****    * @param[in] blockSize  number of samples to process.
4261:Core/Inc/arm_math.h ****    * @param[in] postShift  bit shift applied to coefficients.
4262:Core/Inc/arm_math.h ****    */
4263:Core/Inc/arm_math.h ****   void arm_lms_norm_init_q15(
4264:Core/Inc/arm_math.h ****   arm_lms_norm_instance_q15 * S,
4265:Core/Inc/arm_math.h ****   uint16_t numTaps,
4266:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
4267:Core/Inc/arm_math.h ****   q15_t * pState,
4268:Core/Inc/arm_math.h ****   q15_t mu,
4269:Core/Inc/arm_math.h ****   uint32_t blockSize,
4270:Core/Inc/arm_math.h ****   uint8_t postShift);
4271:Core/Inc/arm_math.h **** 
4272:Core/Inc/arm_math.h **** 
4273:Core/Inc/arm_math.h ****   /**
4274:Core/Inc/arm_math.h ****    * @brief Correlation of floating-point sequences.
4275:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4276:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4277:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4278:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4279:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4280:Core/Inc/arm_math.h ****    */
4281:Core/Inc/arm_math.h ****   void arm_correlate_f32(
4282:Core/Inc/arm_math.h ****   float32_t * pSrcA,
4283:Core/Inc/arm_math.h ****   uint32_t srcALen,
4284:Core/Inc/arm_math.h ****   float32_t * pSrcB,
4285:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4286:Core/Inc/arm_math.h ****   float32_t * pDst);
4287:Core/Inc/arm_math.h **** 
4288:Core/Inc/arm_math.h **** 
4289:Core/Inc/arm_math.h ****    /**
4290:Core/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences
4291:Core/Inc/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4292:Core/Inc/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4293:Core/Inc/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4294:Core/Inc/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4295:Core/Inc/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4296:Core/Inc/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4297:Core/Inc/arm_math.h ****    */
4298:Core/Inc/arm_math.h ****   void arm_correlate_opt_q15(
4299:Core/Inc/arm_math.h ****   q15_t * pSrcA,
4300:Core/Inc/arm_math.h ****   uint32_t srcALen,
4301:Core/Inc/arm_math.h ****   q15_t * pSrcB,
4302:Core/Inc/arm_math.h ****   uint32_t srcBLen,
ARM GAS  /tmp/ccpEjOub.s 			page 80


4303:Core/Inc/arm_math.h ****   q15_t * pDst,
4304:Core/Inc/arm_math.h ****   q15_t * pScratch);
4305:Core/Inc/arm_math.h **** 
4306:Core/Inc/arm_math.h **** 
4307:Core/Inc/arm_math.h ****   /**
4308:Core/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences.
4309:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4310:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4311:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4312:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4313:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4314:Core/Inc/arm_math.h ****    */
4315:Core/Inc/arm_math.h **** 
4316:Core/Inc/arm_math.h ****   void arm_correlate_q15(
4317:Core/Inc/arm_math.h ****   q15_t * pSrcA,
4318:Core/Inc/arm_math.h ****   uint32_t srcALen,
4319:Core/Inc/arm_math.h ****   q15_t * pSrcB,
4320:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4321:Core/Inc/arm_math.h ****   q15_t * pDst);
4322:Core/Inc/arm_math.h **** 
4323:Core/Inc/arm_math.h **** 
4324:Core/Inc/arm_math.h ****   /**
4325:Core/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4326:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4327:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4328:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4329:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4330:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4331:Core/Inc/arm_math.h ****    */
4332:Core/Inc/arm_math.h **** 
4333:Core/Inc/arm_math.h ****   void arm_correlate_fast_q15(
4334:Core/Inc/arm_math.h ****   q15_t * pSrcA,
4335:Core/Inc/arm_math.h ****   uint32_t srcALen,
4336:Core/Inc/arm_math.h ****   q15_t * pSrcB,
4337:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4338:Core/Inc/arm_math.h ****   q15_t * pDst);
4339:Core/Inc/arm_math.h **** 
4340:Core/Inc/arm_math.h **** 
4341:Core/Inc/arm_math.h ****   /**
4342:Core/Inc/arm_math.h ****    * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
4343:Core/Inc/arm_math.h ****    * @param[in]  pSrcA     points to the first input sequence.
4344:Core/Inc/arm_math.h ****    * @param[in]  srcALen   length of the first input sequence.
4345:Core/Inc/arm_math.h ****    * @param[in]  pSrcB     points to the second input sequence.
4346:Core/Inc/arm_math.h ****    * @param[in]  srcBLen   length of the second input sequence.
4347:Core/Inc/arm_math.h ****    * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1
4348:Core/Inc/arm_math.h ****    * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, 
4349:Core/Inc/arm_math.h ****    */
4350:Core/Inc/arm_math.h ****   void arm_correlate_fast_opt_q15(
4351:Core/Inc/arm_math.h ****   q15_t * pSrcA,
4352:Core/Inc/arm_math.h ****   uint32_t srcALen,
4353:Core/Inc/arm_math.h ****   q15_t * pSrcB,
4354:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4355:Core/Inc/arm_math.h ****   q15_t * pDst,
4356:Core/Inc/arm_math.h ****   q15_t * pScratch);
4357:Core/Inc/arm_math.h **** 
4358:Core/Inc/arm_math.h **** 
4359:Core/Inc/arm_math.h ****   /**
ARM GAS  /tmp/ccpEjOub.s 			page 81


4360:Core/Inc/arm_math.h ****    * @brief Correlation of Q31 sequences.
4361:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4362:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4363:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4364:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4365:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4366:Core/Inc/arm_math.h ****    */
4367:Core/Inc/arm_math.h ****   void arm_correlate_q31(
4368:Core/Inc/arm_math.h ****   q31_t * pSrcA,
4369:Core/Inc/arm_math.h ****   uint32_t srcALen,
4370:Core/Inc/arm_math.h ****   q31_t * pSrcB,
4371:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4372:Core/Inc/arm_math.h ****   q31_t * pDst);
4373:Core/Inc/arm_math.h **** 
4374:Core/Inc/arm_math.h **** 
4375:Core/Inc/arm_math.h ****   /**
4376:Core/Inc/arm_math.h ****    * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
4377:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4378:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4379:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4380:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
4381:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4382:Core/Inc/arm_math.h ****    */
4383:Core/Inc/arm_math.h ****   void arm_correlate_fast_q31(
4384:Core/Inc/arm_math.h ****   q31_t * pSrcA,
4385:Core/Inc/arm_math.h ****   uint32_t srcALen,
4386:Core/Inc/arm_math.h ****   q31_t * pSrcB,
4387:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4388:Core/Inc/arm_math.h ****   q31_t * pDst);
4389:Core/Inc/arm_math.h **** 
4390:Core/Inc/arm_math.h **** 
4391:Core/Inc/arm_math.h ****  /**
4392:Core/Inc/arm_math.h ****    * @brief Correlation of Q7 sequences.
4393:Core/Inc/arm_math.h ****    * @param[in]  pSrcA      points to the first input sequence.
4394:Core/Inc/arm_math.h ****    * @param[in]  srcALen    length of the first input sequence.
4395:Core/Inc/arm_math.h ****    * @param[in]  pSrcB      points to the second input sequence.
4396:Core/Inc/arm_math.h ****    * @param[in]  srcBLen    length of the second input sequence.
4397:Core/Inc/arm_math.h ****    * @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 
4398:Core/Inc/arm_math.h ****    * @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) +
4399:Core/Inc/arm_math.h ****    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
4400:Core/Inc/arm_math.h ****    */
4401:Core/Inc/arm_math.h ****   void arm_correlate_opt_q7(
4402:Core/Inc/arm_math.h ****   q7_t * pSrcA,
4403:Core/Inc/arm_math.h ****   uint32_t srcALen,
4404:Core/Inc/arm_math.h ****   q7_t * pSrcB,
4405:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4406:Core/Inc/arm_math.h ****   q7_t * pDst,
4407:Core/Inc/arm_math.h ****   q15_t * pScratch1,
4408:Core/Inc/arm_math.h ****   q15_t * pScratch2);
4409:Core/Inc/arm_math.h **** 
4410:Core/Inc/arm_math.h **** 
4411:Core/Inc/arm_math.h ****   /**
4412:Core/Inc/arm_math.h ****    * @brief Correlation of Q7 sequences.
4413:Core/Inc/arm_math.h ****    * @param[in]  pSrcA    points to the first input sequence.
4414:Core/Inc/arm_math.h ****    * @param[in]  srcALen  length of the first input sequence.
4415:Core/Inc/arm_math.h ****    * @param[in]  pSrcB    points to the second input sequence.
4416:Core/Inc/arm_math.h ****    * @param[in]  srcBLen  length of the second input sequence.
ARM GAS  /tmp/ccpEjOub.s 			page 82


4417:Core/Inc/arm_math.h ****    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
4418:Core/Inc/arm_math.h ****    */
4419:Core/Inc/arm_math.h ****   void arm_correlate_q7(
4420:Core/Inc/arm_math.h ****   q7_t * pSrcA,
4421:Core/Inc/arm_math.h ****   uint32_t srcALen,
4422:Core/Inc/arm_math.h ****   q7_t * pSrcB,
4423:Core/Inc/arm_math.h ****   uint32_t srcBLen,
4424:Core/Inc/arm_math.h ****   q7_t * pDst);
4425:Core/Inc/arm_math.h **** 
4426:Core/Inc/arm_math.h **** 
4427:Core/Inc/arm_math.h ****   /**
4428:Core/Inc/arm_math.h ****    * @brief Instance structure for the floating-point sparse FIR filter.
4429:Core/Inc/arm_math.h ****    */
4430:Core/Inc/arm_math.h ****   typedef struct
4431:Core/Inc/arm_math.h ****   {
4432:Core/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4433:Core/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4434:Core/Inc/arm_math.h ****     float32_t *pState;            /**< points to the state buffer array. The array is of length max
4435:Core/Inc/arm_math.h ****     float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numT
4436:Core/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4437:Core/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4438:Core/Inc/arm_math.h ****   } arm_fir_sparse_instance_f32;
4439:Core/Inc/arm_math.h **** 
4440:Core/Inc/arm_math.h ****   /**
4441:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q31 sparse FIR filter.
4442:Core/Inc/arm_math.h ****    */
4443:Core/Inc/arm_math.h ****   typedef struct
4444:Core/Inc/arm_math.h ****   {
4445:Core/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4446:Core/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4447:Core/Inc/arm_math.h ****     q31_t *pState;                /**< points to the state buffer array. The array is of length max
4448:Core/Inc/arm_math.h ****     q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4449:Core/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4450:Core/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4451:Core/Inc/arm_math.h ****   } arm_fir_sparse_instance_q31;
4452:Core/Inc/arm_math.h **** 
4453:Core/Inc/arm_math.h ****   /**
4454:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q15 sparse FIR filter.
4455:Core/Inc/arm_math.h ****    */
4456:Core/Inc/arm_math.h ****   typedef struct
4457:Core/Inc/arm_math.h ****   {
4458:Core/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4459:Core/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4460:Core/Inc/arm_math.h ****     q15_t *pState;                /**< points to the state buffer array. The array is of length max
4461:Core/Inc/arm_math.h ****     q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numT
4462:Core/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4463:Core/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4464:Core/Inc/arm_math.h ****   } arm_fir_sparse_instance_q15;
4465:Core/Inc/arm_math.h **** 
4466:Core/Inc/arm_math.h ****   /**
4467:Core/Inc/arm_math.h ****    * @brief Instance structure for the Q7 sparse FIR filter.
4468:Core/Inc/arm_math.h ****    */
4469:Core/Inc/arm_math.h ****   typedef struct
4470:Core/Inc/arm_math.h ****   {
4471:Core/Inc/arm_math.h ****     uint16_t numTaps;             /**< number of coefficients in the filter. */
4472:Core/Inc/arm_math.h ****     uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the stat
4473:Core/Inc/arm_math.h ****     q7_t *pState;                 /**< points to the state buffer array. The array is of length max
ARM GAS  /tmp/ccpEjOub.s 			page 83


4474:Core/Inc/arm_math.h ****     q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numT
4475:Core/Inc/arm_math.h ****     uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
4476:Core/Inc/arm_math.h ****     int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length
4477:Core/Inc/arm_math.h ****   } arm_fir_sparse_instance_q7;
4478:Core/Inc/arm_math.h **** 
4479:Core/Inc/arm_math.h **** 
4480:Core/Inc/arm_math.h ****   /**
4481:Core/Inc/arm_math.h ****    * @brief Processing function for the floating-point sparse FIR filter.
4482:Core/Inc/arm_math.h ****    * @param[in]  S           points to an instance of the floating-point sparse FIR structure.
4483:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4484:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
4485:Core/Inc/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4486:Core/Inc/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4487:Core/Inc/arm_math.h ****    */
4488:Core/Inc/arm_math.h ****   void arm_fir_sparse_f32(
4489:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4490:Core/Inc/arm_math.h ****   float32_t * pSrc,
4491:Core/Inc/arm_math.h ****   float32_t * pDst,
4492:Core/Inc/arm_math.h ****   float32_t * pScratchIn,
4493:Core/Inc/arm_math.h ****   uint32_t blockSize);
4494:Core/Inc/arm_math.h **** 
4495:Core/Inc/arm_math.h **** 
4496:Core/Inc/arm_math.h ****   /**
4497:Core/Inc/arm_math.h ****    * @brief  Initialization function for the floating-point sparse FIR filter.
4498:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the floating-point sparse FIR structure.
4499:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4500:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4501:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4502:Core/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4503:Core/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4504:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4505:Core/Inc/arm_math.h ****    */
4506:Core/Inc/arm_math.h ****   void arm_fir_sparse_init_f32(
4507:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_f32 * S,
4508:Core/Inc/arm_math.h ****   uint16_t numTaps,
4509:Core/Inc/arm_math.h ****   float32_t * pCoeffs,
4510:Core/Inc/arm_math.h ****   float32_t * pState,
4511:Core/Inc/arm_math.h ****   int32_t * pTapDelay,
4512:Core/Inc/arm_math.h ****   uint16_t maxDelay,
4513:Core/Inc/arm_math.h ****   uint32_t blockSize);
4514:Core/Inc/arm_math.h **** 
4515:Core/Inc/arm_math.h **** 
4516:Core/Inc/arm_math.h ****   /**
4517:Core/Inc/arm_math.h ****    * @brief Processing function for the Q31 sparse FIR filter.
4518:Core/Inc/arm_math.h ****    * @param[in]  S           points to an instance of the Q31 sparse FIR structure.
4519:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the block of input data.
4520:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the block of output data
4521:Core/Inc/arm_math.h ****    * @param[in]  pScratchIn  points to a temporary buffer of size blockSize.
4522:Core/Inc/arm_math.h ****    * @param[in]  blockSize   number of input samples to process per call.
4523:Core/Inc/arm_math.h ****    */
4524:Core/Inc/arm_math.h ****   void arm_fir_sparse_q31(
4525:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4526:Core/Inc/arm_math.h ****   q31_t * pSrc,
4527:Core/Inc/arm_math.h ****   q31_t * pDst,
4528:Core/Inc/arm_math.h ****   q31_t * pScratchIn,
4529:Core/Inc/arm_math.h ****   uint32_t blockSize);
4530:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 84


4531:Core/Inc/arm_math.h **** 
4532:Core/Inc/arm_math.h ****   /**
4533:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q31 sparse FIR filter.
4534:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q31 sparse FIR structure.
4535:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4536:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4537:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4538:Core/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4539:Core/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4540:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4541:Core/Inc/arm_math.h ****    */
4542:Core/Inc/arm_math.h ****   void arm_fir_sparse_init_q31(
4543:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_q31 * S,
4544:Core/Inc/arm_math.h ****   uint16_t numTaps,
4545:Core/Inc/arm_math.h ****   q31_t * pCoeffs,
4546:Core/Inc/arm_math.h ****   q31_t * pState,
4547:Core/Inc/arm_math.h ****   int32_t * pTapDelay,
4548:Core/Inc/arm_math.h ****   uint16_t maxDelay,
4549:Core/Inc/arm_math.h ****   uint32_t blockSize);
4550:Core/Inc/arm_math.h **** 
4551:Core/Inc/arm_math.h **** 
4552:Core/Inc/arm_math.h ****   /**
4553:Core/Inc/arm_math.h ****    * @brief Processing function for the Q15 sparse FIR filter.
4554:Core/Inc/arm_math.h ****    * @param[in]  S            points to an instance of the Q15 sparse FIR structure.
4555:Core/Inc/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4556:Core/Inc/arm_math.h ****    * @param[out] pDst         points to the block of output data
4557:Core/Inc/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4558:Core/Inc/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4559:Core/Inc/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4560:Core/Inc/arm_math.h ****    */
4561:Core/Inc/arm_math.h ****   void arm_fir_sparse_q15(
4562:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4563:Core/Inc/arm_math.h ****   q15_t * pSrc,
4564:Core/Inc/arm_math.h ****   q15_t * pDst,
4565:Core/Inc/arm_math.h ****   q15_t * pScratchIn,
4566:Core/Inc/arm_math.h ****   q31_t * pScratchOut,
4567:Core/Inc/arm_math.h ****   uint32_t blockSize);
4568:Core/Inc/arm_math.h **** 
4569:Core/Inc/arm_math.h **** 
4570:Core/Inc/arm_math.h ****   /**
4571:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q15 sparse FIR filter.
4572:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q15 sparse FIR structure.
4573:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4574:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4575:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4576:Core/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4577:Core/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4578:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4579:Core/Inc/arm_math.h ****    */
4580:Core/Inc/arm_math.h ****   void arm_fir_sparse_init_q15(
4581:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_q15 * S,
4582:Core/Inc/arm_math.h ****   uint16_t numTaps,
4583:Core/Inc/arm_math.h ****   q15_t * pCoeffs,
4584:Core/Inc/arm_math.h ****   q15_t * pState,
4585:Core/Inc/arm_math.h ****   int32_t * pTapDelay,
4586:Core/Inc/arm_math.h ****   uint16_t maxDelay,
4587:Core/Inc/arm_math.h ****   uint32_t blockSize);
ARM GAS  /tmp/ccpEjOub.s 			page 85


4588:Core/Inc/arm_math.h **** 
4589:Core/Inc/arm_math.h **** 
4590:Core/Inc/arm_math.h ****   /**
4591:Core/Inc/arm_math.h ****    * @brief Processing function for the Q7 sparse FIR filter.
4592:Core/Inc/arm_math.h ****    * @param[in]  S            points to an instance of the Q7 sparse FIR structure.
4593:Core/Inc/arm_math.h ****    * @param[in]  pSrc         points to the block of input data.
4594:Core/Inc/arm_math.h ****    * @param[out] pDst         points to the block of output data
4595:Core/Inc/arm_math.h ****    * @param[in]  pScratchIn   points to a temporary buffer of size blockSize.
4596:Core/Inc/arm_math.h ****    * @param[in]  pScratchOut  points to a temporary buffer of size blockSize.
4597:Core/Inc/arm_math.h ****    * @param[in]  blockSize    number of input samples to process per call.
4598:Core/Inc/arm_math.h ****    */
4599:Core/Inc/arm_math.h ****   void arm_fir_sparse_q7(
4600:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4601:Core/Inc/arm_math.h ****   q7_t * pSrc,
4602:Core/Inc/arm_math.h ****   q7_t * pDst,
4603:Core/Inc/arm_math.h ****   q7_t * pScratchIn,
4604:Core/Inc/arm_math.h ****   q31_t * pScratchOut,
4605:Core/Inc/arm_math.h ****   uint32_t blockSize);
4606:Core/Inc/arm_math.h **** 
4607:Core/Inc/arm_math.h **** 
4608:Core/Inc/arm_math.h ****   /**
4609:Core/Inc/arm_math.h ****    * @brief  Initialization function for the Q7 sparse FIR filter.
4610:Core/Inc/arm_math.h ****    * @param[in,out] S          points to an instance of the Q7 sparse FIR structure.
4611:Core/Inc/arm_math.h ****    * @param[in]     numTaps    number of nonzero coefficients in the filter.
4612:Core/Inc/arm_math.h ****    * @param[in]     pCoeffs    points to the array of filter coefficients.
4613:Core/Inc/arm_math.h ****    * @param[in]     pState     points to the state buffer.
4614:Core/Inc/arm_math.h ****    * @param[in]     pTapDelay  points to the array of offset times.
4615:Core/Inc/arm_math.h ****    * @param[in]     maxDelay   maximum offset time supported.
4616:Core/Inc/arm_math.h ****    * @param[in]     blockSize  number of samples that will be processed per block.
4617:Core/Inc/arm_math.h ****    */
4618:Core/Inc/arm_math.h ****   void arm_fir_sparse_init_q7(
4619:Core/Inc/arm_math.h ****   arm_fir_sparse_instance_q7 * S,
4620:Core/Inc/arm_math.h ****   uint16_t numTaps,
4621:Core/Inc/arm_math.h ****   q7_t * pCoeffs,
4622:Core/Inc/arm_math.h ****   q7_t * pState,
4623:Core/Inc/arm_math.h ****   int32_t * pTapDelay,
4624:Core/Inc/arm_math.h ****   uint16_t maxDelay,
4625:Core/Inc/arm_math.h ****   uint32_t blockSize);
4626:Core/Inc/arm_math.h **** 
4627:Core/Inc/arm_math.h **** 
4628:Core/Inc/arm_math.h ****   /**
4629:Core/Inc/arm_math.h ****    * @brief  Floating-point sin_cos function.
4630:Core/Inc/arm_math.h ****    * @param[in]  theta   input value in degrees
4631:Core/Inc/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4632:Core/Inc/arm_math.h ****    * @param[out] pCosVal  points to the processed cos output.
4633:Core/Inc/arm_math.h ****    */
4634:Core/Inc/arm_math.h ****   void arm_sin_cos_f32(
4635:Core/Inc/arm_math.h ****   float32_t theta,
4636:Core/Inc/arm_math.h ****   float32_t * pSinVal,
4637:Core/Inc/arm_math.h ****   float32_t * pCosVal);
4638:Core/Inc/arm_math.h **** 
4639:Core/Inc/arm_math.h **** 
4640:Core/Inc/arm_math.h ****   /**
4641:Core/Inc/arm_math.h ****    * @brief  Q31 sin_cos function.
4642:Core/Inc/arm_math.h ****    * @param[in]  theta    scaled input value in degrees
4643:Core/Inc/arm_math.h ****    * @param[out] pSinVal  points to the processed sine output.
4644:Core/Inc/arm_math.h ****    * @param[out] pCosVal  points to the processed cosine output.
ARM GAS  /tmp/ccpEjOub.s 			page 86


4645:Core/Inc/arm_math.h ****    */
4646:Core/Inc/arm_math.h ****   void arm_sin_cos_q31(
4647:Core/Inc/arm_math.h ****   q31_t theta,
4648:Core/Inc/arm_math.h ****   q31_t * pSinVal,
4649:Core/Inc/arm_math.h ****   q31_t * pCosVal);
4650:Core/Inc/arm_math.h **** 
4651:Core/Inc/arm_math.h **** 
4652:Core/Inc/arm_math.h ****   /**
4653:Core/Inc/arm_math.h ****    * @brief  Floating-point complex conjugate.
4654:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4655:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
4656:Core/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4657:Core/Inc/arm_math.h ****    */
4658:Core/Inc/arm_math.h ****   void arm_cmplx_conj_f32(
4659:Core/Inc/arm_math.h ****   float32_t * pSrc,
4660:Core/Inc/arm_math.h ****   float32_t * pDst,
4661:Core/Inc/arm_math.h ****   uint32_t numSamples);
4662:Core/Inc/arm_math.h **** 
4663:Core/Inc/arm_math.h ****   /**
4664:Core/Inc/arm_math.h ****    * @brief  Q31 complex conjugate.
4665:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4666:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
4667:Core/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4668:Core/Inc/arm_math.h ****    */
4669:Core/Inc/arm_math.h ****   void arm_cmplx_conj_q31(
4670:Core/Inc/arm_math.h ****   q31_t * pSrc,
4671:Core/Inc/arm_math.h ****   q31_t * pDst,
4672:Core/Inc/arm_math.h ****   uint32_t numSamples);
4673:Core/Inc/arm_math.h **** 
4674:Core/Inc/arm_math.h **** 
4675:Core/Inc/arm_math.h ****   /**
4676:Core/Inc/arm_math.h ****    * @brief  Q15 complex conjugate.
4677:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the input vector
4678:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the output vector
4679:Core/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in each vector
4680:Core/Inc/arm_math.h ****    */
4681:Core/Inc/arm_math.h ****   void arm_cmplx_conj_q15(
4682:Core/Inc/arm_math.h ****   q15_t * pSrc,
4683:Core/Inc/arm_math.h ****   q15_t * pDst,
4684:Core/Inc/arm_math.h ****   uint32_t numSamples);
4685:Core/Inc/arm_math.h **** 
4686:Core/Inc/arm_math.h **** 
4687:Core/Inc/arm_math.h ****   /**
4688:Core/Inc/arm_math.h ****    * @brief  Floating-point complex magnitude squared
4689:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4690:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the real output vector
4691:Core/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4692:Core/Inc/arm_math.h ****    */
4693:Core/Inc/arm_math.h ****   void arm_cmplx_mag_squared_f32(
4694:Core/Inc/arm_math.h ****   float32_t * pSrc,
4695:Core/Inc/arm_math.h ****   float32_t * pDst,
4696:Core/Inc/arm_math.h ****   uint32_t numSamples);
4697:Core/Inc/arm_math.h **** 
4698:Core/Inc/arm_math.h **** 
4699:Core/Inc/arm_math.h ****   /**
4700:Core/Inc/arm_math.h ****    * @brief  Q31 complex magnitude squared
4701:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
ARM GAS  /tmp/ccpEjOub.s 			page 87


4702:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the real output vector
4703:Core/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4704:Core/Inc/arm_math.h ****    */
4705:Core/Inc/arm_math.h ****   void arm_cmplx_mag_squared_q31(
4706:Core/Inc/arm_math.h ****   q31_t * pSrc,
4707:Core/Inc/arm_math.h ****   q31_t * pDst,
4708:Core/Inc/arm_math.h ****   uint32_t numSamples);
4709:Core/Inc/arm_math.h **** 
4710:Core/Inc/arm_math.h **** 
4711:Core/Inc/arm_math.h ****   /**
4712:Core/Inc/arm_math.h ****    * @brief  Q15 complex magnitude squared
4713:Core/Inc/arm_math.h ****    * @param[in]  pSrc        points to the complex input vector
4714:Core/Inc/arm_math.h ****    * @param[out] pDst        points to the real output vector
4715:Core/Inc/arm_math.h ****    * @param[in]  numSamples  number of complex samples in the input vector
4716:Core/Inc/arm_math.h ****    */
4717:Core/Inc/arm_math.h ****   void arm_cmplx_mag_squared_q15(
4718:Core/Inc/arm_math.h ****   q15_t * pSrc,
4719:Core/Inc/arm_math.h ****   q15_t * pDst,
4720:Core/Inc/arm_math.h ****   uint32_t numSamples);
4721:Core/Inc/arm_math.h **** 
4722:Core/Inc/arm_math.h **** 
4723:Core/Inc/arm_math.h ****  /**
4724:Core/Inc/arm_math.h ****    * @ingroup groupController
4725:Core/Inc/arm_math.h ****    */
4726:Core/Inc/arm_math.h **** 
4727:Core/Inc/arm_math.h ****   /**
4728:Core/Inc/arm_math.h ****    * @defgroup PID PID Motor Control
4729:Core/Inc/arm_math.h ****    *
4730:Core/Inc/arm_math.h ****    * A Proportional Integral Derivative (PID) controller is a generic feedback control
4731:Core/Inc/arm_math.h ****    * loop mechanism widely used in industrial control systems.
4732:Core/Inc/arm_math.h ****    * A PID controller is the most commonly used type of feedback controller.
4733:Core/Inc/arm_math.h ****    *
4734:Core/Inc/arm_math.h ****    * This set of functions implements (PID) controllers
4735:Core/Inc/arm_math.h ****    * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
4736:Core/Inc/arm_math.h ****    * of data and each call to the function returns a single processed value.
4737:Core/Inc/arm_math.h ****    * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
4738:Core/Inc/arm_math.h ****    * is the input sample value. The functions return the output value.
4739:Core/Inc/arm_math.h ****    *
4740:Core/Inc/arm_math.h ****    * \par Algorithm:
4741:Core/Inc/arm_math.h ****    * <pre>
4742:Core/Inc/arm_math.h ****    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
4743:Core/Inc/arm_math.h ****    *    A0 = Kp + Ki + Kd
4744:Core/Inc/arm_math.h ****    *    A1 = (-Kp ) - (2 * Kd )
4745:Core/Inc/arm_math.h ****    *    A2 = Kd  </pre>
4746:Core/Inc/arm_math.h ****    *
4747:Core/Inc/arm_math.h ****    * \par
4748:Core/Inc/arm_math.h ****    * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative const
4749:Core/Inc/arm_math.h ****    *
4750:Core/Inc/arm_math.h ****    * \par
4751:Core/Inc/arm_math.h ****    * \image html PID.gif "Proportional Integral Derivative Controller"
4752:Core/Inc/arm_math.h ****    *
4753:Core/Inc/arm_math.h ****    * \par
4754:Core/Inc/arm_math.h ****    * The PID controller calculates an "error" value as the difference between
4755:Core/Inc/arm_math.h ****    * the measured output and the reference input.
4756:Core/Inc/arm_math.h ****    * The controller attempts to minimize the error by adjusting the process control inputs.
4757:Core/Inc/arm_math.h ****    * The proportional value determines the reaction to the current error,
4758:Core/Inc/arm_math.h ****    * the integral value determines the reaction based on the sum of recent errors,
ARM GAS  /tmp/ccpEjOub.s 			page 88


4759:Core/Inc/arm_math.h ****    * and the derivative value determines the reaction based on the rate at which the error has been
4760:Core/Inc/arm_math.h ****    *
4761:Core/Inc/arm_math.h ****    * \par Instance Structure
4762:Core/Inc/arm_math.h ****    * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instan
4763:Core/Inc/arm_math.h ****    * A separate instance structure must be defined for each PID Controller.
4764:Core/Inc/arm_math.h ****    * There are separate instance structure declarations for each of the 3 supported data types.
4765:Core/Inc/arm_math.h ****    *
4766:Core/Inc/arm_math.h ****    * \par Reset Functions
4767:Core/Inc/arm_math.h ****    * There is also an associated reset function for each data type which clears the state array.
4768:Core/Inc/arm_math.h ****    *
4769:Core/Inc/arm_math.h ****    * \par Initialization Functions
4770:Core/Inc/arm_math.h ****    * There is also an associated initialization function for each data type.
4771:Core/Inc/arm_math.h ****    * The initialization function performs the following operations:
4772:Core/Inc/arm_math.h ****    * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
4773:Core/Inc/arm_math.h ****    * - Zeros out the values in the state buffer.
4774:Core/Inc/arm_math.h ****    *
4775:Core/Inc/arm_math.h ****    * \par
4776:Core/Inc/arm_math.h ****    * Instance structure cannot be placed into a const data section and it is recommended to use the
4777:Core/Inc/arm_math.h ****    *
4778:Core/Inc/arm_math.h ****    * \par Fixed-Point Behavior
4779:Core/Inc/arm_math.h ****    * Care must be taken when using the fixed-point versions of the PID Controller functions.
4780:Core/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used in each function m
4781:Core/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4782:Core/Inc/arm_math.h ****    */
4783:Core/Inc/arm_math.h **** 
4784:Core/Inc/arm_math.h ****   /**
4785:Core/Inc/arm_math.h ****    * @addtogroup PID
4786:Core/Inc/arm_math.h ****    * @{
4787:Core/Inc/arm_math.h ****    */
4788:Core/Inc/arm_math.h **** 
4789:Core/Inc/arm_math.h ****   /**
4790:Core/Inc/arm_math.h ****    * @brief  Process function for the floating-point PID Control.
4791:Core/Inc/arm_math.h ****    * @param[in,out] S   is an instance of the floating-point PID Control structure
4792:Core/Inc/arm_math.h ****    * @param[in]     in  input sample to process
4793:Core/Inc/arm_math.h ****    * @return out processed output sample.
4794:Core/Inc/arm_math.h ****    */
4795:Core/Inc/arm_math.h ****   static __INLINE float32_t arm_pid_f32(
4796:Core/Inc/arm_math.h ****   arm_pid_instance_f32 * S,
4797:Core/Inc/arm_math.h ****   float32_t in)
4798:Core/Inc/arm_math.h ****   {
4799:Core/Inc/arm_math.h ****     float32_t out;
4800:Core/Inc/arm_math.h **** 
4801:Core/Inc/arm_math.h ****     /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
4802:Core/Inc/arm_math.h ****     out = (S->A0 * in) +
4803:Core/Inc/arm_math.h ****       (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
4804:Core/Inc/arm_math.h **** 
4805:Core/Inc/arm_math.h ****     /* Update state */
4806:Core/Inc/arm_math.h ****     S->state[1] = S->state[0];
4807:Core/Inc/arm_math.h ****     S->state[0] = in;
4808:Core/Inc/arm_math.h ****     S->state[2] = out;
4809:Core/Inc/arm_math.h **** 
4810:Core/Inc/arm_math.h ****     /* return to application */
4811:Core/Inc/arm_math.h ****     return (out);
4812:Core/Inc/arm_math.h **** 
4813:Core/Inc/arm_math.h ****   }
4814:Core/Inc/arm_math.h **** 
4815:Core/Inc/arm_math.h ****   /**
ARM GAS  /tmp/ccpEjOub.s 			page 89


4816:Core/Inc/arm_math.h ****    * @brief  Process function for the Q31 PID Control.
4817:Core/Inc/arm_math.h ****    * @param[in,out] S  points to an instance of the Q31 PID Control structure
4818:Core/Inc/arm_math.h ****    * @param[in]     in  input sample to process
4819:Core/Inc/arm_math.h ****    * @return out processed output sample.
4820:Core/Inc/arm_math.h ****    *
4821:Core/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4822:Core/Inc/arm_math.h ****    * \par
4823:Core/Inc/arm_math.h ****    * The function is implemented using an internal 64-bit accumulator.
4824:Core/Inc/arm_math.h ****    * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplicat
4825:Core/Inc/arm_math.h ****    * Thus, if the accumulator result overflows it wraps around rather than clip.
4826:Core/Inc/arm_math.h ****    * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there
4827:Core/Inc/arm_math.h ****    * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format
4828:Core/Inc/arm_math.h ****    */
4829:Core/Inc/arm_math.h ****   static __INLINE q31_t arm_pid_q31(
4830:Core/Inc/arm_math.h ****   arm_pid_instance_q31 * S,
4831:Core/Inc/arm_math.h ****   q31_t in)
4832:Core/Inc/arm_math.h ****   {
4833:Core/Inc/arm_math.h ****     q63_t acc;
4834:Core/Inc/arm_math.h ****     q31_t out;
4835:Core/Inc/arm_math.h **** 
4836:Core/Inc/arm_math.h ****     /* acc = A0 * x[n]  */
4837:Core/Inc/arm_math.h ****     acc = (q63_t) S->A0 * in;
4838:Core/Inc/arm_math.h **** 
4839:Core/Inc/arm_math.h ****     /* acc += A1 * x[n-1] */
4840:Core/Inc/arm_math.h ****     acc += (q63_t) S->A1 * S->state[0];
4841:Core/Inc/arm_math.h **** 
4842:Core/Inc/arm_math.h ****     /* acc += A2 * x[n-2]  */
4843:Core/Inc/arm_math.h ****     acc += (q63_t) S->A2 * S->state[1];
4844:Core/Inc/arm_math.h **** 
4845:Core/Inc/arm_math.h ****     /* convert output to 1.31 format to add y[n-1] */
4846:Core/Inc/arm_math.h ****     out = (q31_t) (acc >> 31u);
4847:Core/Inc/arm_math.h **** 
4848:Core/Inc/arm_math.h ****     /* out += y[n-1] */
4849:Core/Inc/arm_math.h ****     out += S->state[2];
4850:Core/Inc/arm_math.h **** 
4851:Core/Inc/arm_math.h ****     /* Update state */
4852:Core/Inc/arm_math.h ****     S->state[1] = S->state[0];
4853:Core/Inc/arm_math.h ****     S->state[0] = in;
4854:Core/Inc/arm_math.h ****     S->state[2] = out;
4855:Core/Inc/arm_math.h **** 
4856:Core/Inc/arm_math.h ****     /* return to application */
4857:Core/Inc/arm_math.h ****     return (out);
4858:Core/Inc/arm_math.h ****   }
4859:Core/Inc/arm_math.h **** 
4860:Core/Inc/arm_math.h **** 
4861:Core/Inc/arm_math.h ****   /**
4862:Core/Inc/arm_math.h ****    * @brief  Process function for the Q15 PID Control.
4863:Core/Inc/arm_math.h ****    * @param[in,out] S   points to an instance of the Q15 PID Control structure
4864:Core/Inc/arm_math.h ****    * @param[in]     in  input sample to process
4865:Core/Inc/arm_math.h ****    * @return out processed output sample.
4866:Core/Inc/arm_math.h ****    *
4867:Core/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
4868:Core/Inc/arm_math.h ****    * \par
4869:Core/Inc/arm_math.h ****    * The function is implemented using a 64-bit internal accumulator.
4870:Core/Inc/arm_math.h ****    * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30
4871:Core/Inc/arm_math.h ****    * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
4872:Core/Inc/arm_math.h ****    * There is no risk of internal overflow with this approach and the full precision of intermediat
ARM GAS  /tmp/ccpEjOub.s 			page 90


4873:Core/Inc/arm_math.h ****    * After all additions have been performed, the accumulator is truncated to 34.15 format by disca
4874:Core/Inc/arm_math.h ****    * Lastly, the accumulator is saturated to yield a result in 1.15 format.
4875:Core/Inc/arm_math.h ****    */
4876:Core/Inc/arm_math.h ****   static __INLINE q15_t arm_pid_q15(
4877:Core/Inc/arm_math.h ****   arm_pid_instance_q15 * S,
4878:Core/Inc/arm_math.h ****   q15_t in)
4879:Core/Inc/arm_math.h ****   {
4880:Core/Inc/arm_math.h ****     q63_t acc;
4881:Core/Inc/arm_math.h ****     q15_t out;
4882:Core/Inc/arm_math.h **** 
4883:Core/Inc/arm_math.h **** #ifndef ARM_MATH_CM0_FAMILY
4884:Core/Inc/arm_math.h ****     __SIMD32_TYPE *vstate;
4885:Core/Inc/arm_math.h **** 
4886:Core/Inc/arm_math.h ****     /* Implementation of PID controller */
4887:Core/Inc/arm_math.h **** 
4888:Core/Inc/arm_math.h ****     /* acc = A0 * x[n]  */
4889:Core/Inc/arm_math.h ****     acc = (q31_t) __SMUAD((uint32_t)S->A0, (uint32_t)in);
4890:Core/Inc/arm_math.h **** 
4891:Core/Inc/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4892:Core/Inc/arm_math.h ****     vstate = __SIMD32_CONST(S->state);
4893:Core/Inc/arm_math.h ****     acc = (q63_t)__SMLALD((uint32_t)S->A1, (uint32_t)*vstate, (uint64_t)acc);
4894:Core/Inc/arm_math.h **** #else
4895:Core/Inc/arm_math.h ****     /* acc = A0 * x[n]  */
4896:Core/Inc/arm_math.h ****     acc = ((q31_t) S->A0) * in;
4897:Core/Inc/arm_math.h **** 
4898:Core/Inc/arm_math.h ****     /* acc += A1 * x[n-1] + A2 * x[n-2]  */
4899:Core/Inc/arm_math.h ****     acc += (q31_t) S->A1 * S->state[0];
4900:Core/Inc/arm_math.h ****     acc += (q31_t) S->A2 * S->state[1];
4901:Core/Inc/arm_math.h **** #endif
4902:Core/Inc/arm_math.h **** 
4903:Core/Inc/arm_math.h ****     /* acc += y[n-1] */
4904:Core/Inc/arm_math.h ****     acc += (q31_t) S->state[2] << 15;
4905:Core/Inc/arm_math.h **** 
4906:Core/Inc/arm_math.h ****     /* saturate the output */
4907:Core/Inc/arm_math.h ****     out = (q15_t) (__SSAT((acc >> 15), 16));
4908:Core/Inc/arm_math.h **** 
4909:Core/Inc/arm_math.h ****     /* Update state */
4910:Core/Inc/arm_math.h ****     S->state[1] = S->state[0];
4911:Core/Inc/arm_math.h ****     S->state[0] = in;
4912:Core/Inc/arm_math.h ****     S->state[2] = out;
4913:Core/Inc/arm_math.h **** 
4914:Core/Inc/arm_math.h ****     /* return to application */
4915:Core/Inc/arm_math.h ****     return (out);
4916:Core/Inc/arm_math.h ****   }
4917:Core/Inc/arm_math.h **** 
4918:Core/Inc/arm_math.h ****   /**
4919:Core/Inc/arm_math.h ****    * @} end of PID group
4920:Core/Inc/arm_math.h ****    */
4921:Core/Inc/arm_math.h **** 
4922:Core/Inc/arm_math.h **** 
4923:Core/Inc/arm_math.h ****   /**
4924:Core/Inc/arm_math.h ****    * @brief Floating-point matrix inverse.
4925:Core/Inc/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4926:Core/Inc/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4927:Core/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4928:Core/Inc/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4929:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 91


4930:Core/Inc/arm_math.h ****   arm_status arm_mat_inverse_f32(
4931:Core/Inc/arm_math.h ****   const arm_matrix_instance_f32 * src,
4932:Core/Inc/arm_math.h ****   arm_matrix_instance_f32 * dst);
4933:Core/Inc/arm_math.h **** 
4934:Core/Inc/arm_math.h **** 
4935:Core/Inc/arm_math.h ****   /**
4936:Core/Inc/arm_math.h ****    * @brief Floating-point matrix inverse.
4937:Core/Inc/arm_math.h ****    * @param[in]  src   points to the instance of the input floating-point matrix structure.
4938:Core/Inc/arm_math.h ****    * @param[out] dst   points to the instance of the output floating-point matrix structure.
4939:Core/Inc/arm_math.h ****    * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
4940:Core/Inc/arm_math.h ****    * If the input matrix is singular (does not have an inverse), then the algorithm terminates and 
4941:Core/Inc/arm_math.h ****    */
4942:Core/Inc/arm_math.h ****   arm_status arm_mat_inverse_f64(
4943:Core/Inc/arm_math.h ****   const arm_matrix_instance_f64 * src,
4944:Core/Inc/arm_math.h ****   arm_matrix_instance_f64 * dst);
4945:Core/Inc/arm_math.h **** 
4946:Core/Inc/arm_math.h **** 
4947:Core/Inc/arm_math.h **** 
4948:Core/Inc/arm_math.h ****   /**
4949:Core/Inc/arm_math.h ****    * @ingroup groupController
4950:Core/Inc/arm_math.h ****    */
4951:Core/Inc/arm_math.h **** 
4952:Core/Inc/arm_math.h ****   /**
4953:Core/Inc/arm_math.h ****    * @defgroup clarke Vector Clarke Transform
4954:Core/Inc/arm_math.h ****    * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time i
4955:Core/Inc/arm_math.h ****    * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calcula
4956:Core/Inc/arm_math.h ****    * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
4957:Core/Inc/arm_math.h ****    * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
4958:Core/Inc/arm_math.h ****    * \image html clarke.gif Stator current space vector and its components in (a,b).
4959:Core/Inc/arm_math.h ****    * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code
4960:Core/Inc/arm_math.h ****    * can be calculated using only <code>Ia</code> and <code>Ib</code>.
4961:Core/Inc/arm_math.h ****    *
4962:Core/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
4963:Core/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
4964:Core/Inc/arm_math.h ****    * \par Algorithm
4965:Core/Inc/arm_math.h ****    * \image html clarkeFormula.gif
4966:Core/Inc/arm_math.h ****    * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
4967:Core/Inc/arm_math.h ****    * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
4968:Core/Inc/arm_math.h ****    * \par Fixed-Point Behavior
4969:Core/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
4970:Core/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
4971:Core/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
4972:Core/Inc/arm_math.h ****    */
4973:Core/Inc/arm_math.h **** 
4974:Core/Inc/arm_math.h ****   /**
4975:Core/Inc/arm_math.h ****    * @addtogroup clarke
4976:Core/Inc/arm_math.h ****    * @{
4977:Core/Inc/arm_math.h ****    */
4978:Core/Inc/arm_math.h **** 
4979:Core/Inc/arm_math.h ****   /**
4980:Core/Inc/arm_math.h ****    *
4981:Core/Inc/arm_math.h ****    * @brief  Floating-point Clarke transform
4982:Core/Inc/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
4983:Core/Inc/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
4984:Core/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
4985:Core/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
4986:Core/Inc/arm_math.h ****    */
ARM GAS  /tmp/ccpEjOub.s 			page 92


4987:Core/Inc/arm_math.h ****   static __INLINE void arm_clarke_f32(
4988:Core/Inc/arm_math.h ****   float32_t Ia,
4989:Core/Inc/arm_math.h ****   float32_t Ib,
4990:Core/Inc/arm_math.h ****   float32_t * pIalpha,
4991:Core/Inc/arm_math.h ****   float32_t * pIbeta)
4992:Core/Inc/arm_math.h ****   {
4993:Core/Inc/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Ia */
4994:Core/Inc/arm_math.h ****     *pIalpha = Ia;
4995:Core/Inc/arm_math.h **** 
4996:Core/Inc/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
4997:Core/Inc/arm_math.h ****     *pIbeta = ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
4998:Core/Inc/arm_math.h ****   }
4999:Core/Inc/arm_math.h **** 
5000:Core/Inc/arm_math.h **** 
5001:Core/Inc/arm_math.h ****   /**
5002:Core/Inc/arm_math.h ****    * @brief  Clarke transform for Q31 version
5003:Core/Inc/arm_math.h ****    * @param[in]  Ia       input three-phase coordinate <code>a</code>
5004:Core/Inc/arm_math.h ****    * @param[in]  Ib       input three-phase coordinate <code>b</code>
5005:Core/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5006:Core/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5007:Core/Inc/arm_math.h ****    *
5008:Core/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5009:Core/Inc/arm_math.h ****    * \par
5010:Core/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5011:Core/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5012:Core/Inc/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5013:Core/Inc/arm_math.h ****    */
5014:Core/Inc/arm_math.h ****   static __INLINE void arm_clarke_q31(
5015:Core/Inc/arm_math.h ****   q31_t Ia,
5016:Core/Inc/arm_math.h ****   q31_t Ib,
5017:Core/Inc/arm_math.h ****   q31_t * pIalpha,
5018:Core/Inc/arm_math.h ****   q31_t * pIbeta)
5019:Core/Inc/arm_math.h ****   {
 209              		.loc 1 5019 3
 210              		.cfi_startproc
 211              		@ args = 0, pretend = 0, frame = 24
 212              		@ frame_needed = 1, uses_anonymous_args = 0
 213 0000 80B5     		push	{r7, lr}
 214              	.LCFI16:
 215              		.cfi_def_cfa_offset 8
 216              		.cfi_offset 7, -8
 217              		.cfi_offset 14, -4
 218 0002 86B0     		sub	sp, sp, #24
 219              	.LCFI17:
 220              		.cfi_def_cfa_offset 32
 221 0004 00AF     		add	r7, sp, #0
 222              	.LCFI18:
 223              		.cfi_def_cfa_register 7
 224 0006 F860     		str	r0, [r7, #12]
 225 0008 B960     		str	r1, [r7, #8]
 226 000a 7A60     		str	r2, [r7, #4]
 227 000c 3B60     		str	r3, [r7]
5020:Core/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5021:Core/Inc/arm_math.h **** 
5022:Core/Inc/arm_math.h ****     /* Calculating pIalpha from Ia by equation pIalpha = Ia */
5023:Core/Inc/arm_math.h ****     *pIalpha = Ia;
 228              		.loc 1 5023 14
ARM GAS  /tmp/ccpEjOub.s 			page 93


 229 000e 7B68     		ldr	r3, [r7, #4]
 230 0010 FA68     		ldr	r2, [r7, #12]
 231 0012 1A60     		str	r2, [r3]
5024:Core/Inc/arm_math.h **** 
5025:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
5026:Core/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
 232              		.loc 1 5026 26
 233 0014 FB68     		ldr	r3, [r7, #12]
 234 0016 1A46     		mov	r2, r3
 235 0018 4FEAE273 		asr	r3, r2, #31
 236              		.loc 1 5026 37
 237 001c 1D49     		ldr	r1, .L10
 238 001e 01FB03F0 		mul	r0, r1, r3
 239 0022 0021     		movs	r1, #0
 240 0024 01FB02F1 		mul	r1, r1, r2
 241 0028 0144     		add	r1, r1, r0
 242 002a 1A48     		ldr	r0, .L10
 243 002c A2FB0023 		umull	r2, r3, r2, r0
 244 0030 1944     		add	r1, r1, r3
 245 0032 0B46     		mov	r3, r1
 246              		.loc 1 5026 51
 247 0034 4FF00000 		mov	r0, #0
 248 0038 4FF00001 		mov	r1, #0
 249 003c 900F     		lsrs	r0, r2, #30
 250 003e 40EA8300 		orr	r0, r0, r3, lsl #2
 251 0042 9917     		asrs	r1, r3, #30
 252              		.loc 1 5026 14
 253 0044 0346     		mov	r3, r0
 254 0046 7B61     		str	r3, [r7, #20]
5027:Core/Inc/arm_math.h **** 
5028:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
5029:Core/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
 255              		.loc 1 5029 26
 256 0048 BB68     		ldr	r3, [r7, #8]
 257 004a 1A46     		mov	r2, r3
 258 004c 4FEAE273 		asr	r3, r2, #31
 259              		.loc 1 5029 37
 260 0050 1149     		ldr	r1, .L10+4
 261 0052 01FB03F0 		mul	r0, r1, r3
 262 0056 0021     		movs	r1, #0
 263 0058 01FB02F1 		mul	r1, r1, r2
 264 005c 0144     		add	r1, r1, r0
 265 005e 0E48     		ldr	r0, .L10+4
 266 0060 A2FB0023 		umull	r2, r3, r2, r0
 267 0064 1944     		add	r1, r1, r3
 268 0066 0B46     		mov	r3, r1
 269              		.loc 1 5029 51
 270 0068 4FF00000 		mov	r0, #0
 271 006c 4FF00001 		mov	r1, #0
 272 0070 900F     		lsrs	r0, r2, #30
 273 0072 40EA8300 		orr	r0, r0, r3, lsl #2
 274 0076 9917     		asrs	r1, r3, #30
 275              		.loc 1 5029 14
 276 0078 0346     		mov	r3, r0
 277 007a 3B61     		str	r3, [r7, #16]
5030:Core/Inc/arm_math.h **** 
5031:Core/Inc/arm_math.h ****     /* pIbeta is calculated by adding the intermediate products */
ARM GAS  /tmp/ccpEjOub.s 			page 94


5032:Core/Inc/arm_math.h ****     *pIbeta = __QADD(product1, product2);
 278              		.loc 1 5032 15
 279 007c 3969     		ldr	r1, [r7, #16]
 280 007e 7869     		ldr	r0, [r7, #20]
 281 0080 FFF7FEFF 		bl	__QADD
 282 0084 0246     		mov	r2, r0
 283              		.loc 1 5032 13
 284 0086 3B68     		ldr	r3, [r7]
 285 0088 1A60     		str	r2, [r3]
5033:Core/Inc/arm_math.h ****   }
 286              		.loc 1 5033 3
 287 008a 00BF     		nop
 288 008c 1837     		adds	r7, r7, #24
 289              	.LCFI19:
 290              		.cfi_def_cfa_offset 8
 291 008e BD46     		mov	sp, r7
 292              	.LCFI20:
 293              		.cfi_def_cfa_register 13
 294              		@ sp needed
 295 0090 80BD     		pop	{r7, pc}
 296              	.L11:
 297 0092 00BF     		.align	2
 298              	.L10:
 299 0094 8B4EF324 		.word	619925131
 300 0098 169DE649 		.word	1239850262
 301              		.cfi_endproc
 302              	.LFE77:
 304              		.section	.text.arm_park_q31,"ax",%progbits
 305              		.align	1
 306              		.syntax unified
 307              		.thumb
 308              		.thumb_func
 309              		.fpu softvfp
 311              	arm_park_q31:
 312              	.LFB81:
5034:Core/Inc/arm_math.h **** 
5035:Core/Inc/arm_math.h ****   /**
5036:Core/Inc/arm_math.h ****    * @} end of clarke group
5037:Core/Inc/arm_math.h ****    */
5038:Core/Inc/arm_math.h **** 
5039:Core/Inc/arm_math.h ****   /**
5040:Core/Inc/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q31 vector.
5041:Core/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
5042:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
5043:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5044:Core/Inc/arm_math.h ****    */
5045:Core/Inc/arm_math.h ****   void arm_q7_to_q31(
5046:Core/Inc/arm_math.h ****   q7_t * pSrc,
5047:Core/Inc/arm_math.h ****   q31_t * pDst,
5048:Core/Inc/arm_math.h ****   uint32_t blockSize);
5049:Core/Inc/arm_math.h **** 
5050:Core/Inc/arm_math.h **** 
5051:Core/Inc/arm_math.h **** 
5052:Core/Inc/arm_math.h ****   /**
5053:Core/Inc/arm_math.h ****    * @ingroup groupController
5054:Core/Inc/arm_math.h ****    */
5055:Core/Inc/arm_math.h **** 
ARM GAS  /tmp/ccpEjOub.s 			page 95


5056:Core/Inc/arm_math.h ****   /**
5057:Core/Inc/arm_math.h ****    * @defgroup inv_clarke Vector Inverse Clarke Transform
5058:Core/Inc/arm_math.h ****    * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous 
5059:Core/Inc/arm_math.h ****    *
5060:Core/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5061:Core/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5062:Core/Inc/arm_math.h ****    * \par Algorithm
5063:Core/Inc/arm_math.h ****    * \image html clarkeInvFormula.gif
5064:Core/Inc/arm_math.h ****    * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
5065:Core/Inc/arm_math.h ****    * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
5066:Core/Inc/arm_math.h ****    * \par Fixed-Point Behavior
5067:Core/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Clarke transform.
5068:Core/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5069:Core/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5070:Core/Inc/arm_math.h ****    */
5071:Core/Inc/arm_math.h **** 
5072:Core/Inc/arm_math.h ****   /**
5073:Core/Inc/arm_math.h ****    * @addtogroup inv_clarke
5074:Core/Inc/arm_math.h ****    * @{
5075:Core/Inc/arm_math.h ****    */
5076:Core/Inc/arm_math.h **** 
5077:Core/Inc/arm_math.h ****    /**
5078:Core/Inc/arm_math.h ****    * @brief  Floating-point Inverse Clarke transform
5079:Core/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5080:Core/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5081:Core/Inc/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5082:Core/Inc/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5083:Core/Inc/arm_math.h ****    */
5084:Core/Inc/arm_math.h ****   static __INLINE void arm_inv_clarke_f32(
5085:Core/Inc/arm_math.h ****   float32_t Ialpha,
5086:Core/Inc/arm_math.h ****   float32_t Ibeta,
5087:Core/Inc/arm_math.h ****   float32_t * pIa,
5088:Core/Inc/arm_math.h ****   float32_t * pIb)
5089:Core/Inc/arm_math.h ****   {
5090:Core/Inc/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5091:Core/Inc/arm_math.h ****     *pIa = Ialpha;
5092:Core/Inc/arm_math.h **** 
5093:Core/Inc/arm_math.h ****     /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibet
5094:Core/Inc/arm_math.h ****     *pIb = -0.5f * Ialpha + 0.8660254039f * Ibeta;
5095:Core/Inc/arm_math.h ****   }
5096:Core/Inc/arm_math.h **** 
5097:Core/Inc/arm_math.h **** 
5098:Core/Inc/arm_math.h ****   /**
5099:Core/Inc/arm_math.h ****    * @brief  Inverse Clarke transform for Q31 version
5100:Core/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase orthogonal vector axis alpha
5101:Core/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase orthogonal vector axis beta
5102:Core/Inc/arm_math.h ****    * @param[out] pIa     points to output three-phase coordinate <code>a</code>
5103:Core/Inc/arm_math.h ****    * @param[out] pIb     points to output three-phase coordinate <code>b</code>
5104:Core/Inc/arm_math.h ****    *
5105:Core/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5106:Core/Inc/arm_math.h ****    * \par
5107:Core/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5108:Core/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5109:Core/Inc/arm_math.h ****    * There is saturation on the subtraction, hence there is no risk of overflow.
5110:Core/Inc/arm_math.h ****    */
5111:Core/Inc/arm_math.h ****   static __INLINE void arm_inv_clarke_q31(
5112:Core/Inc/arm_math.h ****   q31_t Ialpha,
ARM GAS  /tmp/ccpEjOub.s 			page 96


5113:Core/Inc/arm_math.h ****   q31_t Ibeta,
5114:Core/Inc/arm_math.h ****   q31_t * pIa,
5115:Core/Inc/arm_math.h ****   q31_t * pIb)
5116:Core/Inc/arm_math.h ****   {
5117:Core/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5118:Core/Inc/arm_math.h **** 
5119:Core/Inc/arm_math.h ****     /* Calculating pIa from Ialpha by equation pIa = Ialpha */
5120:Core/Inc/arm_math.h ****     *pIa = Ialpha;
5121:Core/Inc/arm_math.h **** 
5122:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
5123:Core/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
5124:Core/Inc/arm_math.h **** 
5125:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
5126:Core/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
5127:Core/Inc/arm_math.h **** 
5128:Core/Inc/arm_math.h ****     /* pIb is calculated by subtracting the products */
5129:Core/Inc/arm_math.h ****     *pIb = __QSUB(product2, product1);
5130:Core/Inc/arm_math.h ****   }
5131:Core/Inc/arm_math.h **** 
5132:Core/Inc/arm_math.h ****   /**
5133:Core/Inc/arm_math.h ****    * @} end of inv_clarke group
5134:Core/Inc/arm_math.h ****    */
5135:Core/Inc/arm_math.h **** 
5136:Core/Inc/arm_math.h ****   /**
5137:Core/Inc/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to Q15 vector.
5138:Core/Inc/arm_math.h ****    * @param[in]  pSrc       input pointer
5139:Core/Inc/arm_math.h ****    * @param[out] pDst       output pointer
5140:Core/Inc/arm_math.h ****    * @param[in]  blockSize  number of samples to process
5141:Core/Inc/arm_math.h ****    */
5142:Core/Inc/arm_math.h ****   void arm_q7_to_q15(
5143:Core/Inc/arm_math.h ****   q7_t * pSrc,
5144:Core/Inc/arm_math.h ****   q15_t * pDst,
5145:Core/Inc/arm_math.h ****   uint32_t blockSize);
5146:Core/Inc/arm_math.h **** 
5147:Core/Inc/arm_math.h **** 
5148:Core/Inc/arm_math.h **** 
5149:Core/Inc/arm_math.h ****   /**
5150:Core/Inc/arm_math.h ****    * @ingroup groupController
5151:Core/Inc/arm_math.h ****    */
5152:Core/Inc/arm_math.h **** 
5153:Core/Inc/arm_math.h ****   /**
5154:Core/Inc/arm_math.h ****    * @defgroup park Vector Park Transform
5155:Core/Inc/arm_math.h ****    *
5156:Core/Inc/arm_math.h ****    * Forward Park transform converts the input two-coordinate vector to flux and torque components.
5157:Core/Inc/arm_math.h ****    * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and th
5158:Core/Inc/arm_math.h ****    * from the stationary to the moving reference frame and control the spatial relationship between
5159:Core/Inc/arm_math.h ****    * the stator vector current and rotor flux vector.
5160:Core/Inc/arm_math.h ****    * If we consider the d axis aligned with the rotor flux, the diagram below shows the
5161:Core/Inc/arm_math.h ****    * current vector and the relationship from the two reference frames:
5162:Core/Inc/arm_math.h ****    * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q ro
5163:Core/Inc/arm_math.h ****    *
5164:Core/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5165:Core/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5166:Core/Inc/arm_math.h ****    * \par Algorithm
5167:Core/Inc/arm_math.h ****    * \image html parkFormula.gif
5168:Core/Inc/arm_math.h ****    * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
5169:Core/Inc/arm_math.h ****    * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and 
ARM GAS  /tmp/ccpEjOub.s 			page 97


5170:Core/Inc/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5171:Core/Inc/arm_math.h ****    * \par Fixed-Point Behavior
5172:Core/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5173:Core/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5174:Core/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5175:Core/Inc/arm_math.h ****    */
5176:Core/Inc/arm_math.h **** 
5177:Core/Inc/arm_math.h ****   /**
5178:Core/Inc/arm_math.h ****    * @addtogroup park
5179:Core/Inc/arm_math.h ****    * @{
5180:Core/Inc/arm_math.h ****    */
5181:Core/Inc/arm_math.h **** 
5182:Core/Inc/arm_math.h ****   /**
5183:Core/Inc/arm_math.h ****    * @brief Floating-point Park transform
5184:Core/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5185:Core/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5186:Core/Inc/arm_math.h ****    * @param[out] pId     points to output   rotor reference frame d
5187:Core/Inc/arm_math.h ****    * @param[out] pIq     points to output   rotor reference frame q
5188:Core/Inc/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5189:Core/Inc/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5190:Core/Inc/arm_math.h ****    *
5191:Core/Inc/arm_math.h ****    * The function implements the forward Park transform.
5192:Core/Inc/arm_math.h ****    *
5193:Core/Inc/arm_math.h ****    */
5194:Core/Inc/arm_math.h ****   static __INLINE void arm_park_f32(
5195:Core/Inc/arm_math.h ****   float32_t Ialpha,
5196:Core/Inc/arm_math.h ****   float32_t Ibeta,
5197:Core/Inc/arm_math.h ****   float32_t * pId,
5198:Core/Inc/arm_math.h ****   float32_t * pIq,
5199:Core/Inc/arm_math.h ****   float32_t sinVal,
5200:Core/Inc/arm_math.h ****   float32_t cosVal)
5201:Core/Inc/arm_math.h ****   {
5202:Core/Inc/arm_math.h ****     /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
5203:Core/Inc/arm_math.h ****     *pId = Ialpha * cosVal + Ibeta * sinVal;
5204:Core/Inc/arm_math.h **** 
5205:Core/Inc/arm_math.h ****     /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
5206:Core/Inc/arm_math.h ****     *pIq = -Ialpha * sinVal + Ibeta * cosVal;
5207:Core/Inc/arm_math.h ****   }
5208:Core/Inc/arm_math.h **** 
5209:Core/Inc/arm_math.h **** 
5210:Core/Inc/arm_math.h ****   /**
5211:Core/Inc/arm_math.h ****    * @brief  Park transform for Q31 version
5212:Core/Inc/arm_math.h ****    * @param[in]  Ialpha  input two-phase vector coordinate alpha
5213:Core/Inc/arm_math.h ****    * @param[in]  Ibeta   input two-phase vector coordinate beta
5214:Core/Inc/arm_math.h ****    * @param[out] pId     points to output rotor reference frame d
5215:Core/Inc/arm_math.h ****    * @param[out] pIq     points to output rotor reference frame q
5216:Core/Inc/arm_math.h ****    * @param[in]  sinVal  sine value of rotation angle theta
5217:Core/Inc/arm_math.h ****    * @param[in]  cosVal  cosine value of rotation angle theta
5218:Core/Inc/arm_math.h ****    *
5219:Core/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5220:Core/Inc/arm_math.h ****    * \par
5221:Core/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5222:Core/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5223:Core/Inc/arm_math.h ****    * There is saturation on the addition and subtraction, hence there is no risk of overflow.
5224:Core/Inc/arm_math.h ****    */
5225:Core/Inc/arm_math.h ****   static __INLINE void arm_park_q31(
5226:Core/Inc/arm_math.h ****   q31_t Ialpha,
ARM GAS  /tmp/ccpEjOub.s 			page 98


5227:Core/Inc/arm_math.h ****   q31_t Ibeta,
5228:Core/Inc/arm_math.h ****   q31_t * pId,
5229:Core/Inc/arm_math.h ****   q31_t * pIq,
5230:Core/Inc/arm_math.h ****   q31_t sinVal,
5231:Core/Inc/arm_math.h ****   q31_t cosVal)
5232:Core/Inc/arm_math.h ****   {
 313              		.loc 1 5232 3
 314              		.cfi_startproc
 315              		@ args = 8, pretend = 0, frame = 32
 316              		@ frame_needed = 1, uses_anonymous_args = 0
 317 0000 B0B5     		push	{r4, r5, r7, lr}
 318              	.LCFI21:
 319              		.cfi_def_cfa_offset 16
 320              		.cfi_offset 4, -16
 321              		.cfi_offset 5, -12
 322              		.cfi_offset 7, -8
 323              		.cfi_offset 14, -4
 324 0002 88B0     		sub	sp, sp, #32
 325              	.LCFI22:
 326              		.cfi_def_cfa_offset 48
 327 0004 00AF     		add	r7, sp, #0
 328              	.LCFI23:
 329              		.cfi_def_cfa_register 7
 330 0006 F860     		str	r0, [r7, #12]
 331 0008 B960     		str	r1, [r7, #8]
 332 000a 7A60     		str	r2, [r7, #4]
 333 000c 3B60     		str	r3, [r7]
5233:Core/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5234:Core/Inc/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5235:Core/Inc/arm_math.h **** 
5236:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * cosVal) */
5237:Core/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
 334              		.loc 1 5237 26
 335 000e FB68     		ldr	r3, [r7, #12]
 336 0010 1846     		mov	r0, r3
 337 0012 4FEAE071 		asr	r1, r0, #31
 338              		.loc 1 5237 43
 339 0016 7B6B     		ldr	r3, [r7, #52]
 340 0018 1A46     		mov	r2, r3
 341 001a 4FEAE273 		asr	r3, r2, #31
 342 001e 02FB01F5 		mul	r5, r2, r1
 343 0022 00FB03F4 		mul	r4, r0, r3
 344 0026 2C44     		add	r4, r4, r5
 345 0028 A0FB0223 		umull	r2, r3, r0, r2
 346 002c E118     		adds	r1, r4, r3
 347 002e 0B46     		mov	r3, r1
 348              		.loc 1 5237 55
 349 0030 4FF00000 		mov	r0, #0
 350 0034 4FF00001 		mov	r1, #0
 351 0038 D00F     		lsrs	r0, r2, #31
 352 003a 40EA4300 		orr	r0, r0, r3, lsl #1
 353 003e D917     		asrs	r1, r3, #31
 354              		.loc 1 5237 14
 355 0040 0346     		mov	r3, r0
 356 0042 FB61     		str	r3, [r7, #28]
5238:Core/Inc/arm_math.h **** 
5239:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * sinVal) */
ARM GAS  /tmp/ccpEjOub.s 			page 99


5240:Core/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
 357              		.loc 1 5240 26
 358 0044 BB68     		ldr	r3, [r7, #8]
 359 0046 1846     		mov	r0, r3
 360 0048 4FEAE071 		asr	r1, r0, #31
 361              		.loc 1 5240 42
 362 004c 3B6B     		ldr	r3, [r7, #48]
 363 004e 1A46     		mov	r2, r3
 364 0050 4FEAE273 		asr	r3, r2, #31
 365 0054 02FB01F5 		mul	r5, r2, r1
 366 0058 00FB03F4 		mul	r4, r0, r3
 367 005c 2C44     		add	r4, r4, r5
 368 005e A0FB0223 		umull	r2, r3, r0, r2
 369 0062 E118     		adds	r1, r4, r3
 370 0064 0B46     		mov	r3, r1
 371              		.loc 1 5240 54
 372 0066 4FF00000 		mov	r0, #0
 373 006a 4FF00001 		mov	r1, #0
 374 006e D00F     		lsrs	r0, r2, #31
 375 0070 40EA4300 		orr	r0, r0, r3, lsl #1
 376 0074 D917     		asrs	r1, r3, #31
 377              		.loc 1 5240 14
 378 0076 0346     		mov	r3, r0
 379 0078 BB61     		str	r3, [r7, #24]
5241:Core/Inc/arm_math.h **** 
5242:Core/Inc/arm_math.h **** 
5243:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ialpha * sinVal) */
5244:Core/Inc/arm_math.h ****     product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
 380              		.loc 1 5244 26
 381 007a FB68     		ldr	r3, [r7, #12]
 382 007c 1846     		mov	r0, r3
 383 007e 4FEAE071 		asr	r1, r0, #31
 384              		.loc 1 5244 43
 385 0082 3B6B     		ldr	r3, [r7, #48]
 386 0084 1A46     		mov	r2, r3
 387 0086 4FEAE273 		asr	r3, r2, #31
 388 008a 02FB01F5 		mul	r5, r2, r1
 389 008e 00FB03F4 		mul	r4, r0, r3
 390 0092 2C44     		add	r4, r4, r5
 391 0094 A0FB0223 		umull	r2, r3, r0, r2
 392 0098 E118     		adds	r1, r4, r3
 393 009a 0B46     		mov	r3, r1
 394              		.loc 1 5244 55
 395 009c 4FF00000 		mov	r0, #0
 396 00a0 4FF00001 		mov	r1, #0
 397 00a4 D00F     		lsrs	r0, r2, #31
 398 00a6 40EA4300 		orr	r0, r0, r3, lsl #1
 399 00aa D917     		asrs	r1, r3, #31
 400              		.loc 1 5244 14
 401 00ac 0346     		mov	r3, r0
 402 00ae 7B61     		str	r3, [r7, #20]
5245:Core/Inc/arm_math.h **** 
5246:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Ibeta * cosVal) */
5247:Core/Inc/arm_math.h ****     product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
 403              		.loc 1 5247 26
 404 00b0 BB68     		ldr	r3, [r7, #8]
 405 00b2 1846     		mov	r0, r3
ARM GAS  /tmp/ccpEjOub.s 			page 100


 406 00b4 4FEAE071 		asr	r1, r0, #31
 407              		.loc 1 5247 42
 408 00b8 7B6B     		ldr	r3, [r7, #52]
 409 00ba 1A46     		mov	r2, r3
 410 00bc 4FEAE273 		asr	r3, r2, #31
 411 00c0 02FB01F5 		mul	r5, r2, r1
 412 00c4 00FB03F4 		mul	r4, r0, r3
 413 00c8 2C44     		add	r4, r4, r5
 414 00ca A0FB0223 		umull	r2, r3, r0, r2
 415 00ce E118     		adds	r1, r4, r3
 416 00d0 0B46     		mov	r3, r1
 417              		.loc 1 5247 54
 418 00d2 4FF00000 		mov	r0, #0
 419 00d6 4FF00001 		mov	r1, #0
 420 00da D00F     		lsrs	r0, r2, #31
 421 00dc 40EA4300 		orr	r0, r0, r3, lsl #1
 422 00e0 D917     		asrs	r1, r3, #31
 423              		.loc 1 5247 14
 424 00e2 0346     		mov	r3, r0
 425 00e4 3B61     		str	r3, [r7, #16]
5248:Core/Inc/arm_math.h **** 
5249:Core/Inc/arm_math.h ****     /* Calculate pId by adding the two intermediate products 1 and 2 */
5250:Core/Inc/arm_math.h ****     *pId = __QADD(product1, product2);
 426              		.loc 1 5250 12
 427 00e6 B969     		ldr	r1, [r7, #24]
 428 00e8 F869     		ldr	r0, [r7, #28]
 429 00ea FFF7FEFF 		bl	__QADD
 430 00ee 0246     		mov	r2, r0
 431              		.loc 1 5250 10
 432 00f0 7B68     		ldr	r3, [r7, #4]
 433 00f2 1A60     		str	r2, [r3]
5251:Core/Inc/arm_math.h **** 
5252:Core/Inc/arm_math.h ****     /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
5253:Core/Inc/arm_math.h ****     *pIq = __QSUB(product4, product3);
 434              		.loc 1 5253 12
 435 00f4 7969     		ldr	r1, [r7, #20]
 436 00f6 3869     		ldr	r0, [r7, #16]
 437 00f8 FFF7FEFF 		bl	__QSUB
 438 00fc 0246     		mov	r2, r0
 439              		.loc 1 5253 10
 440 00fe 3B68     		ldr	r3, [r7]
 441 0100 1A60     		str	r2, [r3]
5254:Core/Inc/arm_math.h ****   }
 442              		.loc 1 5254 3
 443 0102 00BF     		nop
 444 0104 2037     		adds	r7, r7, #32
 445              	.LCFI24:
 446              		.cfi_def_cfa_offset 16
 447 0106 BD46     		mov	sp, r7
 448              	.LCFI25:
 449              		.cfi_def_cfa_register 13
 450              		@ sp needed
 451 0108 B0BD     		pop	{r4, r5, r7, pc}
 452              		.cfi_endproc
 453              	.LFE81:
 455              		.section	.text.arm_inv_park_q31,"ax",%progbits
 456              		.align	1
ARM GAS  /tmp/ccpEjOub.s 			page 101


 457              		.syntax unified
 458              		.thumb
 459              		.thumb_func
 460              		.fpu softvfp
 462              	arm_inv_park_q31:
 463              	.LFB83:
5255:Core/Inc/arm_math.h **** 
5256:Core/Inc/arm_math.h ****   /**
5257:Core/Inc/arm_math.h ****    * @} end of park group
5258:Core/Inc/arm_math.h ****    */
5259:Core/Inc/arm_math.h **** 
5260:Core/Inc/arm_math.h ****   /**
5261:Core/Inc/arm_math.h ****    * @brief  Converts the elements of the Q7 vector to floating-point vector.
5262:Core/Inc/arm_math.h ****    * @param[in]  pSrc       is input pointer
5263:Core/Inc/arm_math.h ****    * @param[out] pDst       is output pointer
5264:Core/Inc/arm_math.h ****    * @param[in]  blockSize  is the number of samples to process
5265:Core/Inc/arm_math.h ****    */
5266:Core/Inc/arm_math.h ****   void arm_q7_to_float(
5267:Core/Inc/arm_math.h ****   q7_t * pSrc,
5268:Core/Inc/arm_math.h ****   float32_t * pDst,
5269:Core/Inc/arm_math.h ****   uint32_t blockSize);
5270:Core/Inc/arm_math.h **** 
5271:Core/Inc/arm_math.h **** 
5272:Core/Inc/arm_math.h ****   /**
5273:Core/Inc/arm_math.h ****    * @ingroup groupController
5274:Core/Inc/arm_math.h ****    */
5275:Core/Inc/arm_math.h **** 
5276:Core/Inc/arm_math.h ****   /**
5277:Core/Inc/arm_math.h ****    * @defgroup inv_park Vector Inverse Park transform
5278:Core/Inc/arm_math.h ****    * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
5279:Core/Inc/arm_math.h ****    *
5280:Core/Inc/arm_math.h ****    * The function operates on a single sample of data and each call to the function returns the pro
5281:Core/Inc/arm_math.h ****    * The library provides separate functions for Q31 and floating-point data types.
5282:Core/Inc/arm_math.h ****    * \par Algorithm
5283:Core/Inc/arm_math.h ****    * \image html parkInvFormula.gif
5284:Core/Inc/arm_math.h ****    * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
5285:Core/Inc/arm_math.h ****    * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <c
5286:Core/Inc/arm_math.h ****    * cosine and sine values of theta (rotor flux position).
5287:Core/Inc/arm_math.h ****    * \par Fixed-Point Behavior
5288:Core/Inc/arm_math.h ****    * Care must be taken when using the Q31 version of the Park transform.
5289:Core/Inc/arm_math.h ****    * In particular, the overflow and saturation behavior of the accumulator used must be considered
5290:Core/Inc/arm_math.h ****    * Refer to the function specific documentation below for usage guidelines.
5291:Core/Inc/arm_math.h ****    */
5292:Core/Inc/arm_math.h **** 
5293:Core/Inc/arm_math.h ****   /**
5294:Core/Inc/arm_math.h ****    * @addtogroup inv_park
5295:Core/Inc/arm_math.h ****    * @{
5296:Core/Inc/arm_math.h ****    */
5297:Core/Inc/arm_math.h **** 
5298:Core/Inc/arm_math.h ****    /**
5299:Core/Inc/arm_math.h ****    * @brief  Floating-point Inverse Park transform
5300:Core/Inc/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5301:Core/Inc/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5302:Core/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5303:Core/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5304:Core/Inc/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5305:Core/Inc/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
ARM GAS  /tmp/ccpEjOub.s 			page 102


5306:Core/Inc/arm_math.h ****    */
5307:Core/Inc/arm_math.h ****   static __INLINE void arm_inv_park_f32(
5308:Core/Inc/arm_math.h ****   float32_t Id,
5309:Core/Inc/arm_math.h ****   float32_t Iq,
5310:Core/Inc/arm_math.h ****   float32_t * pIalpha,
5311:Core/Inc/arm_math.h ****   float32_t * pIbeta,
5312:Core/Inc/arm_math.h ****   float32_t sinVal,
5313:Core/Inc/arm_math.h ****   float32_t cosVal)
5314:Core/Inc/arm_math.h ****   {
5315:Core/Inc/arm_math.h ****     /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
5316:Core/Inc/arm_math.h ****     *pIalpha = Id * cosVal - Iq * sinVal;
5317:Core/Inc/arm_math.h **** 
5318:Core/Inc/arm_math.h ****     /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
5319:Core/Inc/arm_math.h ****     *pIbeta = Id * sinVal + Iq * cosVal;
5320:Core/Inc/arm_math.h ****   }
5321:Core/Inc/arm_math.h **** 
5322:Core/Inc/arm_math.h **** 
5323:Core/Inc/arm_math.h ****   /**
5324:Core/Inc/arm_math.h ****    * @brief  Inverse Park transform for   Q31 version
5325:Core/Inc/arm_math.h ****    * @param[in]  Id       input coordinate of rotor reference frame d
5326:Core/Inc/arm_math.h ****    * @param[in]  Iq       input coordinate of rotor reference frame q
5327:Core/Inc/arm_math.h ****    * @param[out] pIalpha  points to output two-phase orthogonal vector axis alpha
5328:Core/Inc/arm_math.h ****    * @param[out] pIbeta   points to output two-phase orthogonal vector axis beta
5329:Core/Inc/arm_math.h ****    * @param[in]  sinVal   sine value of rotation angle theta
5330:Core/Inc/arm_math.h ****    * @param[in]  cosVal   cosine value of rotation angle theta
5331:Core/Inc/arm_math.h ****    *
5332:Core/Inc/arm_math.h ****    * <b>Scaling and Overflow Behavior:</b>
5333:Core/Inc/arm_math.h ****    * \par
5334:Core/Inc/arm_math.h ****    * The function is implemented using an internal 32-bit accumulator.
5335:Core/Inc/arm_math.h ****    * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multipli
5336:Core/Inc/arm_math.h ****    * There is saturation on the addition, hence there is no risk of overflow.
5337:Core/Inc/arm_math.h ****    */
5338:Core/Inc/arm_math.h ****   static __INLINE void arm_inv_park_q31(
5339:Core/Inc/arm_math.h ****   q31_t Id,
5340:Core/Inc/arm_math.h ****   q31_t Iq,
5341:Core/Inc/arm_math.h ****   q31_t * pIalpha,
5342:Core/Inc/arm_math.h ****   q31_t * pIbeta,
5343:Core/Inc/arm_math.h ****   q31_t sinVal,
5344:Core/Inc/arm_math.h ****   q31_t cosVal)
5345:Core/Inc/arm_math.h ****   {
 464              		.loc 1 5345 3
 465              		.cfi_startproc
 466              		@ args = 8, pretend = 0, frame = 32
 467              		@ frame_needed = 1, uses_anonymous_args = 0
 468 0000 B0B5     		push	{r4, r5, r7, lr}
 469              	.LCFI26:
 470              		.cfi_def_cfa_offset 16
 471              		.cfi_offset 4, -16
 472              		.cfi_offset 5, -12
 473              		.cfi_offset 7, -8
 474              		.cfi_offset 14, -4
 475 0002 88B0     		sub	sp, sp, #32
 476              	.LCFI27:
 477              		.cfi_def_cfa_offset 48
 478 0004 00AF     		add	r7, sp, #0
 479              	.LCFI28:
 480              		.cfi_def_cfa_register 7
ARM GAS  /tmp/ccpEjOub.s 			page 103


 481 0006 F860     		str	r0, [r7, #12]
 482 0008 B960     		str	r1, [r7, #8]
 483 000a 7A60     		str	r2, [r7, #4]
 484 000c 3B60     		str	r3, [r7]
5346:Core/Inc/arm_math.h ****     q31_t product1, product2;                    /* Temporary variables used to store intermediate 
5347:Core/Inc/arm_math.h ****     q31_t product3, product4;                    /* Temporary variables used to store intermediate 
5348:Core/Inc/arm_math.h **** 
5349:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Id * cosVal) */
5350:Core/Inc/arm_math.h ****     product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
 485              		.loc 1 5350 26
 486 000e FB68     		ldr	r3, [r7, #12]
 487 0010 1846     		mov	r0, r3
 488 0012 4FEAE071 		asr	r1, r0, #31
 489              		.loc 1 5350 39
 490 0016 7B6B     		ldr	r3, [r7, #52]
 491 0018 1A46     		mov	r2, r3
 492 001a 4FEAE273 		asr	r3, r2, #31
 493 001e 02FB01F5 		mul	r5, r2, r1
 494 0022 00FB03F4 		mul	r4, r0, r3
 495 0026 2C44     		add	r4, r4, r5
 496 0028 A0FB0223 		umull	r2, r3, r0, r2
 497 002c E118     		adds	r1, r4, r3
 498 002e 0B46     		mov	r3, r1
 499              		.loc 1 5350 51
 500 0030 4FF00000 		mov	r0, #0
 501 0034 4FF00001 		mov	r1, #0
 502 0038 D00F     		lsrs	r0, r2, #31
 503 003a 40EA4300 		orr	r0, r0, r3, lsl #1
 504 003e D917     		asrs	r1, r3, #31
 505              		.loc 1 5350 14
 506 0040 0346     		mov	r3, r0
 507 0042 FB61     		str	r3, [r7, #28]
5351:Core/Inc/arm_math.h **** 
5352:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Iq * sinVal) */
5353:Core/Inc/arm_math.h ****     product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
 508              		.loc 1 5353 26
 509 0044 BB68     		ldr	r3, [r7, #8]
 510 0046 1846     		mov	r0, r3
 511 0048 4FEAE071 		asr	r1, r0, #31
 512              		.loc 1 5353 39
 513 004c 3B6B     		ldr	r3, [r7, #48]
 514 004e 1A46     		mov	r2, r3
 515 0050 4FEAE273 		asr	r3, r2, #31
 516 0054 02FB01F5 		mul	r5, r2, r1
 517 0058 00FB03F4 		mul	r4, r0, r3
 518 005c 2C44     		add	r4, r4, r5
 519 005e A0FB0223 		umull	r2, r3, r0, r2
 520 0062 E118     		adds	r1, r4, r3
 521 0064 0B46     		mov	r3, r1
 522              		.loc 1 5353 51
 523 0066 4FF00000 		mov	r0, #0
 524 006a 4FF00001 		mov	r1, #0
 525 006e D00F     		lsrs	r0, r2, #31
 526 0070 40EA4300 		orr	r0, r0, r3, lsl #1
 527 0074 D917     		asrs	r1, r3, #31
 528              		.loc 1 5353 14
 529 0076 0346     		mov	r3, r0
ARM GAS  /tmp/ccpEjOub.s 			page 104


 530 0078 BB61     		str	r3, [r7, #24]
5354:Core/Inc/arm_math.h **** 
5355:Core/Inc/arm_math.h **** 
5356:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Id * sinVal) */
5357:Core/Inc/arm_math.h ****     product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
 531              		.loc 1 5357 26
 532 007a FB68     		ldr	r3, [r7, #12]
 533 007c 1846     		mov	r0, r3
 534 007e 4FEAE071 		asr	r1, r0, #31
 535              		.loc 1 5357 39
 536 0082 3B6B     		ldr	r3, [r7, #48]
 537 0084 1A46     		mov	r2, r3
 538 0086 4FEAE273 		asr	r3, r2, #31
 539 008a 02FB01F5 		mul	r5, r2, r1
 540 008e 00FB03F4 		mul	r4, r0, r3
 541 0092 2C44     		add	r4, r4, r5
 542 0094 A0FB0223 		umull	r2, r3, r0, r2
 543 0098 E118     		adds	r1, r4, r3
 544 009a 0B46     		mov	r3, r1
 545              		.loc 1 5357 51
 546 009c 4FF00000 		mov	r0, #0
 547 00a0 4FF00001 		mov	r1, #0
 548 00a4 D00F     		lsrs	r0, r2, #31
 549 00a6 40EA4300 		orr	r0, r0, r3, lsl #1
 550 00aa D917     		asrs	r1, r3, #31
 551              		.loc 1 5357 14
 552 00ac 0346     		mov	r3, r0
 553 00ae 7B61     		str	r3, [r7, #20]
5358:Core/Inc/arm_math.h **** 
5359:Core/Inc/arm_math.h ****     /* Intermediate product is calculated by (Iq * cosVal) */
5360:Core/Inc/arm_math.h ****     product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
 554              		.loc 1 5360 26
 555 00b0 BB68     		ldr	r3, [r7, #8]
 556 00b2 1846     		mov	r0, r3
 557 00b4 4FEAE071 		asr	r1, r0, #31
 558              		.loc 1 5360 39
 559 00b8 7B6B     		ldr	r3, [r7, #52]
 560 00ba 1A46     		mov	r2, r3
 561 00bc 4FEAE273 		asr	r3, r2, #31
 562 00c0 02FB01F5 		mul	r5, r2, r1
 563 00c4 00FB03F4 		mul	r4, r0, r3
 564 00c8 2C44     		add	r4, r4, r5
 565 00ca A0FB0223 		umull	r2, r3, r0, r2
 566 00ce E118     		adds	r1, r4, r3
 567 00d0 0B46     		mov	r3, r1
 568              		.loc 1 5360 51
 569 00d2 4FF00000 		mov	r0, #0
 570 00d6 4FF00001 		mov	r1, #0
 571 00da D00F     		lsrs	r0, r2, #31
 572 00dc 40EA4300 		orr	r0, r0, r3, lsl #1
 573 00e0 D917     		asrs	r1, r3, #31
 574              		.loc 1 5360 14
 575 00e2 0346     		mov	r3, r0
 576 00e4 3B61     		str	r3, [r7, #16]
5361:Core/Inc/arm_math.h **** 
5362:Core/Inc/arm_math.h ****     /* Calculate pIalpha by using the two intermediate products 1 and 2 */
5363:Core/Inc/arm_math.h ****     *pIalpha = __QSUB(product1, product2);
ARM GAS  /tmp/ccpEjOub.s 			page 105


 577              		.loc 1 5363 16
 578 00e6 B969     		ldr	r1, [r7, #24]
 579 00e8 F869     		ldr	r0, [r7, #28]
 580 00ea FFF7FEFF 		bl	__QSUB
 581 00ee 0246     		mov	r2, r0
 582              		.loc 1 5363 14
 583 00f0 7B68     		ldr	r3, [r7, #4]
 584 00f2 1A60     		str	r2, [r3]
5364:Core/Inc/arm_math.h **** 
5365:Core/Inc/arm_math.h ****     /* Calculate pIbeta by using the two intermediate products 3 and 4 */
5366:Core/Inc/arm_math.h ****     *pIbeta = __QADD(product4, product3);
 585              		.loc 1 5366 15
 586 00f4 7969     		ldr	r1, [r7, #20]
 587 00f6 3869     		ldr	r0, [r7, #16]
 588 00f8 FFF7FEFF 		bl	__QADD
 589 00fc 0246     		mov	r2, r0
 590              		.loc 1 5366 13
 591 00fe 3B68     		ldr	r3, [r7]
 592 0100 1A60     		str	r2, [r3]
5367:Core/Inc/arm_math.h ****   }
 593              		.loc 1 5367 3
 594 0102 00BF     		nop
 595 0104 2037     		adds	r7, r7, #32
 596              	.LCFI29:
 597              		.cfi_def_cfa_offset 16
 598 0106 BD46     		mov	sp, r7
 599              	.LCFI30:
 600              		.cfi_def_cfa_register 13
 601              		@ sp needed
 602 0108 B0BD     		pop	{r4, r5, r7, pc}
 603              		.cfi_endproc
 604              	.LFE83:
 606              		.global	VirtAddVarTab
 607              		.section	.data.VirtAddVarTab,"aw"
 608              		.align	2
 611              	VirtAddVarTab:
 612 0000 0100     		.short	1
 613 0002 0200     		.short	2
 614 0004 0300     		.short	3
 615 0006 00000000 		.space	10
 615      00000000 
 615      0000
 616              		.comm	hadc1,48,4
 617              		.comm	hadc2,48,4
 618              		.comm	hdma_adc1,68,4
 619              		.comm	htim1,72,4
 620              		.comm	htim2,72,4
 621              		.comm	htim3,72,4
 622              		.comm	htim4,72,4
 623              		.comm	adcData1,48,4
 624              		.comm	MS,56,4
 625              		.global	i16_ph1_current
 626              		.section	.bss.i16_ph1_current,"aw",%nobits
 627              		.align	1
 630              	i16_ph1_current:
 631 0000 0000     		.space	2
 632              		.global	i16_ph2_current
ARM GAS  /tmp/ccpEjOub.s 			page 106


 633              		.section	.bss.i16_ph2_current,"aw",%nobits
 634              		.align	1
 637              	i16_ph2_current:
 638 0000 0000     		.space	2
 639              		.global	i16_ph2_current_filter
 640              		.section	.bss.i16_ph2_current_filter,"aw",%nobits
 641              		.align	1
 644              	i16_ph2_current_filter:
 645 0000 0000     		.space	2
 646              		.global	ui8_adc_inj_flag
 647              		.section	.bss.ui8_adc_inj_flag,"aw",%nobits
 650              	ui8_adc_inj_flag:
 651 0000 00       		.space	1
 652              		.comm	raw_inj1,4,4
 653              		.comm	raw_inj2,4,4
 654              		.global	ui8_hall_state
 655              		.section	.bss.ui8_hall_state,"aw",%nobits
 658              	ui8_hall_state:
 659 0000 00       		.space	1
 660              		.global	ui8_hall_state_old
 661              		.section	.bss.ui8_hall_state_old,"aw",%nobits
 664              	ui8_hall_state_old:
 665 0000 00       		.space	1
 666              		.global	ui8_hall_case
 667              		.section	.bss.ui8_hall_case,"aw",%nobits
 670              	ui8_hall_case:
 671 0000 00       		.space	1
 672              		.global	ui8_BC_limit_flag
 673              		.section	.bss.ui8_BC_limit_flag,"aw",%nobits
 676              	ui8_BC_limit_flag:
 677 0000 00       		.space	1
 678              		.comm	ui16_halls_tim2tics,2,2
 679              		.global	ui16_halls_tim2tics_filtered
 680              		.section	.data.ui16_halls_tim2tics_filtered,"aw"
 681              		.align	1
 684              	ui16_halls_tim2tics_filtered:
 685 0000 8813     		.short	5000
 686              		.global	ui8_6step_flag
 687              		.section	.bss.ui8_6step_flag,"aw",%nobits
 690              	ui8_6step_flag:
 691 0000 00       		.space	1
 692              		.comm	q31_rotorposition_absolute,4,4
 693              		.comm	q31_rotorposition_hall,4,4
 694              		.global	q31_rotorposition_motor_specific
 695              		.section	.data.q31_rotorposition_motor_specific,"aw"
 696              		.align	2
 699              	q31_rotorposition_motor_specific:
 700 0000 1A610BF6 		.word	-167026406
 701              		.global	q31_rotorposition_PLL
 702              		.section	.bss.q31_rotorposition_PLL,"aw",%nobits
 703              		.align	2
 706              	q31_rotorposition_PLL:
 707 0000 00000000 		.space	4
 708              		.global	q31_angle_per_tic
 709              		.section	.bss.q31_angle_per_tic,"aw",%nobits
 710              		.align	2
 713              	q31_angle_per_tic:
ARM GAS  /tmp/ccpEjOub.s 			page 107


 714 0000 00000000 		.space	4
 715              		.global	q31_PLL_error
 716              		.section	.bss.q31_PLL_error,"aw",%nobits
 717              		.align	2
 720              	q31_PLL_error:
 721 0000 00000000 		.space	4
 722              		.global	i8_recent_rotor_direction
 723              		.section	.data.i8_recent_rotor_direction,"aw"
 726              	i8_recent_rotor_direction:
 727 0000 01       		.byte	1
 728              		.global	i16_hall_order
 729              		.section	.data.i16_hall_order,"aw"
 730              		.align	1
 733              	i16_hall_order:
 734 0000 0100     		.short	1
 735              		.global	Hall_13
 736              		.section	.bss.Hall_13,"aw",%nobits
 737              		.align	2
 740              	Hall_13:
 741 0000 00000000 		.space	4
 742              		.global	Hall_32
 743              		.section	.bss.Hall_32,"aw",%nobits
 744              		.align	2
 747              	Hall_32:
 748 0000 00000000 		.space	4
 749              		.global	Hall_26
 750              		.section	.bss.Hall_26,"aw",%nobits
 751              		.align	2
 754              	Hall_26:
 755 0000 00000000 		.space	4
 756              		.global	Hall_64
 757              		.section	.bss.Hall_64,"aw",%nobits
 758              		.align	2
 761              	Hall_64:
 762 0000 00000000 		.space	4
 763              		.global	Hall_51
 764              		.section	.bss.Hall_51,"aw",%nobits
 765              		.align	2
 768              	Hall_51:
 769 0000 00000000 		.space	4
 770              		.global	Hall_45
 771              		.section	.bss.Hall_45,"aw",%nobits
 772              		.align	2
 775              	Hall_45:
 776 0000 00000000 		.space	4
 777              		.global	deg_30
 778              		.section	.rodata.deg_30,"a"
 779              		.align	2
 782              	deg_30:
 783 0000 55555515 		.word	357913941
 784              		.comm	switchtime,12,4
 785              		.global	ui8_overflow_flag
 786              		.section	.bss.ui8_overflow_flag,"aw",%nobits
 789              	ui8_overflow_flag:
 790 0000 00       		.space	1
 791              		.global	char_dyn_adc_state_old
 792              		.section	.data.char_dyn_adc_state_old,"aw"
ARM GAS  /tmp/ccpEjOub.s 			page 108


 795              	char_dyn_adc_state_old:
 796 0000 01       		.byte	1
 797              		.global	q31_tics_filtered
 798              		.section	.data.q31_tics_filtered,"aw"
 799              		.align	2
 802              	q31_tics_filtered:
 803 0000 00F40100 		.word	128000
 804              		.global	q31_t_Battery_Current_accumulated
 805              		.section	.bss.q31_t_Battery_Current_accumulated,"aw",%nobits
 806              		.align	2
 809              	q31_t_Battery_Current_accumulated:
 810 0000 00000000 		.space	4
 811              		.global	i8_direction
 812              		.section	.data.i8_direction,"aw"
 815              	i8_direction:
 816 0000 01       		.byte	1
 817              		.global	i8_reverse_flag
 818              		.section	.data.i8_reverse_flag,"aw"
 821              	i8_reverse_flag:
 822 0000 01       		.byte	1
 823              		.global	q31_u_d_temp
 824              		.section	.bss.q31_u_d_temp,"aw",%nobits
 825              		.align	2
 828              	q31_u_d_temp:
 829 0000 00000000 		.space	4
 830              		.global	q31_u_q_temp
 831              		.section	.bss.q31_u_q_temp,"aw",%nobits
 832              		.align	2
 835              	q31_u_q_temp:
 836 0000 00000000 		.space	4
 837              		.global	i16_sinus
 838              		.section	.bss.i16_sinus,"aw",%nobits
 839              		.align	1
 842              	i16_sinus:
 843 0000 0000     		.space	2
 844              		.global	i16_cosinus
 845              		.section	.bss.i16_cosinus,"aw",%nobits
 846              		.align	1
 849              	i16_cosinus:
 850 0000 0000     		.space	2
 851              		.global	uint16_half_rotation_counter
 852              		.section	.bss.uint16_half_rotation_counter,"aw",%nobits
 853              		.align	1
 856              	uint16_half_rotation_counter:
 857 0000 0000     		.space	2
 858              		.global	uint16_full_rotation_counter
 859              		.section	.bss.uint16_full_rotation_counter,"aw",%nobits
 860              		.align	1
 863              	uint16_full_rotation_counter:
 864 0000 0000     		.space	2
 865              		.section	.bss.tics_lower_limit,"aw",%nobits
 866              		.align	2
 869              	tics_lower_limit:
 870 0000 00000000 		.space	4
 871              		.section	.bss.tics_higher_limit,"aw",%nobits
 872              		.align	2
 875              	tics_higher_limit:
ARM GAS  /tmp/ccpEjOub.s 			page 109


 876 0000 00000000 		.space	4
 877              		.global	DEG_0
 878              		.section	.rodata.DEG_0,"a"
 879              		.align	2
 882              	DEG_0:
 883 0000 00000000 		.space	4
 884              		.global	DEG_plus60
 885              		.section	.rodata.DEG_plus60,"a"
 886              		.align	2
 889              	DEG_plus60:
 890 0000 ABAAAA2A 		.word	715827883
 891              		.global	DEG_plus120
 892              		.section	.rodata.DEG_plus120,"a"
 893              		.align	2
 896              	DEG_plus120:
 897 0000 55555555 		.word	1431655765
 898              		.global	DEG_plus180
 899              		.section	.rodata.DEG_plus180,"a"
 900              		.align	2
 903              	DEG_plus180:
 904 0000 FFFFFF7F 		.word	2147483647
 905              		.global	DEG_minus60
 906              		.section	.rodata.DEG_minus60,"a"
 907              		.align	2
 910              	DEG_minus60:
 911 0000 555555D5 		.word	-715827883
 912              		.global	DEG_minus120
 913              		.section	.rodata.DEG_minus120,"a"
 914              		.align	2
 917              	DEG_minus120:
 918 0000 ABAAAAAA 		.word	-1431655765
 919              		.comm	ui16_reg_adc_value,2,2
 920              		.comm	ui32_reg_adc_value_filter,4,4
 921              		.global	ui8_adc_regular_flag
 922              		.section	.bss.ui8_adc_regular_flag,"aw",%nobits
 925              	ui8_adc_regular_flag:
 926 0000 00       		.space	1
 927              		.global	ui16_ph1_offset
 928              		.section	.bss.ui16_ph1_offset,"aw",%nobits
 929              		.align	1
 932              	ui16_ph1_offset:
 933 0000 0000     		.space	2
 934              		.global	ui16_ph2_offset
 935              		.section	.bss.ui16_ph2_offset,"aw",%nobits
 936              		.align	1
 939              	ui16_ph2_offset:
 940 0000 0000     		.space	2
 941              		.global	ui16_ph3_offset
 942              		.section	.bss.ui16_ph3_offset,"aw",%nobits
 943              		.align	1
 946              	ui16_ph3_offset:
 947 0000 0000     		.space	2
 948              		.global	ui16_KV_detect_counter
 949              		.section	.bss.ui16_KV_detect_counter,"aw",%nobits
 950              		.align	1
 953              	ui16_KV_detect_counter:
 954 0000 0000     		.space	2
ARM GAS  /tmp/ccpEjOub.s 			page 110


 955              		.section	.bss.ui32_KV,"aw",%nobits
 956              		.align	1
 959              	ui32_KV:
 960 0000 0000     		.space	2
 961              		.global	uint32_SPEEDx100_cumulated
 962              		.section	.bss.uint32_SPEEDx100_cumulated,"aw",%nobits
 963              		.align	2
 966              	uint32_SPEEDx100_cumulated:
 967 0000 00000000 		.space	4
 968              		.comm	PI_iq,32,4
 969              		.comm	PI_id,32,4
 970              		.comm	iq_filtered,4,4
 971              		.comm	id_filtered,4,4
 972              		.comm	uq_filtered,4,4
 973              		.comm	ud_filtered,4,4
 974              		.global	q31_i_q_fil
 975              		.section	.bss.q31_i_q_fil,"aw",%nobits
 976              		.align	2
 979              	q31_i_q_fil:
 980 0000 00000000 		.space	4
 981              		.global	q31_i_d_fil
 982              		.section	.bss.q31_i_d_fil,"aw",%nobits
 983              		.align	2
 986              	q31_i_d_fil:
 987 0000 00000000 		.space	4
 988              		.comm	p_MotorStatePublic,4,4
 989              		.section	.text._motor_error_handler,"ax",%progbits
 990              		.align	1
 991              		.global	_motor_error_handler
 992              		.syntax unified
 993              		.thumb
 994              		.thumb_func
 995              		.fpu softvfp
 997              	_motor_error_handler:
 998              	.LFB120:
 999              		.file 2 "Core/Src/motor.c"
   1:Core/Src/motor.c **** #include <stdlib.h>
   2:Core/Src/motor.c **** #include <arm_math.h>
   3:Core/Src/motor.c **** #include "main.h"
   4:Core/Src/motor.c **** #include "motor.h"
   5:Core/Src/motor.c **** #include "print.h"
   6:Core/Src/motor.c **** #include "eeprom.h"
   7:Core/Src/motor.c **** #include "utils.h"
   8:Core/Src/motor.c **** 
   9:Core/Src/motor.c **** #define TRIGGER_OFFSET_ADC 50
  10:Core/Src/motor.c **** #define TRIGGER_DEFAULT 2020
  11:Core/Src/motor.c **** #define _T 2028
  12:Core/Src/motor.c **** 
  13:Core/Src/motor.c **** #define iabs(x) (((x) >= 0)?(x):-(x))
  14:Core/Src/motor.c **** #define sign(x) (((x) >= 0)?(1):(-1))
  15:Core/Src/motor.c **** 
  16:Core/Src/motor.c **** #define _U_MAX	2000L
  17:Core/Src/motor.c **** 
  18:Core/Src/motor.c **** // Square Root of 3
  19:Core/Src/motor.c **** #define _SQRT3	28  //1.73205081*16
  20:Core/Src/motor.c **** 
  21:Core/Src/motor.c **** #define JSQR_PHASE_A 0b00011000000000000000 //3
ARM GAS  /tmp/ccpEjOub.s 			page 111


  22:Core/Src/motor.c **** #define JSQR_PHASE_B 0b00100000000000000000 //4
  23:Core/Src/motor.c **** #define JSQR_PHASE_C 0b00101000000000000000 //5
  24:Core/Src/motor.c **** 
  25:Core/Src/motor.c **** typedef struct {
  26:Core/Src/motor.c **** 	q31_t i_d;
  27:Core/Src/motor.c **** 	q31_t i_q;
  28:Core/Src/motor.c **** 	q31_t i_q_setpoint;
  29:Core/Src/motor.c **** 	q31_t i_d_setpoint;
  30:Core/Src/motor.c **** 	q31_t i_setpoint_abs;
  31:Core/Src/motor.c **** 	int32_t i_q_setpoint_temp;
  32:Core/Src/motor.c **** 	int32_t i_d_setpoint_temp;
  33:Core/Src/motor.c **** 	q31_t u_d;
  34:Core/Src/motor.c **** 	q31_t u_q;
  35:Core/Src/motor.c **** 	q31_t u_abs;
  36:Core/Src/motor.c **** 	q31_t Battery_Current;
  37:Core/Src/motor.c **** 	uint8_t char_dyn_adc_state;
  38:Core/Src/motor.c **** 	int8_t system_state;
  39:Core/Src/motor.c **** 	int8_t error_state;
  40:Core/Src/motor.c ****   int16_t spec_angle;
  41:Core/Src/motor.c ****   bool brake_active;
  42:Core/Src/motor.c ****   enum angle_estimation angle_estimation;
  43:Core/Src/motor.c **** 	int16_t KV_detect_flag;
  44:Core/Src/motor.c ****   bool hall_angle_detect_flag;
  45:Core/Src/motor.c **** } MotorState_t;
  46:Core/Src/motor.c **** 
  47:Core/Src/motor.c **** typedef struct
  48:Core/Src/motor.c **** {
  49:Core/Src/motor.c **** 	int16_t gain_p;
  50:Core/Src/motor.c **** 	int16_t gain_i;
  51:Core/Src/motor.c **** 	int16_t limit_i;
  52:Core/Src/motor.c **** 	int16_t limit_output;
  53:Core/Src/motor.c **** 	int16_t recent_value;
  54:Core/Src/motor.c **** 	int32_t setpoint;
  55:Core/Src/motor.c **** 	int32_t integral_part;
  56:Core/Src/motor.c **** 	int16_t max_step;
  57:Core/Src/motor.c **** 	int32_t out;
  58:Core/Src/motor.c **** 	int8_t shift;
  59:Core/Src/motor.c **** } PI_control_t;
  60:Core/Src/motor.c **** 
  61:Core/Src/motor.c **** // EEPROM number of variables to use
  62:Core/Src/motor.c **** uint16_t VirtAddVarTab[NB_OF_VAR] = {
  63:Core/Src/motor.c ****   0x01,
  64:Core/Src/motor.c ****   0x02,
  65:Core/Src/motor.c ****   0x03
  66:Core/Src/motor.c **** };
  67:Core/Src/motor.c **** 
  68:Core/Src/motor.c **** ADC_HandleTypeDef hadc1;
  69:Core/Src/motor.c **** ADC_HandleTypeDef hadc2;
  70:Core/Src/motor.c **** DMA_HandleTypeDef hdma_adc1;
  71:Core/Src/motor.c **** 
  72:Core/Src/motor.c **** TIM_HandleTypeDef htim1;
  73:Core/Src/motor.c **** TIM_HandleTypeDef htim2;
  74:Core/Src/motor.c **** TIM_HandleTypeDef htim3;
  75:Core/Src/motor.c **** TIM_HandleTypeDef htim4;
  76:Core/Src/motor.c **** 
  77:Core/Src/motor.c **** uint16_t adcData1[6 * sizeof(uint32_t)]; // point to buffer for ADC1 inputs
  78:Core/Src/motor.c **** 
ARM GAS  /tmp/ccpEjOub.s 			page 112


  79:Core/Src/motor.c **** MotorState_t MS;
  80:Core/Src/motor.c **** 
  81:Core/Src/motor.c **** int16_t i16_ph1_current = 0;
  82:Core/Src/motor.c **** int16_t i16_ph2_current = 0;
  83:Core/Src/motor.c **** int16_t i16_ph2_current_filter = 0;
  84:Core/Src/motor.c **** uint8_t ui8_adc_inj_flag = 0;
  85:Core/Src/motor.c **** q31_t raw_inj1;
  86:Core/Src/motor.c **** q31_t raw_inj2;
  87:Core/Src/motor.c **** uint8_t ui8_hall_state = 0;
  88:Core/Src/motor.c **** uint8_t ui8_hall_state_old = 0;
  89:Core/Src/motor.c **** uint8_t ui8_hall_case = 0;
  90:Core/Src/motor.c **** bool ui8_BC_limit_flag = false;
  91:Core/Src/motor.c **** uint16_t ui16_halls_tim2tics; // timertics between two hall events for 60 interpolation
  92:Core/Src/motor.c **** uint16_t ui16_halls_tim2tics_filtered = 5000;
  93:Core/Src/motor.c **** bool ui8_6step_flag = false;
  94:Core/Src/motor.c **** q31_t q31_rotorposition_absolute;
  95:Core/Src/motor.c **** q31_t q31_rotorposition_hall;
  96:Core/Src/motor.c **** q31_t q31_rotorposition_motor_specific = SPEC_ANGLE;
  97:Core/Src/motor.c **** q31_t q31_rotorposition_PLL = 0;
  98:Core/Src/motor.c **** q31_t q31_angle_per_tic = 0;
  99:Core/Src/motor.c **** q31_t q31_PLL_error = 0;
 100:Core/Src/motor.c **** int8_t i8_recent_rotor_direction = 1;
 101:Core/Src/motor.c **** int16_t i16_hall_order = 1;
 102:Core/Src/motor.c **** 
 103:Core/Src/motor.c **** // rotor angle scaled from degree to q31 for arm_math. -180-->-2^31, 0-->0, +180-->+2^31 read
 104:Core/Src/motor.c **** q31_t Hall_13 = 0;
 105:Core/Src/motor.c **** q31_t Hall_32 = 0;
 106:Core/Src/motor.c **** q31_t Hall_26 = 0;
 107:Core/Src/motor.c **** q31_t Hall_64 = 0;
 108:Core/Src/motor.c **** q31_t Hall_51 = 0;
 109:Core/Src/motor.c **** q31_t Hall_45 = 0;
 110:Core/Src/motor.c **** 
 111:Core/Src/motor.c **** const q31_t deg_30 = 357913941;
 112:Core/Src/motor.c **** 
 113:Core/Src/motor.c **** q31_t switchtime[3];
 114:Core/Src/motor.c **** bool ui8_overflow_flag = false;
 115:Core/Src/motor.c **** char char_dyn_adc_state_old = 1;
 116:Core/Src/motor.c **** q31_t q31_tics_filtered = 128000;
 117:Core/Src/motor.c **** q31_t q31_t_Battery_Current_accumulated = 0;
 118:Core/Src/motor.c **** int8_t i8_direction = REVERSE;
 119:Core/Src/motor.c **** int8_t i8_reverse_flag = 1; //for temporaribly reverse direction
 120:Core/Src/motor.c **** q31_t q31_u_d_temp = 0;
 121:Core/Src/motor.c **** q31_t q31_u_q_temp = 0;
 122:Core/Src/motor.c **** int16_t i16_sinus = 0;
 123:Core/Src/motor.c **** int16_t i16_cosinus = 0;
 124:Core/Src/motor.c **** uint16_t uint16_half_rotation_counter = 0;
 125:Core/Src/motor.c **** uint16_t uint16_full_rotation_counter = 0;
 126:Core/Src/motor.c **** 
 127:Core/Src/motor.c **** static q31_t tics_lower_limit;
 128:Core/Src/motor.c **** static q31_t tics_higher_limit;
 129:Core/Src/motor.c **** 
 130:Core/Src/motor.c **** //Rotor angle scaled from degree to q31 for arm_math. -180-->-2^31, 0-->0, +180-->+2^31
 131:Core/Src/motor.c **** const q31_t DEG_0 = 0;
 132:Core/Src/motor.c **** const q31_t DEG_plus60 = 715827883;
 133:Core/Src/motor.c **** const q31_t DEG_plus120 = 1431655765;
 134:Core/Src/motor.c **** const q31_t DEG_plus180 = 2147483647;
 135:Core/Src/motor.c **** const q31_t DEG_minus60 = -715827883;
ARM GAS  /tmp/ccpEjOub.s 			page 113


 136:Core/Src/motor.c **** const q31_t DEG_minus120 = -1431655765;
 137:Core/Src/motor.c **** 
 138:Core/Src/motor.c **** uint16_t ui16_reg_adc_value;
 139:Core/Src/motor.c **** uint32_t ui32_reg_adc_value_filter;
 140:Core/Src/motor.c **** uint8_t ui8_adc_regular_flag = 0;
 141:Core/Src/motor.c **** uint16_t ui16_ph1_offset = 0;
 142:Core/Src/motor.c **** uint16_t ui16_ph2_offset = 0;
 143:Core/Src/motor.c **** uint16_t ui16_ph3_offset = 0;
 144:Core/Src/motor.c **** 
 145:Core/Src/motor.c **** uint16_t ui16_KV_detect_counter = 0; // for getting timing of the KV detect
 146:Core/Src/motor.c **** static int16_t ui32_KV = 0;
 147:Core/Src/motor.c **** 
 148:Core/Src/motor.c **** uint32_t uint32_SPEEDx100_cumulated = 0;
 149:Core/Src/motor.c **** 
 150:Core/Src/motor.c **** // structs for PI_control
 151:Core/Src/motor.c **** PI_control_t PI_iq;
 152:Core/Src/motor.c **** PI_control_t PI_id;
 153:Core/Src/motor.c **** 
 154:Core/Src/motor.c **** q31_t iq_filtered;
 155:Core/Src/motor.c **** q31_t id_filtered;
 156:Core/Src/motor.c **** q31_t uq_filtered;
 157:Core/Src/motor.c **** q31_t ud_filtered;
 158:Core/Src/motor.c **** 
 159:Core/Src/motor.c **** q31_t q31_i_q_fil = 0;
 160:Core/Src/motor.c **** q31_t q31_i_d_fil = 0;
 161:Core/Src/motor.c **** 
 162:Core/Src/motor.c **** MotorStatePublic_t* p_MotorStatePublic;
 163:Core/Src/motor.c **** 
 164:Core/Src/motor.c **** void _motor_error_handler(char *file, int line) {
 1000              		.loc 2 164 49
 1001              		.cfi_startproc
 1002              		@ args = 0, pretend = 0, frame = 8
 1003              		@ frame_needed = 1, uses_anonymous_args = 0
 1004 0000 80B5     		push	{r7, lr}
 1005              	.LCFI31:
 1006              		.cfi_def_cfa_offset 8
 1007              		.cfi_offset 7, -8
 1008              		.cfi_offset 14, -4
 1009 0002 82B0     		sub	sp, sp, #8
 1010              	.LCFI32:
 1011              		.cfi_def_cfa_offset 16
 1012 0004 00AF     		add	r7, sp, #0
 1013              	.LCFI33:
 1014              		.cfi_def_cfa_register 7
 1015 0006 7860     		str	r0, [r7, #4]
 1016 0008 3960     		str	r1, [r7]
 1017              	.LBB9:
 1018              	.LBB10:
 1019              		.file 3 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
ARM GAS  /tmp/ccpEjOub.s 			page 114


   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
ARM GAS  /tmp/ccpEjOub.s 			page 115


  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 117:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 122:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccpEjOub.s 			page 116


 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 129:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 131:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 133:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 1020              		.loc 3 142 3
 1021              		.syntax unified
 1022              	@ 142 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1023 000a 72B6     		cpsid i
 1024              	@ 0 "" 2
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1025              		.loc 3 143 1
 1026              		.thumb
 1027              		.syntax unified
 1028 000c 00BF     		nop
 1029              	.L15:
 1030              	.LBE10:
 1031              	.LBE9:
 165:Core/Src/motor.c **** 	__disable_irq();
 166:Core/Src/motor.c **** 	while (1) {
 167:Core/Src/motor.c ****     motor_disable_pwm();
 1032              		.loc 2 167 5 discriminator 1
 1033 000e FFF7FEFF 		bl	motor_disable_pwm
 1034 0012 FCE7     		b	.L15
 1035              		.cfi_endproc
 1036              	.LFE120:
 1038              		.section	.text.HAL_ADC_ConvCpltCallback,"ax",%progbits
 1039              		.align	1
 1040              		.global	HAL_ADC_ConvCpltCallback
 1041              		.syntax unified
 1042              		.thumb
 1043              		.thumb_func
 1044              		.fpu softvfp
 1046              	HAL_ADC_ConvCpltCallback:
 1047              	.LFB121:
 168:Core/Src/motor.c **** 	}
 169:Core/Src/motor.c **** }
 170:Core/Src/motor.c **** 
 171:Core/Src/motor.c **** // regular ADC callback
 172:Core/Src/motor.c **** void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
 1048              		.loc 2 172 56
 1049              		.cfi_startproc
ARM GAS  /tmp/ccpEjOub.s 			page 117


 1050              		@ args = 0, pretend = 0, frame = 8
 1051              		@ frame_needed = 1, uses_anonymous_args = 0
 1052              		@ link register save eliminated.
 1053 0000 80B4     		push	{r7}
 1054              	.LCFI34:
 1055              		.cfi_def_cfa_offset 4
 1056              		.cfi_offset 7, -4
 1057 0002 83B0     		sub	sp, sp, #12
 1058              	.LCFI35:
 1059              		.cfi_def_cfa_offset 16
 1060 0004 00AF     		add	r7, sp, #0
 1061              	.LCFI36:
 1062              		.cfi_def_cfa_register 7
 1063 0006 7860     		str	r0, [r7, #4]
 173:Core/Src/motor.c **** 	ui8_adc_regular_flag = 1;
 1064              		.loc 2 173 23
 1065 0008 034B     		ldr	r3, .L17
 1066 000a 0122     		movs	r2, #1
 1067 000c 1A70     		strb	r2, [r3]
 174:Core/Src/motor.c **** }
 1068              		.loc 2 174 1
 1069 000e 00BF     		nop
 1070 0010 0C37     		adds	r7, r7, #12
 1071              	.LCFI37:
 1072              		.cfi_def_cfa_offset 4
 1073 0012 BD46     		mov	sp, r7
 1074              	.LCFI38:
 1075              		.cfi_def_cfa_register 13
 1076              		@ sp needed
 1077 0014 80BC     		pop	{r7}
 1078              	.LCFI39:
 1079              		.cfi_restore 7
 1080              		.cfi_def_cfa_offset 0
 1081 0016 7047     		bx	lr
 1082              	.L18:
 1083              		.align	2
 1084              	.L17:
 1085 0018 00000000 		.word	ui8_adc_regular_flag
 1086              		.cfi_endproc
 1087              	.LFE121:
 1089              		.section	.text.motor_disable_pwm,"ax",%progbits
 1090              		.align	1
 1091              		.global	motor_disable_pwm
 1092              		.syntax unified
 1093              		.thumb
 1094              		.thumb_func
 1095              		.fpu softvfp
 1097              	motor_disable_pwm:
 1098              	.LFB122:
 175:Core/Src/motor.c **** 
 176:Core/Src/motor.c **** void motor_disable_pwm(void) {
 1099              		.loc 2 176 30
 1100              		.cfi_startproc
 1101              		@ args = 0, pretend = 0, frame = 0
 1102              		@ frame_needed = 1, uses_anonymous_args = 0
 1103              		@ link register save eliminated.
 1104 0000 80B4     		push	{r7}
ARM GAS  /tmp/ccpEjOub.s 			page 118


 1105              	.LCFI40:
 1106              		.cfi_def_cfa_offset 4
 1107              		.cfi_offset 7, -4
 1108 0002 00AF     		add	r7, sp, #0
 1109              	.LCFI41:
 1110              		.cfi_def_cfa_register 7
 177:Core/Src/motor.c ****   CLEAR_BIT(TIM1->BDTR, TIM_BDTR_MOE);
 1111              		.loc 2 177 3
 1112 0004 044B     		ldr	r3, .L20
 1113 0006 5B6C     		ldr	r3, [r3, #68]
 1114 0008 034A     		ldr	r2, .L20
 1115 000a 23F40043 		bic	r3, r3, #32768
 1116 000e 5364     		str	r3, [r2, #68]
 178:Core/Src/motor.c **** }
 1117              		.loc 2 178 1
 1118 0010 00BF     		nop
 1119 0012 BD46     		mov	sp, r7
 1120              	.LCFI42:
 1121              		.cfi_def_cfa_register 13
 1122              		@ sp needed
 1123 0014 80BC     		pop	{r7}
 1124              	.LCFI43:
 1125              		.cfi_restore 7
 1126              		.cfi_def_cfa_offset 0
 1127 0016 7047     		bx	lr
 1128              	.L21:
 1129              		.align	2
 1130              	.L20:
 1131 0018 002C0140 		.word	1073818624
 1132              		.cfi_endproc
 1133              	.LFE122:
 1135              		.section	.text.disable_pwm,"ax",%progbits
 1136              		.align	1
 1137              		.syntax unified
 1138              		.thumb
 1139              		.thumb_func
 1140              		.fpu softvfp
 1142              	disable_pwm:
 1143              	.LFB123:
 179:Core/Src/motor.c **** 
 180:Core/Src/motor.c **** static inline void disable_pwm(void) {
 1144              		.loc 2 180 38
 1145              		.cfi_startproc
 1146              		@ args = 0, pretend = 0, frame = 0
 1147              		@ frame_needed = 1, uses_anonymous_args = 0
 1148              		@ link register save eliminated.
 1149 0000 80B4     		push	{r7}
 1150              	.LCFI44:
 1151              		.cfi_def_cfa_offset 4
 1152              		.cfi_offset 7, -4
 1153 0002 00AF     		add	r7, sp, #0
 1154              	.LCFI45:
 1155              		.cfi_def_cfa_register 7
 181:Core/Src/motor.c ****   CLEAR_BIT(TIM1->BDTR, TIM_BDTR_MOE);
 1156              		.loc 2 181 3
 1157 0004 044B     		ldr	r3, .L23
 1158 0006 5B6C     		ldr	r3, [r3, #68]
ARM GAS  /tmp/ccpEjOub.s 			page 119


 1159 0008 034A     		ldr	r2, .L23
 1160 000a 23F40043 		bic	r3, r3, #32768
 1161 000e 5364     		str	r3, [r2, #68]
 182:Core/Src/motor.c **** }
 1162              		.loc 2 182 1
 1163 0010 00BF     		nop
 1164 0012 BD46     		mov	sp, r7
 1165              	.LCFI46:
 1166              		.cfi_def_cfa_register 13
 1167              		@ sp needed
 1168 0014 80BC     		pop	{r7}
 1169              	.LCFI47:
 1170              		.cfi_restore 7
 1171              		.cfi_def_cfa_offset 0
 1172 0016 7047     		bx	lr
 1173              	.L24:
 1174              		.align	2
 1175              	.L23:
 1176 0018 002C0140 		.word	1073818624
 1177              		.cfi_endproc
 1178              	.LFE123:
 1180              		.section	.text.enable_pwm,"ax",%progbits
 1181              		.align	1
 1182              		.syntax unified
 1183              		.thumb
 1184              		.thumb_func
 1185              		.fpu softvfp
 1187              	enable_pwm:
 1188              	.LFB124:
 183:Core/Src/motor.c **** 
 184:Core/Src/motor.c **** static inline void enable_pwm(void) {
 1189              		.loc 2 184 37
 1190              		.cfi_startproc
 1191              		@ args = 0, pretend = 0, frame = 0
 1192              		@ frame_needed = 1, uses_anonymous_args = 0
 1193              		@ link register save eliminated.
 1194 0000 80B4     		push	{r7}
 1195              	.LCFI48:
 1196              		.cfi_def_cfa_offset 4
 1197              		.cfi_offset 7, -4
 1198 0002 00AF     		add	r7, sp, #0
 1199              	.LCFI49:
 1200              		.cfi_def_cfa_register 7
 185:Core/Src/motor.c ****   SET_BIT(TIM1->BDTR, TIM_BDTR_MOE);
 1201              		.loc 2 185 3
 1202 0004 044B     		ldr	r3, .L26
 1203 0006 5B6C     		ldr	r3, [r3, #68]
 1204 0008 034A     		ldr	r2, .L26
 1205 000a 43F40043 		orr	r3, r3, #32768
 1206 000e 5364     		str	r3, [r2, #68]
 186:Core/Src/motor.c **** }
 1207              		.loc 2 186 1
 1208 0010 00BF     		nop
 1209 0012 BD46     		mov	sp, r7
 1210              	.LCFI50:
 1211              		.cfi_def_cfa_register 13
 1212              		@ sp needed
ARM GAS  /tmp/ccpEjOub.s 			page 120


 1213 0014 80BC     		pop	{r7}
 1214              	.LCFI51:
 1215              		.cfi_restore 7
 1216              		.cfi_def_cfa_offset 0
 1217 0016 7047     		bx	lr
 1218              	.L27:
 1219              		.align	2
 1220              	.L26:
 1221 0018 002C0140 		.word	1073818624
 1222              		.cfi_endproc
 1223              	.LFE124:
 1225              		.section	.text.pwm_is_enabled,"ax",%progbits
 1226              		.align	1
 1227              		.syntax unified
 1228              		.thumb
 1229              		.thumb_func
 1230              		.fpu softvfp
 1232              	pwm_is_enabled:
 1233              	.LFB125:
 187:Core/Src/motor.c **** 
 188:Core/Src/motor.c **** static inline bool pwm_is_enabled(void) {
 1234              		.loc 2 188 41
 1235              		.cfi_startproc
 1236              		@ args = 0, pretend = 0, frame = 0
 1237              		@ frame_needed = 1, uses_anonymous_args = 0
 1238              		@ link register save eliminated.
 1239 0000 80B4     		push	{r7}
 1240              	.LCFI52:
 1241              		.cfi_def_cfa_offset 4
 1242              		.cfi_offset 7, -4
 1243 0002 00AF     		add	r7, sp, #0
 1244              	.LCFI53:
 1245              		.cfi_def_cfa_register 7
 189:Core/Src/motor.c ****   return READ_BIT(TIM1->BDTR, TIM_BDTR_MOE);
 1246              		.loc 2 189 10
 1247 0004 064B     		ldr	r3, .L30
 1248 0006 5B6C     		ldr	r3, [r3, #68]
 1249 0008 03F40043 		and	r3, r3, #32768
 1250 000c 002B     		cmp	r3, #0
 1251 000e 14BF     		ite	ne
 1252 0010 0123     		movne	r3, #1
 1253 0012 0023     		moveq	r3, #0
 1254 0014 DBB2     		uxtb	r3, r3
 190:Core/Src/motor.c **** }
 1255              		.loc 2 190 1
 1256 0016 1846     		mov	r0, r3
 1257 0018 BD46     		mov	sp, r7
 1258              	.LCFI54:
 1259              		.cfi_def_cfa_register 13
 1260              		@ sp needed
 1261 001a 80BC     		pop	{r7}
 1262              	.LCFI55:
 1263              		.cfi_restore 7
 1264              		.cfi_def_cfa_offset 0
 1265 001c 7047     		bx	lr
 1266              	.L31:
 1267 001e 00BF     		.align	2
ARM GAS  /tmp/ccpEjOub.s 			page 121


 1268              	.L30:
 1269 0020 002C0140 		.word	1073818624
 1270              		.cfi_endproc
 1271              	.LFE125:
 1273              		.section	.text.speed_PLL,"ax",%progbits
 1274              		.align	1
 1275              		.global	speed_PLL
 1276              		.syntax unified
 1277              		.thumb
 1278              		.thumb_func
 1279              		.fpu softvfp
 1281              	speed_PLL:
 1282              	.LFB126:
 191:Core/Src/motor.c **** 
 192:Core/Src/motor.c **** q31_t speed_PLL(q31_t actual, q31_t target) {
 1283              		.loc 2 192 45
 1284              		.cfi_startproc
 1285              		@ args = 0, pretend = 0, frame = 24
 1286              		@ frame_needed = 1, uses_anonymous_args = 0
 1287              		@ link register save eliminated.
 1288 0000 80B4     		push	{r7}
 1289              	.LCFI56:
 1290              		.cfi_def_cfa_offset 4
 1291              		.cfi_offset 7, -4
 1292 0002 87B0     		sub	sp, sp, #28
 1293              	.LCFI57:
 1294              		.cfi_def_cfa_offset 32
 1295 0004 00AF     		add	r7, sp, #0
 1296              	.LCFI58:
 1297              		.cfi_def_cfa_register 7
 1298 0006 7860     		str	r0, [r7, #4]
 1299 0008 3960     		str	r1, [r7]
 193:Core/Src/motor.c ****   static q31_t q31_d_i = 0;
 194:Core/Src/motor.c **** 
 195:Core/Src/motor.c ****   q31_t q31_PLL_error = target - actual;
 1300              		.loc 2 195 9
 1301 000a 3A68     		ldr	r2, [r7]
 1302 000c 7B68     		ldr	r3, [r7, #4]
 1303 000e D31A     		subs	r3, r2, r3
 1304 0010 7B61     		str	r3, [r7, #20]
 196:Core/Src/motor.c **** 
 197:Core/Src/motor.c ****   q31_t q31_p = (q31_PLL_error >> P_FACTOR_PLL);
 1305              		.loc 2 197 9
 1306 0012 7B69     		ldr	r3, [r7, #20]
 1307 0014 9B12     		asrs	r3, r3, #10
 1308 0016 3B61     		str	r3, [r7, #16]
 198:Core/Src/motor.c ****   q31_d_i += (q31_PLL_error >> I_FACTOR_PLL);
 1309              		.loc 2 198 29
 1310 0018 7B69     		ldr	r3, [r7, #20]
 1311 001a 9A12     		asrs	r2, r3, #10
 1312              		.loc 2 198 11
 1313 001c 264B     		ldr	r3, .L37
 1314 001e 1B68     		ldr	r3, [r3]
 1315 0020 1344     		add	r3, r3, r2
 1316 0022 254A     		ldr	r2, .L37
 1317 0024 1360     		str	r3, [r2]
 199:Core/Src/motor.c **** 
ARM GAS  /tmp/ccpEjOub.s 			page 122


 200:Core/Src/motor.c ****   q31_t limit = ((deg_30 >> 18) * 500 / ui16_halls_tim2tics) << 16;
 1318              		.loc 2 200 26
 1319 0026 254B     		ldr	r3, .L37+4
 1320 0028 9B14     		asrs	r3, r3, #18
 1321              		.loc 2 200 33
 1322 002a 4FF4FA72 		mov	r2, #500
 1323 002e 02FB03F3 		mul	r3, r2, r3
 1324              		.loc 2 200 39
 1325 0032 234A     		ldr	r2, .L37+8
 1326 0034 1288     		ldrh	r2, [r2]
 1327 0036 93FBF2F3 		sdiv	r3, r3, r2
 1328              		.loc 2 200 9
 1329 003a 1B04     		lsls	r3, r3, #16
 1330 003c FB60     		str	r3, [r7, #12]
 201:Core/Src/motor.c ****   if (q31_d_i > limit) {
 1331              		.loc 2 201 15
 1332 003e 1E4B     		ldr	r3, .L37
 1333 0040 1B68     		ldr	r3, [r3]
 1334              		.loc 2 201 6
 1335 0042 FA68     		ldr	r2, [r7, #12]
 1336 0044 9A42     		cmp	r2, r3
 1337 0046 02DA     		bge	.L33
 202:Core/Src/motor.c ****     q31_d_i = limit;
 1338              		.loc 2 202 13
 1339 0048 1B4A     		ldr	r2, .L37
 1340 004a FB68     		ldr	r3, [r7, #12]
 1341 004c 1360     		str	r3, [r2]
 1342              	.L33:
 203:Core/Src/motor.c ****   }
 204:Core/Src/motor.c ****   
 205:Core/Src/motor.c ****   limit = -((deg_30 >> 18) * 500 / ui16_halls_tim2tics) << 16;
 1343              		.loc 2 205 21
 1344 004e 1B4B     		ldr	r3, .L37+4
 1345 0050 9B14     		asrs	r3, r3, #18
 1346              		.loc 2 205 28
 1347 0052 4FF4FA72 		mov	r2, #500
 1348 0056 02FB03F3 		mul	r3, r2, r3
 1349              		.loc 2 205 34
 1350 005a 194A     		ldr	r2, .L37+8
 1351 005c 1288     		ldrh	r2, [r2]
 1352 005e 93FBF2F3 		sdiv	r3, r3, r2
 1353              		.loc 2 205 11
 1354 0062 5B42     		rsbs	r3, r3, #0
 1355              		.loc 2 205 9
 1356 0064 1B04     		lsls	r3, r3, #16
 1357 0066 FB60     		str	r3, [r7, #12]
 206:Core/Src/motor.c ****   if (q31_d_i < limit) {
 1358              		.loc 2 206 15
 1359 0068 134B     		ldr	r3, .L37
 1360 006a 1B68     		ldr	r3, [r3]
 1361              		.loc 2 206 6
 1362 006c FA68     		ldr	r2, [r7, #12]
 1363 006e 9A42     		cmp	r2, r3
 1364 0070 0DDD     		ble	.L34
 207:Core/Src/motor.c ****     q31_d_i = -((deg_30 >> 18) * 500 / ui16_halls_tim2tics) << 16;
 1365              		.loc 2 207 25
 1366 0072 124B     		ldr	r3, .L37+4
ARM GAS  /tmp/ccpEjOub.s 			page 123


 1367 0074 9B14     		asrs	r3, r3, #18
 1368              		.loc 2 207 32
 1369 0076 4FF4FA72 		mov	r2, #500
 1370 007a 02FB03F3 		mul	r3, r2, r3
 1371              		.loc 2 207 38
 1372 007e 104A     		ldr	r2, .L37+8
 1373 0080 1288     		ldrh	r2, [r2]
 1374 0082 93FBF2F3 		sdiv	r3, r3, r2
 1375              		.loc 2 207 15
 1376 0086 5B42     		rsbs	r3, r3, #0
 1377              		.loc 2 207 61
 1378 0088 1B04     		lsls	r3, r3, #16
 1379              		.loc 2 207 13
 1380 008a 0B4A     		ldr	r2, .L37
 1381 008c 1360     		str	r3, [r2]
 1382              	.L34:
 208:Core/Src/motor.c ****   }
 209:Core/Src/motor.c **** 
 210:Core/Src/motor.c ****   q31_t q31_d_dc = q31_p + q31_d_i;
 1383              		.loc 2 210 26
 1384 008e 0A4B     		ldr	r3, .L37
 1385 0090 1B68     		ldr	r3, [r3]
 1386              		.loc 2 210 9
 1387 0092 3A69     		ldr	r2, [r7, #16]
 1388 0094 1344     		add	r3, r3, r2
 1389 0096 BB60     		str	r3, [r7, #8]
 211:Core/Src/motor.c **** 
 212:Core/Src/motor.c ****   if (actual == 0 && target == 0) {
 1390              		.loc 2 212 6
 1391 0098 7B68     		ldr	r3, [r7, #4]
 1392 009a 002B     		cmp	r3, #0
 1393 009c 05D1     		bne	.L35
 1394              		.loc 2 212 19 discriminator 1
 1395 009e 3B68     		ldr	r3, [r7]
 1396 00a0 002B     		cmp	r3, #0
 1397 00a2 02D1     		bne	.L35
 213:Core/Src/motor.c ****     q31_d_i = 0;
 1398              		.loc 2 213 13
 1399 00a4 044B     		ldr	r3, .L37
 1400 00a6 0022     		movs	r2, #0
 1401 00a8 1A60     		str	r2, [r3]
 1402              	.L35:
 214:Core/Src/motor.c ****   }
 215:Core/Src/motor.c **** 
 216:Core/Src/motor.c ****   return q31_d_dc;
 1403              		.loc 2 216 10
 1404 00aa BB68     		ldr	r3, [r7, #8]
 217:Core/Src/motor.c **** }
 1405              		.loc 2 217 1
 1406 00ac 1846     		mov	r0, r3
 1407 00ae 1C37     		adds	r7, r7, #28
 1408              	.LCFI59:
 1409              		.cfi_def_cfa_offset 4
 1410 00b0 BD46     		mov	sp, r7
 1411              	.LCFI60:
 1412              		.cfi_def_cfa_register 13
 1413              		@ sp needed
ARM GAS  /tmp/ccpEjOub.s 			page 124


 1414 00b2 80BC     		pop	{r7}
 1415              	.LCFI61:
 1416              		.cfi_restore 7
 1417              		.cfi_def_cfa_offset 0
 1418 00b4 7047     		bx	lr
 1419              	.L38:
 1420 00b6 00BF     		.align	2
 1421              	.L37:
 1422 00b8 00000000 		.word	q31_d_i.10001
 1423 00bc 55555515 		.word	357913941
 1424 00c0 00000000 		.word	ui16_halls_tim2tics
 1425              		.cfi_endproc
 1426              	.LFE126:
 1428              		.section	.text.HAL_GPIO_EXTI_Callback,"ax",%progbits
 1429              		.align	1
 1430              		.global	HAL_GPIO_EXTI_Callback
 1431              		.syntax unified
 1432              		.thumb
 1433              		.thumb_func
 1434              		.fpu softvfp
 1436              	HAL_GPIO_EXTI_Callback:
 1437              	.LFB127:
 218:Core/Src/motor.c **** 
 219:Core/Src/motor.c **** void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
 1438              		.loc 2 219 48
 1439              		.cfi_startproc
 1440              		@ args = 0, pretend = 0, frame = 16
 1441              		@ frame_needed = 1, uses_anonymous_args = 0
 1442 0000 80B5     		push	{r7, lr}
 1443              	.LCFI62:
 1444              		.cfi_def_cfa_offset 8
 1445              		.cfi_offset 7, -8
 1446              		.cfi_offset 14, -4
 1447 0002 84B0     		sub	sp, sp, #16
 1448              	.LCFI63:
 1449              		.cfi_def_cfa_offset 24
 1450 0004 00AF     		add	r7, sp, #0
 1451              	.LCFI64:
 1452              		.cfi_def_cfa_register 7
 1453 0006 0346     		mov	r3, r0
 1454 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 220:Core/Src/motor.c **** 	// Hall sensor event processing
 221:Core/Src/motor.c **** 	if (GPIO_Pin == HALL_1_Pin || GPIO_Pin == HALL_2_Pin || GPIO_Pin == HALL_3_Pin) // check for right
 1455              		.loc 2 221 5
 1456 000a FB88     		ldrh	r3, [r7, #6]
 1457 000c 102B     		cmp	r3, #16
 1458 000e 06D0     		beq	.L40
 1459              		.loc 2 221 29 discriminator 1
 1460 0010 FB88     		ldrh	r3, [r7, #6]
 1461 0012 202B     		cmp	r3, #32
 1462 0014 03D0     		beq	.L40
 1463              		.loc 2 221 55 discriminator 2
 1464 0016 FB88     		ldrh	r3, [r7, #6]
 1465 0018 012B     		cmp	r3, #1
 1466 001a 40F0B181 		bne	.L39
 1467              	.L40:
 1468              	.LBB11:
ARM GAS  /tmp/ccpEjOub.s 			page 125


 222:Core/Src/motor.c **** 	{
 223:Core/Src/motor.c **** 		ui8_hall_state = ((GPIOB->IDR & 1) << 2) | ((GPIOB->IDR >> 4) & 0b11); // mask input register wit
 1469              		.loc 2 223 27
 1470 001e AA4B     		ldr	r3, .L60
 1471 0020 9B68     		ldr	r3, [r3, #8]
 1472              		.loc 2 223 38
 1473 0022 DBB2     		uxtb	r3, r3
 1474 0024 9B00     		lsls	r3, r3, #2
 1475 0026 DBB2     		uxtb	r3, r3
 1476 0028 03F00403 		and	r3, r3, #4
 1477 002c DAB2     		uxtb	r2, r3
 1478              		.loc 2 223 53
 1479 002e A64B     		ldr	r3, .L60
 1480 0030 9B68     		ldr	r3, [r3, #8]
 1481              		.loc 2 223 59
 1482 0032 1B09     		lsrs	r3, r3, #4
 1483              		.loc 2 223 65
 1484 0034 DBB2     		uxtb	r3, r3
 1485 0036 03F00303 		and	r3, r3, #3
 1486 003a DBB2     		uxtb	r3, r3
 1487              		.loc 2 223 44
 1488 003c 1343     		orrs	r3, r3, r2
 1489 003e DAB2     		uxtb	r2, r3
 1490              		.loc 2 223 18
 1491 0040 A24B     		ldr	r3, .L60+4
 1492 0042 1A70     		strb	r2, [r3]
 224:Core/Src/motor.c **** 
 225:Core/Src/motor.c **** 		if (ui8_hall_state == ui8_hall_state_old)
 1493              		.loc 2 225 22
 1494 0044 A14B     		ldr	r3, .L60+4
 1495 0046 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1496 0048 A14B     		ldr	r3, .L60+8
 1497 004a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1498              		.loc 2 225 6
 1499 004c 9A42     		cmp	r2, r3
 1500 004e 00F09681 		beq	.L59
 226:Core/Src/motor.c **** 			return;
 227:Core/Src/motor.c **** 
 228:Core/Src/motor.c ****     // old state + current state: having both states makes possible to validade correct sequence (o
 229:Core/Src/motor.c **** 		ui8_hall_case = ui8_hall_state_old * 10 + ui8_hall_state;
 1501              		.loc 2 229 43
 1502 0052 9F4B     		ldr	r3, .L60+8
 1503 0054 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1504 0056 1A46     		mov	r2, r3
 1505 0058 9200     		lsls	r2, r2, #2
 1506 005a 1344     		add	r3, r3, r2
 1507 005c 5B00     		lsls	r3, r3, #1
 1508 005e DAB2     		uxtb	r2, r3
 1509 0060 9A4B     		ldr	r3, .L60+4
 1510 0062 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1511 0064 1344     		add	r3, r3, r2
 1512 0066 DAB2     		uxtb	r2, r3
 1513              		.loc 2 229 17
 1514 0068 9A4B     		ldr	r3, .L60+12
 1515 006a 1A70     		strb	r2, [r3]
 230:Core/Src/motor.c **** 
 231:Core/Src/motor.c ****     // only process, if autodetect process is finished
ARM GAS  /tmp/ccpEjOub.s 			page 126


 232:Core/Src/motor.c **** 		if (MS.hall_angle_detect_flag == false) {
 1516              		.loc 2 232 9
 1517 006c 9A4B     		ldr	r3, .L60+16
 1518 006e 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 1519              		.loc 2 232 33
 1520 0072 83F00103 		eor	r3, r3, #1
 1521 0076 DBB2     		uxtb	r3, r3
 1522              		.loc 2 232 6
 1523 0078 002B     		cmp	r3, #0
 1524 007a 03D0     		beq	.L43
 233:Core/Src/motor.c **** 			ui8_hall_state_old = ui8_hall_state;
 1525              		.loc 2 233 23
 1526 007c 934B     		ldr	r3, .L60+4
 1527 007e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1528 0080 934B     		ldr	r3, .L60+8
 1529 0082 1A70     		strb	r2, [r3]
 1530              	.L43:
 234:Core/Src/motor.c **** 		}
 235:Core/Src/motor.c **** 
 236:Core/Src/motor.c **** 		uint16_t ui16_tim2_ticks = __HAL_TIM_GET_COUNTER(&htim2); // read in timer2tics since last hall e
 1531              		.loc 2 236 30
 1532 0084 954B     		ldr	r3, .L60+20
 1533 0086 1B68     		ldr	r3, [r3]
 1534 0088 5B6A     		ldr	r3, [r3, #36]
 1535              		.loc 2 236 12
 1536 008a FB81     		strh	r3, [r7, #14]	@ movhi
 237:Core/Src/motor.c **** 
 238:Core/Src/motor.c **** 		if (ui16_tim2_ticks > 100) { // debounce
 1537              		.loc 2 238 6
 1538 008c FB89     		ldrh	r3, [r7, #14]
 1539 008e 642B     		cmp	r3, #100
 1540 0090 1FD9     		bls	.L44
 1541              	.LBB12:
 239:Core/Src/motor.c **** 
 240:Core/Src/motor.c **** 			ui16_halls_tim2tics = ui16_tim2_ticks; // save timertics since last hall event
 1542              		.loc 2 240 24
 1543 0092 934A     		ldr	r2, .L60+24
 1544 0094 FB89     		ldrh	r3, [r7, #14]	@ movhi
 1545 0096 1380     		strh	r3, [r2]	@ movhi
 241:Core/Src/motor.c **** 
 242:Core/Src/motor.c ****       // low pass filter ui16_halls_tim2tics
 243:Core/Src/motor.c **** 			static q31_t ui16_halls_tim2tics_acc = 128000; // start with near 0 angle
 244:Core/Src/motor.c ****       ui16_halls_tim2tics_acc -= ui16_halls_tim2tics_acc >> 3;
 1546              		.loc 2 244 31
 1547 0098 924B     		ldr	r3, .L60+28
 1548 009a 1A68     		ldr	r2, [r3]
 1549              		.loc 2 244 58
 1550 009c 914B     		ldr	r3, .L60+28
 1551 009e 1B68     		ldr	r3, [r3]
 1552 00a0 DB10     		asrs	r3, r3, #3
 1553              		.loc 2 244 31
 1554 00a2 D31A     		subs	r3, r2, r3
 1555 00a4 8F4A     		ldr	r2, .L60+28
 1556 00a6 1360     		str	r3, [r2]
 245:Core/Src/motor.c **** 			ui16_halls_tim2tics_acc += ui16_halls_tim2tics;
 1557              		.loc 2 245 28
 1558 00a8 8D4B     		ldr	r3, .L60+24
ARM GAS  /tmp/ccpEjOub.s 			page 127


 1559 00aa 1B88     		ldrh	r3, [r3]
 1560 00ac 1A46     		mov	r2, r3
 1561 00ae 8D4B     		ldr	r3, .L60+28
 1562 00b0 1B68     		ldr	r3, [r3]
 1563 00b2 1344     		add	r3, r3, r2
 1564 00b4 8B4A     		ldr	r2, .L60+28
 1565 00b6 1360     		str	r3, [r2]
 246:Core/Src/motor.c ****       ui16_halls_tim2tics_filtered = ui16_halls_tim2tics_acc >> 3;
 1566              		.loc 2 246 62
 1567 00b8 8A4B     		ldr	r3, .L60+28
 1568 00ba 1B68     		ldr	r3, [r3]
 1569 00bc DB10     		asrs	r3, r3, #3
 1570              		.loc 2 246 36
 1571 00be 9AB2     		uxth	r2, r3
 1572 00c0 894B     		ldr	r3, .L60+32
 1573 00c2 1A80     		strh	r2, [r3]	@ movhi
 247:Core/Src/motor.c **** 
 248:Core/Src/motor.c **** 			__HAL_TIM_SET_COUNTER(&htim2, 0); // reset tim2 counter
 1574              		.loc 2 248 4
 1575 00c4 854B     		ldr	r3, .L60+20
 1576 00c6 1B68     		ldr	r3, [r3]
 1577 00c8 0022     		movs	r2, #0
 1578 00ca 5A62     		str	r2, [r3, #36]
 249:Core/Src/motor.c **** 
 250:Core/Src/motor.c **** 			ui8_overflow_flag = false;
 1579              		.loc 2 250 22
 1580 00cc 874B     		ldr	r3, .L60+36
 1581 00ce 0022     		movs	r2, #0
 1582 00d0 1A70     		strb	r2, [r3]
 1583              	.L44:
 1584              	.LBE12:
 251:Core/Src/motor.c **** 		}
 252:Core/Src/motor.c **** 
 253:Core/Src/motor.c **** 		switch (ui8_hall_case) // 12 cases for each transition from one stage to the next. 6x forward, 6x
 1585              		.loc 2 253 3
 1586 00d2 804B     		ldr	r3, .L60+12
 1587 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1588 00d6 0D3B     		subs	r3, r3, #13
 1589 00d8 332B     		cmp	r3, #51
 1590 00da 00F23881 		bhi	.L45
 1591 00de 01A2     		adr	r2, .L47
 1592 00e0 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1593              		.p2align 2
 1594              	.L47:
 1595 00e4 0F020000 		.word	.L58+1
 1596 00e8 4F030000 		.word	.L45+1
 1597 00ec 1D030000 		.word	.L57+1
 1598 00f0 4F030000 		.word	.L45+1
 1599 00f4 4F030000 		.word	.L45+1
 1600 00f8 4F030000 		.word	.L45+1
 1601 00fc 4F030000 		.word	.L45+1
 1602 0100 4F030000 		.word	.L45+1
 1603 0104 4F030000 		.word	.L45+1
 1604 0108 4F030000 		.word	.L45+1
 1605 010c 95020000 		.word	.L56+1
 1606 0110 4F030000 		.word	.L45+1
 1607 0114 4F030000 		.word	.L45+1
ARM GAS  /tmp/ccpEjOub.s 			page 128


 1608 0118 4D020000 		.word	.L55+1
 1609 011c 4F030000 		.word	.L45+1
 1610 0120 4F030000 		.word	.L45+1
 1611 0124 4F030000 		.word	.L45+1
 1612 0128 4F030000 		.word	.L45+1
 1613 012c B1020000 		.word	.L54+1
 1614 0130 31020000 		.word	.L53+1
 1615 0134 4F030000 		.word	.L45+1
 1616 0138 4F030000 		.word	.L45+1
 1617 013c 4F030000 		.word	.L45+1
 1618 0140 4F030000 		.word	.L45+1
 1619 0144 4F030000 		.word	.L45+1
 1620 0148 4F030000 		.word	.L45+1
 1621 014c 4F030000 		.word	.L45+1
 1622 0150 4F030000 		.word	.L45+1
 1623 0154 4F030000 		.word	.L45+1
 1624 0158 4F030000 		.word	.L45+1
 1625 015c 4F030000 		.word	.L45+1
 1626 0160 4F030000 		.word	.L45+1
 1627 0164 D7010000 		.word	.L52+1
 1628 0168 69020000 		.word	.L51+1
 1629 016c 4F030000 		.word	.L45+1
 1630 0170 4F030000 		.word	.L45+1
 1631 0174 4F030000 		.word	.L45+1
 1632 0178 4F030000 		.word	.L45+1
 1633 017c F3010000 		.word	.L50+1
 1634 0180 4F030000 		.word	.L45+1
 1635 0184 4F030000 		.word	.L45+1
 1636 0188 33030000 		.word	.L49+1
 1637 018c 4F030000 		.word	.L45+1
 1638 0190 4F030000 		.word	.L45+1
 1639 0194 4F030000 		.word	.L45+1
 1640 0198 4F030000 		.word	.L45+1
 1641 019c 4F030000 		.word	.L45+1
 1642 01a0 4F030000 		.word	.L45+1
 1643 01a4 4F030000 		.word	.L45+1
 1644 01a8 7F020000 		.word	.L48+1
 1645 01ac 4F030000 		.word	.L45+1
 1646 01b0 B5010000 		.word	.L46+1
 1647              		.p2align 1
 1648              	.L46:
 254:Core/Src/motor.c **** 		{
 255:Core/Src/motor.c ****       // 6 cases for forward direction
 256:Core/Src/motor.c ****       case 64:
 257:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_64;
 1649              		.loc 2 257 32
 1650 01b4 4E4B     		ldr	r3, .L60+40
 1651 01b6 1B68     		ldr	r3, [r3]
 1652 01b8 4E4A     		ldr	r2, .L60+44
 1653 01ba 1360     		str	r3, [r2]
 258:Core/Src/motor.c ****         i8_recent_rotor_direction = -i16_hall_order;
 1654              		.loc 2 258 35
 1655 01bc 4E4B     		ldr	r3, .L60+48
 1656 01be B3F90030 		ldrsh	r3, [r3]
 1657 01c2 DBB2     		uxtb	r3, r3
 1658 01c4 5B42     		rsbs	r3, r3, #0
 1659 01c6 DBB2     		uxtb	r3, r3
ARM GAS  /tmp/ccpEjOub.s 			page 129


 1660 01c8 5AB2     		sxtb	r2, r3
 1661 01ca 4C4B     		ldr	r3, .L60+52
 1662 01cc 1A70     		strb	r2, [r3]
 259:Core/Src/motor.c ****         uint16_full_rotation_counter = 0;
 1663              		.loc 2 259 38
 1664 01ce 4C4B     		ldr	r3, .L60+56
 1665 01d0 0022     		movs	r2, #0
 1666 01d2 1A80     		strh	r2, [r3]	@ movhi
 260:Core/Src/motor.c ****         break;
 1667              		.loc 2 260 9
 1668 01d4 BBE0     		b	.L45
 1669              	.L52:
 261:Core/Src/motor.c **** 
 262:Core/Src/motor.c ****       case 45:
 263:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_45;
 1670              		.loc 2 263 32
 1671 01d6 4B4B     		ldr	r3, .L60+60
 1672 01d8 1B68     		ldr	r3, [r3]
 1673 01da 464A     		ldr	r2, .L60+44
 1674 01dc 1360     		str	r3, [r2]
 264:Core/Src/motor.c ****         i8_recent_rotor_direction = -i16_hall_order;
 1675              		.loc 2 264 35
 1676 01de 464B     		ldr	r3, .L60+48
 1677 01e0 B3F90030 		ldrsh	r3, [r3]
 1678 01e4 DBB2     		uxtb	r3, r3
 1679 01e6 5B42     		rsbs	r3, r3, #0
 1680 01e8 DBB2     		uxtb	r3, r3
 1681 01ea 5AB2     		sxtb	r2, r3
 1682 01ec 434B     		ldr	r3, .L60+52
 1683 01ee 1A70     		strb	r2, [r3]
 265:Core/Src/motor.c ****         break;
 1684              		.loc 2 265 9
 1685 01f0 ADE0     		b	.L45
 1686              	.L50:
 266:Core/Src/motor.c **** 
 267:Core/Src/motor.c ****       case 51:
 268:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_51;
 1687              		.loc 2 268 32
 1688 01f2 454B     		ldr	r3, .L60+64
 1689 01f4 1B68     		ldr	r3, [r3]
 1690 01f6 3F4A     		ldr	r2, .L60+44
 1691 01f8 1360     		str	r3, [r2]
 269:Core/Src/motor.c ****         i8_recent_rotor_direction = -i16_hall_order;
 1692              		.loc 2 269 35
 1693 01fa 3F4B     		ldr	r3, .L60+48
 1694 01fc B3F90030 		ldrsh	r3, [r3]
 1695 0200 DBB2     		uxtb	r3, r3
 1696 0202 5B42     		rsbs	r3, r3, #0
 1697 0204 DBB2     		uxtb	r3, r3
 1698 0206 5AB2     		sxtb	r2, r3
 1699 0208 3C4B     		ldr	r3, .L60+52
 1700 020a 1A70     		strb	r2, [r3]
 270:Core/Src/motor.c ****         break;
 1701              		.loc 2 270 9
 1702 020c 9FE0     		b	.L45
 1703              	.L58:
 271:Core/Src/motor.c **** 
ARM GAS  /tmp/ccpEjOub.s 			page 130


 272:Core/Src/motor.c ****       case 13:
 273:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_13;
 1704              		.loc 2 273 32
 1705 020e 3F4B     		ldr	r3, .L60+68
 1706 0210 1B68     		ldr	r3, [r3]
 1707 0212 384A     		ldr	r2, .L60+44
 1708 0214 1360     		str	r3, [r2]
 274:Core/Src/motor.c ****         i8_recent_rotor_direction = -i16_hall_order;
 1709              		.loc 2 274 35
 1710 0216 384B     		ldr	r3, .L60+48
 1711 0218 B3F90030 		ldrsh	r3, [r3]
 1712 021c DBB2     		uxtb	r3, r3
 1713 021e 5B42     		rsbs	r3, r3, #0
 1714 0220 DBB2     		uxtb	r3, r3
 1715 0222 5AB2     		sxtb	r2, r3
 1716 0224 354B     		ldr	r3, .L60+52
 1717 0226 1A70     		strb	r2, [r3]
 275:Core/Src/motor.c ****         uint16_half_rotation_counter = 0;
 1718              		.loc 2 275 38
 1719 0228 394B     		ldr	r3, .L60+72
 1720 022a 0022     		movs	r2, #0
 1721 022c 1A80     		strh	r2, [r3]	@ movhi
 276:Core/Src/motor.c ****         break;
 1722              		.loc 2 276 9
 1723 022e 8EE0     		b	.L45
 1724              	.L53:
 277:Core/Src/motor.c **** 
 278:Core/Src/motor.c ****       case 32:
 279:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_32;
 1725              		.loc 2 279 32
 1726 0230 384B     		ldr	r3, .L60+76
 1727 0232 1B68     		ldr	r3, [r3]
 1728 0234 2F4A     		ldr	r2, .L60+44
 1729 0236 1360     		str	r3, [r2]
 280:Core/Src/motor.c ****         i8_recent_rotor_direction = -i16_hall_order;
 1730              		.loc 2 280 35
 1731 0238 2F4B     		ldr	r3, .L60+48
 1732 023a B3F90030 		ldrsh	r3, [r3]
 1733 023e DBB2     		uxtb	r3, r3
 1734 0240 5B42     		rsbs	r3, r3, #0
 1735 0242 DBB2     		uxtb	r3, r3
 1736 0244 5AB2     		sxtb	r2, r3
 1737 0246 2D4B     		ldr	r3, .L60+52
 1738 0248 1A70     		strb	r2, [r3]
 281:Core/Src/motor.c ****         break;
 1739              		.loc 2 281 9
 1740 024a 80E0     		b	.L45
 1741              	.L55:
 282:Core/Src/motor.c **** 
 283:Core/Src/motor.c ****       case 26:
 284:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_26;
 1742              		.loc 2 284 32
 1743 024c 324B     		ldr	r3, .L60+80
 1744 024e 1B68     		ldr	r3, [r3]
 1745 0250 284A     		ldr	r2, .L60+44
 1746 0252 1360     		str	r3, [r2]
 285:Core/Src/motor.c ****         i8_recent_rotor_direction = -i16_hall_order;
ARM GAS  /tmp/ccpEjOub.s 			page 131


 1747              		.loc 2 285 35
 1748 0254 284B     		ldr	r3, .L60+48
 1749 0256 B3F90030 		ldrsh	r3, [r3]
 1750 025a DBB2     		uxtb	r3, r3
 1751 025c 5B42     		rsbs	r3, r3, #0
 1752 025e DBB2     		uxtb	r3, r3
 1753 0260 5AB2     		sxtb	r2, r3
 1754 0262 264B     		ldr	r3, .L60+52
 1755 0264 1A70     		strb	r2, [r3]
 286:Core/Src/motor.c ****         break;
 1756              		.loc 2 286 9
 1757 0266 72E0     		b	.L45
 1758              	.L51:
 287:Core/Src/motor.c **** 
 288:Core/Src/motor.c ****       // 6 cases for reverse direction
 289:Core/Src/motor.c ****       case 46:
 290:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_64;
 1759              		.loc 2 290 32
 1760 0268 214B     		ldr	r3, .L60+40
 1761 026a 1B68     		ldr	r3, [r3]
 1762 026c 214A     		ldr	r2, .L60+44
 1763 026e 1360     		str	r3, [r2]
 291:Core/Src/motor.c ****         i8_recent_rotor_direction = i16_hall_order;
 1764              		.loc 2 291 35
 1765 0270 214B     		ldr	r3, .L60+48
 1766 0272 B3F90030 		ldrsh	r3, [r3]
 1767 0276 5AB2     		sxtb	r2, r3
 1768 0278 204B     		ldr	r3, .L60+52
 1769 027a 1A70     		strb	r2, [r3]
 292:Core/Src/motor.c ****         break;
 1770              		.loc 2 292 9
 1771 027c 67E0     		b	.L45
 1772              	.L48:
 293:Core/Src/motor.c **** 
 294:Core/Src/motor.c ****       case 62:
 295:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_26;
 1773              		.loc 2 295 32
 1774 027e 264B     		ldr	r3, .L60+80
 1775 0280 1B68     		ldr	r3, [r3]
 1776 0282 1C4A     		ldr	r2, .L60+44
 1777 0284 1360     		str	r3, [r2]
 296:Core/Src/motor.c ****         i8_recent_rotor_direction = i16_hall_order;
 1778              		.loc 2 296 35
 1779 0286 1C4B     		ldr	r3, .L60+48
 1780 0288 B3F90030 		ldrsh	r3, [r3]
 1781 028c 5AB2     		sxtb	r2, r3
 1782 028e 1B4B     		ldr	r3, .L60+52
 1783 0290 1A70     		strb	r2, [r3]
 297:Core/Src/motor.c ****         break;
 1784              		.loc 2 297 9
 1785 0292 5CE0     		b	.L45
 1786              	.L56:
 298:Core/Src/motor.c **** 
 299:Core/Src/motor.c ****       case 23:
 300:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_32;
 1787              		.loc 2 300 32
 1788 0294 1F4B     		ldr	r3, .L60+76
ARM GAS  /tmp/ccpEjOub.s 			page 132


 1789 0296 1B68     		ldr	r3, [r3]
 1790 0298 164A     		ldr	r2, .L60+44
 1791 029a 1360     		str	r3, [r2]
 301:Core/Src/motor.c ****         i8_recent_rotor_direction = i16_hall_order;
 1792              		.loc 2 301 35
 1793 029c 164B     		ldr	r3, .L60+48
 1794 029e B3F90030 		ldrsh	r3, [r3]
 1795 02a2 5AB2     		sxtb	r2, r3
 1796 02a4 154B     		ldr	r3, .L60+52
 1797 02a6 1A70     		strb	r2, [r3]
 302:Core/Src/motor.c ****         uint16_half_rotation_counter = 0;
 1798              		.loc 2 302 38
 1799 02a8 194B     		ldr	r3, .L60+72
 1800 02aa 0022     		movs	r2, #0
 1801 02ac 1A80     		strh	r2, [r3]	@ movhi
 303:Core/Src/motor.c ****         break;
 1802              		.loc 2 303 9
 1803 02ae 4EE0     		b	.L45
 1804              	.L54:
 304:Core/Src/motor.c **** 
 305:Core/Src/motor.c ****       case 31:
 306:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_13;
 1805              		.loc 2 306 32
 1806 02b0 164B     		ldr	r3, .L60+68
 1807 02b2 1B68     		ldr	r3, [r3]
 1808 02b4 0F4A     		ldr	r2, .L60+44
 1809 02b6 1360     		str	r3, [r2]
 307:Core/Src/motor.c ****         i8_recent_rotor_direction = i16_hall_order;
 1810              		.loc 2 307 35
 1811 02b8 0F4B     		ldr	r3, .L60+48
 1812 02ba B3F90030 		ldrsh	r3, [r3]
 1813 02be 5AB2     		sxtb	r2, r3
 1814 02c0 0E4B     		ldr	r3, .L60+52
 1815 02c2 1A70     		strb	r2, [r3]
 308:Core/Src/motor.c ****         break;
 1816              		.loc 2 308 9
 1817 02c4 43E0     		b	.L45
 1818              	.L61:
 1819 02c6 00BF     		.align	2
 1820              	.L60:
 1821 02c8 000C0140 		.word	1073810432
 1822 02cc 00000000 		.word	ui8_hall_state
 1823 02d0 00000000 		.word	ui8_hall_state_old
 1824 02d4 00000000 		.word	ui8_hall_case
 1825 02d8 00000000 		.word	MS
 1826 02dc 00000000 		.word	htim2
 1827 02e0 00000000 		.word	ui16_halls_tim2tics
 1828 02e4 00000000 		.word	ui16_halls_tim2tics_acc.10010
 1829 02e8 00000000 		.word	ui16_halls_tim2tics_filtered
 1830 02ec 00000000 		.word	ui8_overflow_flag
 1831 02f0 00000000 		.word	Hall_64
 1832 02f4 00000000 		.word	q31_rotorposition_hall
 1833 02f8 00000000 		.word	i16_hall_order
 1834 02fc 00000000 		.word	i8_recent_rotor_direction
 1835 0300 00000000 		.word	uint16_full_rotation_counter
 1836 0304 00000000 		.word	Hall_45
 1837 0308 00000000 		.word	Hall_51
ARM GAS  /tmp/ccpEjOub.s 			page 133


 1838 030c 00000000 		.word	Hall_13
 1839 0310 00000000 		.word	uint16_half_rotation_counter
 1840 0314 00000000 		.word	Hall_32
 1841 0318 00000000 		.word	Hall_26
 1842              	.L57:
 309:Core/Src/motor.c **** 
 310:Core/Src/motor.c ****       case 15:
 311:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_51;
 1843              		.loc 2 311 32
 1844 031c 1A4B     		ldr	r3, .L62
 1845 031e 1B68     		ldr	r3, [r3]
 1846 0320 1A4A     		ldr	r2, .L62+4
 1847 0322 1360     		str	r3, [r2]
 312:Core/Src/motor.c ****         i8_recent_rotor_direction = i16_hall_order;
 1848              		.loc 2 312 35
 1849 0324 1A4B     		ldr	r3, .L62+8
 1850 0326 B3F90030 		ldrsh	r3, [r3]
 1851 032a 5AB2     		sxtb	r2, r3
 1852 032c 194B     		ldr	r3, .L62+12
 1853 032e 1A70     		strb	r2, [r3]
 313:Core/Src/motor.c ****         break;
 1854              		.loc 2 313 9
 1855 0330 0DE0     		b	.L45
 1856              	.L49:
 314:Core/Src/motor.c **** 
 315:Core/Src/motor.c ****       case 54:
 316:Core/Src/motor.c ****         q31_rotorposition_hall = Hall_45;
 1857              		.loc 2 316 32
 1858 0332 194B     		ldr	r3, .L62+16
 1859 0334 1B68     		ldr	r3, [r3]
 1860 0336 154A     		ldr	r2, .L62+4
 1861 0338 1360     		str	r3, [r2]
 317:Core/Src/motor.c ****         i8_recent_rotor_direction = i16_hall_order;
 1862              		.loc 2 317 35
 1863 033a 154B     		ldr	r3, .L62+8
 1864 033c B3F90030 		ldrsh	r3, [r3]
 1865 0340 5AB2     		sxtb	r2, r3
 1866 0342 144B     		ldr	r3, .L62+12
 1867 0344 1A70     		strb	r2, [r3]
 318:Core/Src/motor.c ****         uint16_full_rotation_counter = 0;
 1868              		.loc 2 318 38
 1869 0346 154B     		ldr	r3, .L62+20
 1870 0348 0022     		movs	r2, #0
 1871 034a 1A80     		strh	r2, [r3]	@ movhi
 319:Core/Src/motor.c ****         break;
 1872              		.loc 2 319 9
 1873 034c 00BF     		nop
 1874              	.L45:
 320:Core/Src/motor.c **** 		}
 321:Core/Src/motor.c **** 
 322:Core/Src/motor.c ****     if (MS.angle_estimation == SPEED_PLL) {
 1875              		.loc 2 322 11
 1876 034e 144B     		ldr	r3, .L62+24
 1877 0350 93F83330 		ldrb	r3, [r3, #51]	@ zero_extendqisi2
 1878              		.loc 2 322 8
 1879 0354 012B     		cmp	r3, #1
 1880 0356 13D1     		bne	.L39
ARM GAS  /tmp/ccpEjOub.s 			page 134


 323:Core/Src/motor.c ****       q31_PLL_error = q31_rotorposition_PLL - q31_rotorposition_hall;
 1881              		.loc 2 323 45
 1882 0358 124B     		ldr	r3, .L62+28
 1883 035a 1A68     		ldr	r2, [r3]
 1884 035c 0B4B     		ldr	r3, .L62+4
 1885 035e 1B68     		ldr	r3, [r3]
 1886 0360 D31A     		subs	r3, r2, r3
 1887              		.loc 2 323 21
 1888 0362 114A     		ldr	r2, .L62+32
 1889 0364 1360     		str	r3, [r2]
 324:Core/Src/motor.c **** 		  q31_angle_per_tic = speed_PLL(q31_rotorposition_PLL, q31_rotorposition_hall);
 1890              		.loc 2 324 25
 1891 0366 0F4B     		ldr	r3, .L62+28
 1892 0368 1B68     		ldr	r3, [r3]
 1893 036a 084A     		ldr	r2, .L62+4
 1894 036c 1268     		ldr	r2, [r2]
 1895 036e 1146     		mov	r1, r2
 1896 0370 1846     		mov	r0, r3
 1897 0372 FFF7FEFF 		bl	speed_PLL
 1898 0376 0346     		mov	r3, r0
 1899              		.loc 2 324 23
 1900 0378 0C4A     		ldr	r2, .L62+36
 1901 037a 1360     		str	r3, [r2]
 1902 037c 00E0     		b	.L39
 1903              	.L59:
 226:Core/Src/motor.c **** 
 1904              		.loc 2 226 4
 1905 037e 00BF     		nop
 1906              	.L39:
 1907              	.LBE11:
 325:Core/Src/motor.c ****     }
 326:Core/Src/motor.c **** 	}
 327:Core/Src/motor.c **** }
 1908              		.loc 2 327 1
 1909 0380 1037     		adds	r7, r7, #16
 1910              	.LCFI65:
 1911              		.cfi_def_cfa_offset 8
 1912 0382 BD46     		mov	sp, r7
 1913              	.LCFI66:
 1914              		.cfi_def_cfa_register 13
 1915              		@ sp needed
 1916 0384 80BD     		pop	{r7, pc}
 1917              	.L63:
 1918 0386 00BF     		.align	2
 1919              	.L62:
 1920 0388 00000000 		.word	Hall_51
 1921 038c 00000000 		.word	q31_rotorposition_hall
 1922 0390 00000000 		.word	i16_hall_order
 1923 0394 00000000 		.word	i8_recent_rotor_direction
 1924 0398 00000000 		.word	Hall_45
 1925 039c 00000000 		.word	uint16_full_rotation_counter
 1926 03a0 00000000 		.word	MS
 1927 03a4 00000000 		.word	q31_rotorposition_PLL
 1928 03a8 00000000 		.word	q31_PLL_error
 1929 03ac 00000000 		.word	q31_angle_per_tic
 1930              		.cfi_endproc
 1931              	.LFE127:
ARM GAS  /tmp/ccpEjOub.s 			page 135


 1933              		.section	.text.get_standstill_position,"ax",%progbits
 1934              		.align	1
 1935              		.global	get_standstill_position
 1936              		.syntax unified
 1937              		.thumb
 1938              		.thumb_func
 1939              		.fpu softvfp
 1941              	get_standstill_position:
 1942              	.LFB128:
 328:Core/Src/motor.c **** 
 329:Core/Src/motor.c **** void get_standstill_position() {
 1943              		.loc 2 329 32
 1944              		.cfi_startproc
 1945              		@ args = 0, pretend = 0, frame = 0
 1946              		@ frame_needed = 1, uses_anonymous_args = 0
 1947 0000 80B5     		push	{r7, lr}
 1948              	.LCFI67:
 1949              		.cfi_def_cfa_offset 8
 1950              		.cfi_offset 7, -8
 1951              		.cfi_offset 14, -4
 1952 0002 00AF     		add	r7, sp, #0
 1953              	.LCFI68:
 1954              		.cfi_def_cfa_register 7
 330:Core/Src/motor.c **** 	// HAL_Delay(100); // will BLOCK because it is called inside systick interrupt
 331:Core/Src/motor.c **** 	HAL_GPIO_EXTI_Callback(GPIO_PIN_4); // read in initial rotor position
 1955              		.loc 2 331 2
 1956 0004 1020     		movs	r0, #16
 1957 0006 FFF7FEFF 		bl	HAL_GPIO_EXTI_Callback
 332:Core/Src/motor.c **** 
 333:Core/Src/motor.c **** 	switch (ui8_hall_state) {
 1958              		.loc 2 333 2
 1959 000a 1C4B     		ldr	r3, .L73
 1960 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1961 000e 013B     		subs	r3, r3, #1
 1962 0010 052B     		cmp	r3, #5
 1963 0012 2DD8     		bhi	.L65
 1964 0014 01A2     		adr	r2, .L67
 1965 0016 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1966 001a 00BF     		.p2align 2
 1967              	.L67:
 1968 001c 5D000000 		.word	.L72+1
 1969 0020 35000000 		.word	.L71+1
 1970 0024 67000000 		.word	.L70+1
 1971 0028 49000000 		.word	.L69+1
 1972 002c 53000000 		.word	.L68+1
 1973 0030 3F000000 		.word	.L66+1
 1974              		.p2align 1
 1975              	.L71:
 334:Core/Src/motor.c ****     // 6 cases for forward direction
 335:Core/Src/motor.c ****     case 2:
 336:Core/Src/motor.c ****       q31_rotorposition_hall = Hall_32;
 1976              		.loc 2 336 30
 1977 0034 124B     		ldr	r3, .L73+4
 1978 0036 1B68     		ldr	r3, [r3]
 1979 0038 124A     		ldr	r2, .L73+8
 1980 003a 1360     		str	r3, [r2]
 337:Core/Src/motor.c ****       break;
ARM GAS  /tmp/ccpEjOub.s 			page 136


 1981              		.loc 2 337 7
 1982 003c 18E0     		b	.L65
 1983              	.L66:
 338:Core/Src/motor.c **** 
 339:Core/Src/motor.c ****     case 6:
 340:Core/Src/motor.c ****       q31_rotorposition_hall = Hall_26;
 1984              		.loc 2 340 30
 1985 003e 124B     		ldr	r3, .L73+12
 1986 0040 1B68     		ldr	r3, [r3]
 1987 0042 104A     		ldr	r2, .L73+8
 1988 0044 1360     		str	r3, [r2]
 341:Core/Src/motor.c ****       break;
 1989              		.loc 2 341 7
 1990 0046 13E0     		b	.L65
 1991              	.L69:
 342:Core/Src/motor.c **** 
 343:Core/Src/motor.c ****     case 4:
 344:Core/Src/motor.c ****       q31_rotorposition_hall = Hall_64;
 1992              		.loc 2 344 30
 1993 0048 104B     		ldr	r3, .L73+16
 1994 004a 1B68     		ldr	r3, [r3]
 1995 004c 0D4A     		ldr	r2, .L73+8
 1996 004e 1360     		str	r3, [r2]
 345:Core/Src/motor.c ****       break;
 1997              		.loc 2 345 7
 1998 0050 0EE0     		b	.L65
 1999              	.L68:
 346:Core/Src/motor.c **** 
 347:Core/Src/motor.c ****     case 5:
 348:Core/Src/motor.c ****       q31_rotorposition_hall = Hall_45;
 2000              		.loc 2 348 30
 2001 0052 0F4B     		ldr	r3, .L73+20
 2002 0054 1B68     		ldr	r3, [r3]
 2003 0056 0B4A     		ldr	r2, .L73+8
 2004 0058 1360     		str	r3, [r2]
 349:Core/Src/motor.c ****       break;
 2005              		.loc 2 349 7
 2006 005a 09E0     		b	.L65
 2007              	.L72:
 350:Core/Src/motor.c **** 
 351:Core/Src/motor.c ****     case 1:
 352:Core/Src/motor.c ****       q31_rotorposition_hall = Hall_51;
 2008              		.loc 2 352 30
 2009 005c 0D4B     		ldr	r3, .L73+24
 2010 005e 1B68     		ldr	r3, [r3]
 2011 0060 084A     		ldr	r2, .L73+8
 2012 0062 1360     		str	r3, [r2]
 353:Core/Src/motor.c ****       break;
 2013              		.loc 2 353 7
 2014 0064 04E0     		b	.L65
 2015              	.L70:
 354:Core/Src/motor.c **** 
 355:Core/Src/motor.c ****     case 3:
 356:Core/Src/motor.c ****       q31_rotorposition_hall = Hall_13;
 2016              		.loc 2 356 30
 2017 0066 0C4B     		ldr	r3, .L73+28
 2018 0068 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccpEjOub.s 			page 137


 2019 006a 064A     		ldr	r2, .L73+8
 2020 006c 1360     		str	r3, [r2]
 357:Core/Src/motor.c ****       break;
 2021              		.loc 2 357 7
 2022 006e 00BF     		nop
 2023              	.L65:
 358:Core/Src/motor.c ****     }
 359:Core/Src/motor.c **** 
 360:Core/Src/motor.c **** 	q31_rotorposition_absolute = q31_rotorposition_hall;
 2024              		.loc 2 360 29
 2025 0070 044B     		ldr	r3, .L73+8
 2026 0072 1B68     		ldr	r3, [r3]
 2027 0074 094A     		ldr	r2, .L73+32
 2028 0076 1360     		str	r3, [r2]
 361:Core/Src/motor.c **** }
 2029              		.loc 2 361 1
 2030 0078 00BF     		nop
 2031 007a 80BD     		pop	{r7, pc}
 2032              	.L74:
 2033              		.align	2
 2034              	.L73:
 2035 007c 00000000 		.word	ui8_hall_state
 2036 0080 00000000 		.word	Hall_32
 2037 0084 00000000 		.word	q31_rotorposition_hall
 2038 0088 00000000 		.word	Hall_26
 2039 008c 00000000 		.word	Hall_64
 2040 0090 00000000 		.word	Hall_45
 2041 0094 00000000 		.word	Hall_51
 2042 0098 00000000 		.word	Hall_13
 2043 009c 00000000 		.word	q31_rotorposition_absolute
 2044              		.cfi_endproc
 2045              	.LFE128:
 2047              		.section	.text.speed_to_tics,"ax",%progbits
 2048              		.align	1
 2049              		.global	speed_to_tics
 2050              		.syntax unified
 2051              		.thumb
 2052              		.thumb_func
 2053              		.fpu softvfp
 2055              	speed_to_tics:
 2056              	.LFB129:
 362:Core/Src/motor.c **** 
 363:Core/Src/motor.c **** int32_t speed_to_tics(uint8_t speed) {
 2057              		.loc 2 363 38
 2058              		.cfi_startproc
 2059              		@ args = 0, pretend = 0, frame = 8
 2060              		@ frame_needed = 1, uses_anonymous_args = 0
 2061              		@ link register save eliminated.
 2062 0000 80B4     		push	{r7}
 2063              	.LCFI69:
 2064              		.cfi_def_cfa_offset 4
 2065              		.cfi_offset 7, -4
 2066 0002 83B0     		sub	sp, sp, #12
 2067              	.LCFI70:
 2068              		.cfi_def_cfa_offset 16
 2069 0004 00AF     		add	r7, sp, #0
 2070              	.LCFI71:
ARM GAS  /tmp/ccpEjOub.s 			page 138


 2071              		.cfi_def_cfa_register 7
 2072 0006 0346     		mov	r3, r0
 2073 0008 FB71     		strb	r3, [r7, #7]
 364:Core/Src/motor.c **** 	return WHEEL_CIRCUMFERENCE * 5 * 3600 / (6 * GEAR_RATIO * speed * 10);
 2074              		.loc 2 364 66
 2075 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2076 000c 4FF46172 		mov	r2, #900
 2077 0010 02FB03F3 		mul	r3, r2, r3
 2078              		.loc 2 364 40
 2079 0014 034A     		ldr	r2, .L77
 2080 0016 92FBF3F3 		sdiv	r3, r2, r3
 365:Core/Src/motor.c **** }
 2081              		.loc 2 365 1
 2082 001a 1846     		mov	r0, r3
 2083 001c 0C37     		adds	r7, r7, #12
 2084              	.LCFI72:
 2085              		.cfi_def_cfa_offset 4
 2086 001e BD46     		mov	sp, r7
 2087              	.LCFI73:
 2088              		.cfi_def_cfa_register 13
 2089              		@ sp needed
 2090 0020 80BC     		pop	{r7}
 2091              	.LCFI74:
 2092              		.cfi_restore 7
 2093              		.cfi_def_cfa_offset 0
 2094 0022 7047     		bx	lr
 2095              	.L78:
 2096              		.align	2
 2097              	.L77:
 2098 0024 A083BD00 		.word	12420000
 2099              		.cfi_endproc
 2100              	.LFE129:
 2102              		.section	.text.tics_to_speed,"ax",%progbits
 2103              		.align	1
 2104              		.global	tics_to_speed
 2105              		.syntax unified
 2106              		.thumb
 2107              		.thumb_func
 2108              		.fpu softvfp
 2110              	tics_to_speed:
 2111              	.LFB130:
 366:Core/Src/motor.c **** 
 367:Core/Src/motor.c **** int8_t tics_to_speed(uint32_t tics) {
 2112              		.loc 2 367 37
 2113              		.cfi_startproc
 2114              		@ args = 0, pretend = 0, frame = 8
 2115              		@ frame_needed = 1, uses_anonymous_args = 0
 2116              		@ link register save eliminated.
 2117 0000 80B4     		push	{r7}
 2118              	.LCFI75:
 2119              		.cfi_def_cfa_offset 4
 2120              		.cfi_offset 7, -4
 2121 0002 83B0     		sub	sp, sp, #12
 2122              	.LCFI76:
 2123              		.cfi_def_cfa_offset 16
 2124 0004 00AF     		add	r7, sp, #0
 2125              	.LCFI77:
ARM GAS  /tmp/ccpEjOub.s 			page 139


 2126              		.cfi_def_cfa_register 7
 2127 0006 7860     		str	r0, [r7, #4]
 368:Core/Src/motor.c **** 	return WHEEL_CIRCUMFERENCE * 5 * 3600 / (6 * GEAR_RATIO * tics * 10);;
 2128              		.loc 2 368 65
 2129 0008 7B68     		ldr	r3, [r7, #4]
 2130 000a 4FF46172 		mov	r2, #900
 2131 000e 02FB03F3 		mul	r3, r2, r3
 2132              		.loc 2 368 40
 2133 0012 044A     		ldr	r2, .L81
 2134 0014 B2FBF3F3 		udiv	r3, r2, r3
 2135 0018 5BB2     		sxtb	r3, r3
 369:Core/Src/motor.c **** }
 2136              		.loc 2 369 1
 2137 001a 1846     		mov	r0, r3
 2138 001c 0C37     		adds	r7, r7, #12
 2139              	.LCFI78:
 2140              		.cfi_def_cfa_offset 4
 2141 001e BD46     		mov	sp, r7
 2142              	.LCFI79:
 2143              		.cfi_def_cfa_register 13
 2144              		@ sp needed
 2145 0020 80BC     		pop	{r7}
 2146              	.LCFI80:
 2147              		.cfi_restore 7
 2148              		.cfi_def_cfa_offset 0
 2149 0022 7047     		bx	lr
 2150              	.L82:
 2151              		.align	2
 2152              	.L81:
 2153 0024 A083BD00 		.word	12420000
 2154              		.cfi_endproc
 2155              	.LFE130:
 2157              		.section	.text.motor_autodetect,"ax",%progbits
 2158              		.align	1
 2159              		.global	motor_autodetect
 2160              		.syntax unified
 2161              		.thumb
 2162              		.thumb_func
 2163              		.fpu softvfp
 2165              	motor_autodetect:
 2166              	.LFB131:
 370:Core/Src/motor.c **** 
 371:Core/Src/motor.c **** void motor_autodetect() {
 2167              		.loc 2 371 25
 2168              		.cfi_startproc
 2169              		@ args = 0, pretend = 0, frame = 8
 2170              		@ frame_needed = 1, uses_anonymous_args = 0
 2171 0000 80B5     		push	{r7, lr}
 2172              	.LCFI81:
 2173              		.cfi_def_cfa_offset 8
 2174              		.cfi_offset 7, -8
 2175              		.cfi_offset 14, -4
 2176 0002 82B0     		sub	sp, sp, #8
 2177              	.LCFI82:
 2178              		.cfi_def_cfa_offset 16
 2179 0004 00AF     		add	r7, sp, #0
 2180              	.LCFI83:
ARM GAS  /tmp/ccpEjOub.s 			page 140


 2181              		.cfi_def_cfa_register 7
 372:Core/Src/motor.c **** 	enable_pwm();
 2182              		.loc 2 372 2
 2183 0006 FFF7FEFF 		bl	enable_pwm
 373:Core/Src/motor.c **** 	MS.hall_angle_detect_flag = true;
 2184              		.loc 2 373 28
 2185 000a AF4B     		ldr	r3, .L103
 2186 000c 0122     		movs	r2, #1
 2187 000e 83F83620 		strb	r2, [r3, #54]
 374:Core/Src/motor.c **** 	q31_rotorposition_absolute = 1 << 31;
 2188              		.loc 2 374 29
 2189 0012 AE4B     		ldr	r3, .L103+4
 2190 0014 4FF00042 		mov	r2, #-2147483648
 2191 0018 1A60     		str	r2, [r3]
 375:Core/Src/motor.c ****   i16_hall_order = 1; // reset hall order
 2192              		.loc 2 375 18
 2193 001a AD4B     		ldr	r3, .L103+8
 2194 001c 0122     		movs	r2, #1
 2195 001e 1A80     		strh	r2, [r3]	@ movhi
 376:Core/Src/motor.c ****   MS.i_d_setpoint = 200; // set MS.id to appr. 2000mA
 2196              		.loc 2 376 19
 2197 0020 A94B     		ldr	r3, .L103
 2198 0022 C822     		movs	r2, #200
 2199 0024 DA60     		str	r2, [r3, #12]
 377:Core/Src/motor.c **** 	MS.i_q_setpoint = 1;
 2200              		.loc 2 377 18
 2201 0026 A84B     		ldr	r3, .L103
 2202 0028 0122     		movs	r2, #1
 2203 002a 9A60     		str	r2, [r3, #8]
 378:Core/Src/motor.c **** 
 379:Core/Src/motor.c **** 	HAL_Delay(5);
 2204              		.loc 2 379 2
 2205 002c 0520     		movs	r0, #5
 2206 002e FFF7FEFF 		bl	HAL_Delay
 2207              	.LBB13:
 380:Core/Src/motor.c **** 	for (uint32_t i = 0; i < 1080; i++) { // 1080 = 360 * 3, 3 turns, just to make sure at least a ful
 2208              		.loc 2 380 16
 2209 0032 0023     		movs	r3, #0
 2210 0034 7B60     		str	r3, [r7, #4]
 2211              		.loc 2 380 2
 2212 0036 C6E0     		b	.L84
 2213              	.L100:
 381:Core/Src/motor.c **** 
 382:Core/Src/motor.c **** 		q31_rotorposition_absolute += 11930465; //drive motor in open loop with steps of 1 degree
 2214              		.loc 2 382 30
 2215 0038 A44B     		ldr	r3, .L103+4
 2216 003a 1B68     		ldr	r3, [r3]
 2217 003c 03F53603 		add	r3, r3, #11927552
 2218 0040 03F66133 		addw	r3, r3, #2913
 2219 0044 A14A     		ldr	r2, .L103+4
 2220 0046 1360     		str	r3, [r2]
 383:Core/Src/motor.c ****     HAL_Delay(5);
 2221              		.loc 2 383 5
 2222 0048 0520     		movs	r0, #5
 2223 004a FFF7FEFF 		bl	HAL_Delay
 384:Core/Src/motor.c **** 
 385:Core/Src/motor.c **** 		if (ui8_hall_state_old != ui8_hall_state) {
ARM GAS  /tmp/ccpEjOub.s 			page 141


 2224              		.loc 2 385 26
 2225 004e A14B     		ldr	r3, .L103+12
 2226 0050 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2227 0052 A14B     		ldr	r3, .L103+16
 2228 0054 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2229              		.loc 2 385 6
 2230 0056 9A42     		cmp	r2, r3
 2231 0058 00F0B280 		beq	.L85
 386:Core/Src/motor.c **** 
 387:Core/Src/motor.c **** 	    switch (ui8_hall_case) // 12 cases for each transition from one stage to the next. 6x forward,
 2232              		.loc 2 387 6
 2233 005c 9F4B     		ldr	r3, .L103+20
 2234 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2235 0060 0D3B     		subs	r3, r3, #13
 2236 0062 332B     		cmp	r3, #51
 2237 0064 00F2A880 		bhi	.L86
 2238 0068 01A2     		adr	r2, .L88
 2239 006a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 2240 006e 00BF     		.p2align 2
 2241              	.L88:
 2242 0070 5F010000 		.word	.L99+1
 2243 0074 B9010000 		.word	.L86+1
 2244 0078 A5010000 		.word	.L98+1
 2245 007c B9010000 		.word	.L86+1
 2246 0080 B9010000 		.word	.L86+1
 2247 0084 B9010000 		.word	.L86+1
 2248 0088 B9010000 		.word	.L86+1
 2249 008c B9010000 		.word	.L86+1
 2250 0090 B9010000 		.word	.L86+1
 2251 0094 B9010000 		.word	.L86+1
 2252 0098 91010000 		.word	.L97+1
 2253 009c B9010000 		.word	.L86+1
 2254 00a0 B9010000 		.word	.L86+1
 2255 00a4 73010000 		.word	.L96+1
 2256 00a8 B9010000 		.word	.L86+1
 2257 00ac B9010000 		.word	.L86+1
 2258 00b0 B9010000 		.word	.L86+1
 2259 00b4 B9010000 		.word	.L86+1
 2260 00b8 9B010000 		.word	.L95+1
 2261 00bc 69010000 		.word	.L94+1
 2262 00c0 B9010000 		.word	.L86+1
 2263 00c4 B9010000 		.word	.L86+1
 2264 00c8 B9010000 		.word	.L86+1
 2265 00cc B9010000 		.word	.L86+1
 2266 00d0 B9010000 		.word	.L86+1
 2267 00d4 B9010000 		.word	.L86+1
 2268 00d8 B9010000 		.word	.L86+1
 2269 00dc B9010000 		.word	.L86+1
 2270 00e0 B9010000 		.word	.L86+1
 2271 00e4 B9010000 		.word	.L86+1
 2272 00e8 B9010000 		.word	.L86+1
 2273 00ec B9010000 		.word	.L86+1
 2274 00f0 4B010000 		.word	.L93+1
 2275 00f4 7D010000 		.word	.L92+1
 2276 00f8 B9010000 		.word	.L86+1
 2277 00fc B9010000 		.word	.L86+1
 2278 0100 B9010000 		.word	.L86+1
ARM GAS  /tmp/ccpEjOub.s 			page 142


 2279 0104 B9010000 		.word	.L86+1
 2280 0108 55010000 		.word	.L91+1
 2281 010c B9010000 		.word	.L86+1
 2282 0110 B9010000 		.word	.L86+1
 2283 0114 AF010000 		.word	.L90+1
 2284 0118 B9010000 		.word	.L86+1
 2285 011c B9010000 		.word	.L86+1
 2286 0120 B9010000 		.word	.L86+1
 2287 0124 B9010000 		.word	.L86+1
 2288 0128 B9010000 		.word	.L86+1
 2289 012c B9010000 		.word	.L86+1
 2290 0130 B9010000 		.word	.L86+1
 2291 0134 87010000 		.word	.L89+1
 2292 0138 B9010000 		.word	.L86+1
 2293 013c 41010000 		.word	.L87+1
 2294              		.p2align 1
 2295              	.L87:
 388:Core/Src/motor.c **** 			{
 389:Core/Src/motor.c ****         // 6 cases for forward direction
 390:Core/Src/motor.c ****         case 64:
 391:Core/Src/motor.c ****           Hall_64 = q31_rotorposition_absolute;
 2296              		.loc 2 391 19
 2297 0140 624B     		ldr	r3, .L103+4
 2298 0142 1B68     		ldr	r3, [r3]
 2299 0144 664A     		ldr	r2, .L103+24
 2300 0146 1360     		str	r3, [r2]
 392:Core/Src/motor.c ****           break;
 2301              		.loc 2 392 11
 2302 0148 36E0     		b	.L86
 2303              	.L93:
 393:Core/Src/motor.c **** 
 394:Core/Src/motor.c ****         case 45:
 395:Core/Src/motor.c ****           Hall_45 = q31_rotorposition_absolute;
 2304              		.loc 2 395 19
 2305 014a 604B     		ldr	r3, .L103+4
 2306 014c 1B68     		ldr	r3, [r3]
 2307 014e 654A     		ldr	r2, .L103+28
 2308 0150 1360     		str	r3, [r2]
 396:Core/Src/motor.c ****           break;
 2309              		.loc 2 396 11
 2310 0152 31E0     		b	.L86
 2311              	.L91:
 397:Core/Src/motor.c **** 
 398:Core/Src/motor.c ****         case 51:
 399:Core/Src/motor.c ****           Hall_51 = q31_rotorposition_absolute;
 2312              		.loc 2 399 19
 2313 0154 5D4B     		ldr	r3, .L103+4
 2314 0156 1B68     		ldr	r3, [r3]
 2315 0158 634A     		ldr	r2, .L103+32
 2316 015a 1360     		str	r3, [r2]
 400:Core/Src/motor.c ****           break;
 2317              		.loc 2 400 11
 2318 015c 2CE0     		b	.L86
 2319              	.L99:
 401:Core/Src/motor.c **** 
 402:Core/Src/motor.c ****         case 13:
 403:Core/Src/motor.c ****           Hall_13 = q31_rotorposition_absolute;
ARM GAS  /tmp/ccpEjOub.s 			page 143


 2320              		.loc 2 403 19
 2321 015e 5B4B     		ldr	r3, .L103+4
 2322 0160 1B68     		ldr	r3, [r3]
 2323 0162 624A     		ldr	r2, .L103+36
 2324 0164 1360     		str	r3, [r2]
 404:Core/Src/motor.c ****           break;
 2325              		.loc 2 404 11
 2326 0166 27E0     		b	.L86
 2327              	.L94:
 405:Core/Src/motor.c **** 
 406:Core/Src/motor.c ****         case 32:
 407:Core/Src/motor.c ****           Hall_32 = q31_rotorposition_absolute;
 2328              		.loc 2 407 19
 2329 0168 584B     		ldr	r3, .L103+4
 2330 016a 1B68     		ldr	r3, [r3]
 2331 016c 604A     		ldr	r2, .L103+40
 2332 016e 1360     		str	r3, [r2]
 408:Core/Src/motor.c ****           break;
 2333              		.loc 2 408 11
 2334 0170 22E0     		b	.L86
 2335              	.L96:
 409:Core/Src/motor.c **** 
 410:Core/Src/motor.c ****         case 26:
 411:Core/Src/motor.c ****           Hall_26 = q31_rotorposition_absolute;
 2336              		.loc 2 411 19
 2337 0172 564B     		ldr	r3, .L103+4
 2338 0174 1B68     		ldr	r3, [r3]
 2339 0176 5F4A     		ldr	r2, .L103+44
 2340 0178 1360     		str	r3, [r2]
 412:Core/Src/motor.c ****           break;
 2341              		.loc 2 412 11
 2342 017a 1DE0     		b	.L86
 2343              	.L92:
 413:Core/Src/motor.c **** 
 414:Core/Src/motor.c ****         // 6 cases for reverse direction
 415:Core/Src/motor.c ****         case 46:
 416:Core/Src/motor.c ****           Hall_64 = q31_rotorposition_absolute;
 2344              		.loc 2 416 19
 2345 017c 534B     		ldr	r3, .L103+4
 2346 017e 1B68     		ldr	r3, [r3]
 2347 0180 574A     		ldr	r2, .L103+24
 2348 0182 1360     		str	r3, [r2]
 417:Core/Src/motor.c ****           break;
 2349              		.loc 2 417 11
 2350 0184 18E0     		b	.L86
 2351              	.L89:
 418:Core/Src/motor.c **** 
 419:Core/Src/motor.c ****         case 62:
 420:Core/Src/motor.c ****           Hall_26 = q31_rotorposition_absolute;
 2352              		.loc 2 420 19
 2353 0186 514B     		ldr	r3, .L103+4
 2354 0188 1B68     		ldr	r3, [r3]
 2355 018a 5A4A     		ldr	r2, .L103+44
 2356 018c 1360     		str	r3, [r2]
 421:Core/Src/motor.c ****           break;
 2357              		.loc 2 421 11
 2358 018e 13E0     		b	.L86
ARM GAS  /tmp/ccpEjOub.s 			page 144


 2359              	.L97:
 422:Core/Src/motor.c **** 
 423:Core/Src/motor.c ****         case 23:
 424:Core/Src/motor.c ****           Hall_32 = q31_rotorposition_absolute;
 2360              		.loc 2 424 19
 2361 0190 4E4B     		ldr	r3, .L103+4
 2362 0192 1B68     		ldr	r3, [r3]
 2363 0194 564A     		ldr	r2, .L103+40
 2364 0196 1360     		str	r3, [r2]
 425:Core/Src/motor.c ****           break;
 2365              		.loc 2 425 11
 2366 0198 0EE0     		b	.L86
 2367              	.L95:
 426:Core/Src/motor.c **** 
 427:Core/Src/motor.c ****         case 31:
 428:Core/Src/motor.c ****           Hall_13 = q31_rotorposition_absolute;
 2368              		.loc 2 428 19
 2369 019a 4C4B     		ldr	r3, .L103+4
 2370 019c 1B68     		ldr	r3, [r3]
 2371 019e 534A     		ldr	r2, .L103+36
 2372 01a0 1360     		str	r3, [r2]
 429:Core/Src/motor.c ****           break;
 2373              		.loc 2 429 11
 2374 01a2 09E0     		b	.L86
 2375              	.L98:
 430:Core/Src/motor.c **** 
 431:Core/Src/motor.c ****         case 15:
 432:Core/Src/motor.c ****           Hall_51 = q31_rotorposition_absolute;
 2376              		.loc 2 432 19
 2377 01a4 494B     		ldr	r3, .L103+4
 2378 01a6 1B68     		ldr	r3, [r3]
 2379 01a8 4F4A     		ldr	r2, .L103+32
 2380 01aa 1360     		str	r3, [r2]
 433:Core/Src/motor.c ****           break;
 2381              		.loc 2 433 11
 2382 01ac 04E0     		b	.L86
 2383              	.L90:
 434:Core/Src/motor.c **** 
 435:Core/Src/motor.c ****         case 54:
 436:Core/Src/motor.c ****           Hall_45 = q31_rotorposition_absolute;
 2384              		.loc 2 436 19
 2385 01ae 474B     		ldr	r3, .L103+4
 2386 01b0 1B68     		ldr	r3, [r3]
 2387 01b2 4C4A     		ldr	r2, .L103+28
 2388 01b4 1360     		str	r3, [r2]
 437:Core/Src/motor.c ****           break;
 2389              		.loc 2 437 11
 2390 01b6 00BF     		nop
 2391              	.L86:
 438:Core/Src/motor.c **** 			} // end case
 439:Core/Src/motor.c **** 
 440:Core/Src/motor.c **** 			ui8_hall_state_old = ui8_hall_state;
 2392              		.loc 2 440 23
 2393 01b8 474B     		ldr	r3, .L103+16
 2394 01ba 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 2395 01bc 454B     		ldr	r3, .L103+12
 2396 01be 1A70     		strb	r2, [r3]
ARM GAS  /tmp/ccpEjOub.s 			page 145


 2397              	.L85:
 380:Core/Src/motor.c **** 
 2398              		.loc 2 380 34 discriminator 2
 2399 01c0 7B68     		ldr	r3, [r7, #4]
 2400 01c2 0133     		adds	r3, r3, #1
 2401 01c4 7B60     		str	r3, [r7, #4]
 2402              	.L84:
 380:Core/Src/motor.c **** 
 2403              		.loc 2 380 2 discriminator 1
 2404 01c6 7B68     		ldr	r3, [r7, #4]
 2405 01c8 B3F5876F 		cmp	r3, #1080
 2406 01cc FFF434AF 		bcc	.L100
 2407              	.LBE13:
 441:Core/Src/motor.c **** 		}
 442:Core/Src/motor.c **** 	}
 443:Core/Src/motor.c **** 
 444:Core/Src/motor.c ****   disable_pwm();
 2408              		.loc 2 444 3
 2409 01d0 FFF7FEFF 		bl	disable_pwm
 445:Core/Src/motor.c ****   TIM1->CCR1 = 1023; // set initial PWM values
 2410              		.loc 2 445 7
 2411 01d4 484B     		ldr	r3, .L103+48
 2412              		.loc 2 445 14
 2413 01d6 40F2FF32 		movw	r2, #1023
 2414 01da 5A63     		str	r2, [r3, #52]
 446:Core/Src/motor.c ****   TIM1->CCR2 = 1023;
 2415              		.loc 2 446 7
 2416 01dc 464B     		ldr	r3, .L103+48
 2417              		.loc 2 446 14
 2418 01de 40F2FF32 		movw	r2, #1023
 2419 01e2 9A63     		str	r2, [r3, #56]
 447:Core/Src/motor.c ****   TIM1->CCR3 = 1023;
 2420              		.loc 2 447 7
 2421 01e4 444B     		ldr	r3, .L103+48
 2422              		.loc 2 447 14
 2423 01e6 40F2FF32 		movw	r2, #1023
 2424 01ea DA63     		str	r2, [r3, #60]
 448:Core/Src/motor.c ****   MS.hall_angle_detect_flag = false;
 2425              		.loc 2 448 29
 2426 01ec 364B     		ldr	r3, .L103
 2427 01ee 0022     		movs	r2, #0
 2428 01f0 83F83620 		strb	r2, [r3, #54]
 449:Core/Src/motor.c ****   MS.i_d = 0;
 2429              		.loc 2 449 10
 2430 01f4 344B     		ldr	r3, .L103
 2431 01f6 0022     		movs	r2, #0
 2432 01f8 1A60     		str	r2, [r3]
 450:Core/Src/motor.c ****   MS.i_q = 0;
 2433              		.loc 2 450 10
 2434 01fa 334B     		ldr	r3, .L103
 2435 01fc 0022     		movs	r2, #0
 2436 01fe 5A60     		str	r2, [r3, #4]
 451:Core/Src/motor.c ****   MS.u_d = 0;
 2437              		.loc 2 451 10
 2438 0200 314B     		ldr	r3, .L103
 2439 0202 0022     		movs	r2, #0
 2440 0204 DA61     		str	r2, [r3, #28]
ARM GAS  /tmp/ccpEjOub.s 			page 146


 452:Core/Src/motor.c ****   MS.u_q = 0;
 2441              		.loc 2 452 10
 2442 0206 304B     		ldr	r3, .L103
 2443 0208 0022     		movs	r2, #0
 2444 020a 1A62     		str	r2, [r3, #32]
 453:Core/Src/motor.c ****   q31_tics_filtered = 1000000;
 2445              		.loc 2 453 21
 2446 020c 3B4B     		ldr	r3, .L103+52
 2447 020e 3C4A     		ldr	r2, .L103+56
 2448 0210 1A60     		str	r2, [r3]
 454:Core/Src/motor.c **** 
 455:Core/Src/motor.c ****   // store variables on flash memory
 456:Core/Src/motor.c **** 	HAL_FLASH_Unlock();
 2449              		.loc 2 456 2
 2450 0212 FFF7FEFF 		bl	HAL_FLASH_Unlock
 457:Core/Src/motor.c **** 
 458:Core/Src/motor.c **** 	if (i8_recent_rotor_direction == 1) {
 2451              		.loc 2 458 32
 2452 0216 3B4B     		ldr	r3, .L103+60
 2453 0218 93F90030 		ldrsb	r3, [r3]
 2454              		.loc 2 458 5
 2455 021c 012B     		cmp	r3, #1
 2456 021e 07D1     		bne	.L101
 459:Core/Src/motor.c **** 		EE_WriteVariable(EEPROM_POS_HALL_ORDER, 1);
 2457              		.loc 2 459 3
 2458 0220 0121     		movs	r1, #1
 2459 0222 0020     		movs	r0, #0
 2460 0224 FFF7FEFF 		bl	EE_WriteVariable
 460:Core/Src/motor.c **** 		i16_hall_order = 1;
 2461              		.loc 2 460 18
 2462 0228 294B     		ldr	r3, .L103+8
 2463 022a 0122     		movs	r2, #1
 2464 022c 1A80     		strh	r2, [r3]	@ movhi
 2465 022e 08E0     		b	.L102
 2466              	.L101:
 461:Core/Src/motor.c **** 	} else {
 462:Core/Src/motor.c **** 		EE_WriteVariable(EEPROM_POS_HALL_ORDER, -1);
 2467              		.loc 2 462 3
 2468 0230 4FF0FF31 		mov	r1, #-1
 2469 0234 0020     		movs	r0, #0
 2470 0236 FFF7FEFF 		bl	EE_WriteVariable
 463:Core/Src/motor.c **** 		i16_hall_order = -1;
 2471              		.loc 2 463 18
 2472 023a 254B     		ldr	r3, .L103+8
 2473 023c 4FF6FF72 		movw	r2, #65535
 2474 0240 1A80     		strh	r2, [r3]	@ movhi
 2475              	.L102:
 464:Core/Src/motor.c **** 	}
 465:Core/Src/motor.c **** 	EE_WriteVariable(EEPROM_POS_HALL_45, Hall_45 >> 16);
 2476              		.loc 2 465 47
 2477 0242 284B     		ldr	r3, .L103+28
 2478 0244 1B68     		ldr	r3, [r3]
 2479 0246 1B14     		asrs	r3, r3, #16
 2480              		.loc 2 465 2
 2481 0248 1BB2     		sxth	r3, r3
 2482 024a 1946     		mov	r1, r3
 2483 024c 0120     		movs	r0, #1
ARM GAS  /tmp/ccpEjOub.s 			page 147


 2484 024e FFF7FEFF 		bl	EE_WriteVariable
 466:Core/Src/motor.c **** 	EE_WriteVariable(EEPROM_POS_HALL_51, Hall_51 >> 16);
 2485              		.loc 2 466 47
 2486 0252 254B     		ldr	r3, .L103+32
 2487 0254 1B68     		ldr	r3, [r3]
 2488 0256 1B14     		asrs	r3, r3, #16
 2489              		.loc 2 466 2
 2490 0258 1BB2     		sxth	r3, r3
 2491 025a 1946     		mov	r1, r3
 2492 025c 0220     		movs	r0, #2
 2493 025e FFF7FEFF 		bl	EE_WriteVariable
 467:Core/Src/motor.c **** 	EE_WriteVariable(EEPROM_POS_HALL_13, Hall_13 >> 16);
 2494              		.loc 2 467 47
 2495 0262 224B     		ldr	r3, .L103+36
 2496 0264 1B68     		ldr	r3, [r3]
 2497 0266 1B14     		asrs	r3, r3, #16
 2498              		.loc 2 467 2
 2499 0268 1BB2     		sxth	r3, r3
 2500 026a 1946     		mov	r1, r3
 2501 026c 0320     		movs	r0, #3
 2502 026e FFF7FEFF 		bl	EE_WriteVariable
 468:Core/Src/motor.c **** 	EE_WriteVariable(EEPROM_POS_HALL_32, Hall_32 >> 16);
 2503              		.loc 2 468 47
 2504 0272 1F4B     		ldr	r3, .L103+40
 2505 0274 1B68     		ldr	r3, [r3]
 2506 0276 1B14     		asrs	r3, r3, #16
 2507              		.loc 2 468 2
 2508 0278 1BB2     		sxth	r3, r3
 2509 027a 1946     		mov	r1, r3
 2510 027c 0420     		movs	r0, #4
 2511 027e FFF7FEFF 		bl	EE_WriteVariable
 469:Core/Src/motor.c **** 	EE_WriteVariable(EEPROM_POS_HALL_26, Hall_26 >> 16);
 2512              		.loc 2 469 47
 2513 0282 1C4B     		ldr	r3, .L103+44
 2514 0284 1B68     		ldr	r3, [r3]
 2515 0286 1B14     		asrs	r3, r3, #16
 2516              		.loc 2 469 2
 2517 0288 1BB2     		sxth	r3, r3
 2518 028a 1946     		mov	r1, r3
 2519 028c 0520     		movs	r0, #5
 2520 028e FFF7FEFF 		bl	EE_WriteVariable
 470:Core/Src/motor.c **** 	EE_WriteVariable(EEPROM_POS_HALL_64, Hall_64 >> 16);
 2521              		.loc 2 470 47
 2522 0292 134B     		ldr	r3, .L103+24
 2523 0294 1B68     		ldr	r3, [r3]
 2524 0296 1B14     		asrs	r3, r3, #16
 2525              		.loc 2 470 2
 2526 0298 1BB2     		sxth	r3, r3
 2527 029a 1946     		mov	r1, r3
 2528 029c 0620     		movs	r0, #6
 2529 029e FFF7FEFF 		bl	EE_WriteVariable
 471:Core/Src/motor.c **** 
 472:Core/Src/motor.c **** 	HAL_FLASH_Lock();
 2530              		.loc 2 472 2
 2531 02a2 FFF7FEFF 		bl	HAL_FLASH_Lock
 473:Core/Src/motor.c **** 
 474:Core/Src/motor.c **** 	MS.hall_angle_detect_flag = false;
ARM GAS  /tmp/ccpEjOub.s 			page 148


 2532              		.loc 2 474 28
 2533 02a6 084B     		ldr	r3, .L103
 2534 02a8 0022     		movs	r2, #0
 2535 02aa 83F83620 		strb	r2, [r3, #54]
 475:Core/Src/motor.c **** 
 476:Core/Src/motor.c **** 	ui16_KV_detect_counter = HAL_GetTick();
 2536              		.loc 2 476 27
 2537 02ae FFF7FEFF 		bl	HAL_GetTick
 2538 02b2 0346     		mov	r3, r0
 2539              		.loc 2 476 25
 2540 02b4 9AB2     		uxth	r2, r3
 2541 02b6 144B     		ldr	r3, .L103+64
 2542 02b8 1A80     		strh	r2, [r3]	@ movhi
 477:Core/Src/motor.c **** 	MS.KV_detect_flag = 20;
 2543              		.loc 2 477 20
 2544 02ba 034B     		ldr	r3, .L103
 2545 02bc 1422     		movs	r2, #20
 2546 02be 9A86     		strh	r2, [r3, #52]	@ movhi
 478:Core/Src/motor.c **** }
 2547              		.loc 2 478 1
 2548 02c0 00BF     		nop
 2549 02c2 0837     		adds	r7, r7, #8
 2550              	.LCFI84:
 2551              		.cfi_def_cfa_offset 8
 2552 02c4 BD46     		mov	sp, r7
 2553              	.LCFI85:
 2554              		.cfi_def_cfa_register 13
 2555              		@ sp needed
 2556 02c6 80BD     		pop	{r7, pc}
 2557              	.L104:
 2558              		.align	2
 2559              	.L103:
 2560 02c8 00000000 		.word	MS
 2561 02cc 00000000 		.word	q31_rotorposition_absolute
 2562 02d0 00000000 		.word	i16_hall_order
 2563 02d4 00000000 		.word	ui8_hall_state_old
 2564 02d8 00000000 		.word	ui8_hall_state
 2565 02dc 00000000 		.word	ui8_hall_case
 2566 02e0 00000000 		.word	Hall_64
 2567 02e4 00000000 		.word	Hall_45
 2568 02e8 00000000 		.word	Hall_51
 2569 02ec 00000000 		.word	Hall_13
 2570 02f0 00000000 		.word	Hall_32
 2571 02f4 00000000 		.word	Hall_26
 2572 02f8 002C0140 		.word	1073818624
 2573 02fc 00000000 		.word	q31_tics_filtered
 2574 0300 40420F00 		.word	1000000
 2575 0304 00000000 		.word	i8_recent_rotor_direction
 2576 0308 00000000 		.word	ui16_KV_detect_counter
 2577              		.cfi_endproc
 2578              	.LFE131:
 2580              		.section	.text.internal_tics_to_speedx100,"ax",%progbits
 2581              		.align	1
 2582              		.global	internal_tics_to_speedx100
 2583              		.syntax unified
 2584              		.thumb
 2585              		.thumb_func
ARM GAS  /tmp/ccpEjOub.s 			page 149


 2586              		.fpu softvfp
 2588              	internal_tics_to_speedx100:
 2589              	.LFB132:
 479:Core/Src/motor.c **** 
 480:Core/Src/motor.c **** int16_t internal_tics_to_speedx100 (uint32_t tics) {
 2590              		.loc 2 480 52
 2591              		.cfi_startproc
 2592              		@ args = 0, pretend = 0, frame = 8
 2593              		@ frame_needed = 1, uses_anonymous_args = 0
 2594              		@ link register save eliminated.
 2595 0000 80B4     		push	{r7}
 2596              	.LCFI86:
 2597              		.cfi_def_cfa_offset 4
 2598              		.cfi_offset 7, -4
 2599 0002 83B0     		sub	sp, sp, #12
 2600              	.LCFI87:
 2601              		.cfi_def_cfa_offset 16
 2602 0004 00AF     		add	r7, sp, #0
 2603              	.LCFI88:
 2604              		.cfi_def_cfa_register 7
 2605 0006 7860     		str	r0, [r7, #4]
 481:Core/Src/motor.c **** 	return WHEEL_CIRCUMFERENCE * 50 * 3600 / (6 * GEAR_RATIO * tics);
 2606              		.loc 2 481 59
 2607 0008 7B68     		ldr	r3, [r7, #4]
 2608 000a 5A22     		movs	r2, #90
 2609 000c 02FB03F3 		mul	r3, r2, r3
 2610              		.loc 2 481 41
 2611 0010 044A     		ldr	r2, .L107
 2612 0012 B2FBF3F3 		udiv	r3, r2, r3
 2613 0016 1BB2     		sxth	r3, r3
 482:Core/Src/motor.c **** }
 2614              		.loc 2 482 1
 2615 0018 1846     		mov	r0, r3
 2616 001a 0C37     		adds	r7, r7, #12
 2617              	.LCFI89:
 2618              		.cfi_def_cfa_offset 4
 2619 001c BD46     		mov	sp, r7
 2620              	.LCFI90:
 2621              		.cfi_def_cfa_register 13
 2622              		@ sp needed
 2623 001e 80BC     		pop	{r7}
 2624              	.LCFI91:
 2625              		.cfi_restore 7
 2626              		.cfi_def_cfa_offset 0
 2627 0020 7047     		bx	lr
 2628              	.L108:
 2629 0022 00BF     		.align	2
 2630              	.L107:
 2631 0024 40246707 		.word	124200000
 2632              		.cfi_endproc
 2633              	.LFE132:
 2635              		.section	.text.calculate_tic_limits,"ax",%progbits
 2636              		.align	1
 2637              		.global	calculate_tic_limits
 2638              		.syntax unified
 2639              		.thumb
 2640              		.thumb_func
ARM GAS  /tmp/ccpEjOub.s 			page 150


 2641              		.fpu softvfp
 2643              	calculate_tic_limits:
 2644              	.LFB133:
 483:Core/Src/motor.c **** 
 484:Core/Src/motor.c **** void calculate_tic_limits(int8_t speed_limit) {
 2645              		.loc 2 484 47
 2646              		.cfi_startproc
 2647              		@ args = 0, pretend = 0, frame = 8
 2648              		@ frame_needed = 1, uses_anonymous_args = 0
 2649              		@ link register save eliminated.
 2650 0000 80B4     		push	{r7}
 2651              	.LCFI92:
 2652              		.cfi_def_cfa_offset 4
 2653              		.cfi_offset 7, -4
 2654 0002 83B0     		sub	sp, sp, #12
 2655              	.LCFI93:
 2656              		.cfi_def_cfa_offset 16
 2657 0004 00AF     		add	r7, sp, #0
 2658              	.LCFI94:
 2659              		.cfi_def_cfa_register 7
 2660 0006 0346     		mov	r3, r0
 2661 0008 FB71     		strb	r3, [r7, #7]
 485:Core/Src/motor.c ****   // tics = wheelcirc * timerfrequency / (no. of hallevents per rev * gear-ratio * speedlimit) * 36
 486:Core/Src/motor.c **** 	tics_lower_limit = WHEEL_CIRCUMFERENCE * 5 * 3600 / (6 * GEAR_RATIO * speed_limit * 10);
 2662              		.loc 2 486 84
 2663 000a 97F90730 		ldrsb	r3, [r7, #7]
 2664 000e 4FF46172 		mov	r2, #900
 2665 0012 02FB03F3 		mul	r3, r2, r3
 2666              		.loc 2 486 52
 2667 0016 0B4A     		ldr	r2, .L110
 2668 0018 92FBF3F3 		sdiv	r3, r2, r3
 2669              		.loc 2 486 19
 2670 001c 0A4A     		ldr	r2, .L110+4
 2671 001e 1360     		str	r3, [r2]
 487:Core/Src/motor.c **** 	tics_higher_limit = WHEEL_CIRCUMFERENCE * 5 * 3600 / (6 * GEAR_RATIO * (speed_limit + 2) * 10);
 2672              		.loc 2 487 86
 2673 0020 97F90730 		ldrsb	r3, [r7, #7]
 2674 0024 0233     		adds	r3, r3, #2
 2675              		.loc 2 487 91
 2676 0026 4FF46172 		mov	r2, #900
 2677 002a 02FB03F3 		mul	r3, r2, r3
 2678              		.loc 2 487 53
 2679 002e 054A     		ldr	r2, .L110
 2680 0030 92FBF3F3 		sdiv	r3, r2, r3
 2681              		.loc 2 487 20
 2682 0034 054A     		ldr	r2, .L110+8
 2683 0036 1360     		str	r3, [r2]
 488:Core/Src/motor.c **** }
 2684              		.loc 2 488 1
 2685 0038 00BF     		nop
 2686 003a 0C37     		adds	r7, r7, #12
 2687              	.LCFI95:
 2688              		.cfi_def_cfa_offset 4
 2689 003c BD46     		mov	sp, r7
 2690              	.LCFI96:
 2691              		.cfi_def_cfa_register 13
 2692              		@ sp needed
ARM GAS  /tmp/ccpEjOub.s 			page 151


 2693 003e 80BC     		pop	{r7}
 2694              	.LCFI97:
 2695              		.cfi_restore 7
 2696              		.cfi_def_cfa_offset 0
 2697 0040 7047     		bx	lr
 2698              	.L111:
 2699 0042 00BF     		.align	2
 2700              	.L110:
 2701 0044 A083BD00 		.word	12420000
 2702 0048 00000000 		.word	tics_lower_limit
 2703 004c 00000000 		.word	tics_higher_limit
 2704              		.cfi_endproc
 2705              	.LFE133:
 2707              		.section	.text.get_battery_current,"ax",%progbits
 2708              		.align	1
 2709              		.global	get_battery_current
 2710              		.syntax unified
 2711              		.thumb
 2712              		.thumb_func
 2713              		.fpu softvfp
 2715              	get_battery_current:
 2716              	.LFB134:
 489:Core/Src/motor.c **** 
 490:Core/Src/motor.c **** q31_t get_battery_current(q31_t iq, q31_t id, q31_t uq, q31_t ud) {
 2717              		.loc 2 490 67
 2718              		.cfi_startproc
 2719              		@ args = 0, pretend = 0, frame = 24
 2720              		@ frame_needed = 1, uses_anonymous_args = 0
 2721              		@ link register save eliminated.
 2722 0000 80B4     		push	{r7}
 2723              	.LCFI98:
 2724              		.cfi_def_cfa_offset 4
 2725              		.cfi_offset 7, -4
 2726 0002 87B0     		sub	sp, sp, #28
 2727              	.LCFI99:
 2728              		.cfi_def_cfa_offset 32
 2729 0004 00AF     		add	r7, sp, #0
 2730              	.LCFI100:
 2731              		.cfi_def_cfa_register 7
 2732 0006 F860     		str	r0, [r7, #12]
 2733 0008 B960     		str	r1, [r7, #8]
 2734 000a 7A60     		str	r2, [r7, #4]
 2735 000c 3B60     		str	r3, [r7]
 491:Core/Src/motor.c **** 	q31_t ibatq;
 492:Core/Src/motor.c **** 	q31_t ibatd;
 493:Core/Src/motor.c **** 	ibatq = (iq * uq * CAL_I) >> 11;
 2736              		.loc 2 493 14
 2737 000e FB68     		ldr	r3, [r7, #12]
 2738 0010 7A68     		ldr	r2, [r7, #4]
 2739 0012 02FB03F3 		mul	r3, r2, r3
 2740              		.loc 2 493 19
 2741 0016 2622     		movs	r2, #38
 2742 0018 02FB03F3 		mul	r3, r2, r3
 2743              		.loc 2 493 8
 2744 001c DB12     		asrs	r3, r3, #11
 2745 001e 7B61     		str	r3, [r7, #20]
 494:Core/Src/motor.c **** 	ibatd = (id * ud * CAL_I) >> 11;
ARM GAS  /tmp/ccpEjOub.s 			page 152


 2746              		.loc 2 494 14
 2747 0020 BB68     		ldr	r3, [r7, #8]
 2748 0022 3A68     		ldr	r2, [r7]
 2749 0024 02FB03F3 		mul	r3, r2, r3
 2750              		.loc 2 494 19
 2751 0028 2622     		movs	r2, #38
 2752 002a 02FB03F3 		mul	r3, r2, r3
 2753              		.loc 2 494 8
 2754 002e DB12     		asrs	r3, r3, #11
 2755 0030 3B61     		str	r3, [r7, #16]
 495:Core/Src/motor.c **** 
 496:Core/Src/motor.c **** 	return abs(ibatd) + abs(ibatq);
 2756              		.loc 2 496 9
 2757 0032 3B69     		ldr	r3, [r7, #16]
 2758 0034 83EAE372 		eor	r2, r3, r3, asr #31
 2759 0038 A2EBE372 		sub	r2, r2, r3, asr #31
 2760              		.loc 2 496 22
 2761 003c 7B69     		ldr	r3, [r7, #20]
 2762 003e 002B     		cmp	r3, #0
 2763 0040 B8BF     		it	lt
 2764 0042 5B42     		rsblt	r3, r3, #0
 2765              		.loc 2 496 20
 2766 0044 1344     		add	r3, r3, r2
 497:Core/Src/motor.c **** }
 2767              		.loc 2 497 1
 2768 0046 1846     		mov	r0, r3
 2769 0048 1C37     		adds	r7, r7, #28
 2770              	.LCFI101:
 2771              		.cfi_def_cfa_offset 4
 2772 004a BD46     		mov	sp, r7
 2773              	.LCFI102:
 2774              		.cfi_def_cfa_register 13
 2775              		@ sp needed
 2776 004c 80BC     		pop	{r7}
 2777              	.LCFI103:
 2778              		.cfi_restore 7
 2779              		.cfi_def_cfa_offset 0
 2780 004e 7047     		bx	lr
 2781              		.cfi_endproc
 2782              	.LFE134:
 2784              		.section	.text.motor_slow_loop,"ax",%progbits
 2785              		.align	1
 2786              		.global	motor_slow_loop
 2787              		.syntax unified
 2788              		.thumb
 2789              		.thumb_func
 2790              		.fpu softvfp
 2792              	motor_slow_loop:
 2793              	.LFB135:
 498:Core/Src/motor.c **** 
 499:Core/Src/motor.c **** // call every 10ms
 500:Core/Src/motor.c **** void motor_slow_loop(MotorStatePublic_t* p_MotorStatePublic) {
 2794              		.loc 2 500 62
 2795              		.cfi_startproc
 2796              		@ args = 0, pretend = 0, frame = 16
 2797              		@ frame_needed = 1, uses_anonymous_args = 0
 2798 0000 90B5     		push	{r4, r7, lr}
ARM GAS  /tmp/ccpEjOub.s 			page 153


 2799              	.LCFI104:
 2800              		.cfi_def_cfa_offset 12
 2801              		.cfi_offset 4, -12
 2802              		.cfi_offset 7, -8
 2803              		.cfi_offset 14, -4
 2804 0002 87B0     		sub	sp, sp, #28
 2805              	.LCFI105:
 2806              		.cfi_def_cfa_offset 40
 2807 0004 02AF     		add	r7, sp, #8
 2808              	.LCFI106:
 2809              		.cfi_def_cfa 7, 32
 2810 0006 7860     		str	r0, [r7, #4]
 501:Core/Src/motor.c **** 
 502:Core/Src/motor.c ****   MotorStatePublic_t* MSP = p_MotorStatePublic;
 2811              		.loc 2 502 23
 2812 0008 7B68     		ldr	r3, [r7, #4]
 2813 000a FB60     		str	r3, [r7, #12]
 503:Core/Src/motor.c **** 
 504:Core/Src/motor.c ****   MS.brake_active = MSP->brake_active;
 2814              		.loc 2 504 24
 2815 000c FB68     		ldr	r3, [r7, #12]
 2816 000e 93F82820 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 2817              		.loc 2 504 19
 2818 0012 6F4B     		ldr	r3, .L137
 2819 0014 83F83220 		strb	r2, [r3, #50]
 505:Core/Src/motor.c **** 
 506:Core/Src/motor.c ****   // set power to zero at low voltage
 507:Core/Src/motor.c ****   if (p_MotorStatePublic->battery_voltage < p_MotorStatePublic->battery_voltage_min) {
 2820              		.loc 2 507 25
 2821 0018 7B68     		ldr	r3, [r7, #4]
 2822 001a 9A68     		ldr	r2, [r3, #8]
 2823              		.loc 2 507 63
 2824 001c 7B68     		ldr	r3, [r7, #4]
 2825 001e DB68     		ldr	r3, [r3, #12]
 2826              		.loc 2 507 6
 2827 0020 9A42     		cmp	r2, r3
 2828 0022 0ADA     		bge	.L115
 508:Core/Src/motor.c ****     
 509:Core/Src/motor.c ****     MS.i_q_setpoint = 0;
 2829              		.loc 2 509 21
 2830 0024 6A4B     		ldr	r3, .L137
 2831 0026 0022     		movs	r2, #0
 2832 0028 9A60     		str	r2, [r3, #8]
 510:Core/Src/motor.c ****     MS.i_d_setpoint = 0;
 2833              		.loc 2 510 21
 2834 002a 694B     		ldr	r3, .L137
 2835 002c 0022     		movs	r2, #0
 2836 002e DA60     		str	r2, [r3, #12]
 511:Core/Src/motor.c ****     MS.error_state = lowbattery;
 2837              		.loc 2 511 20
 2838 0030 674B     		ldr	r3, .L137
 2839 0032 1822     		movs	r2, #24
 2840 0034 83F82E20 		strb	r2, [r3, #46]
 2841 0038 86E1     		b	.L116
 2842              	.L115:
 2843              	.LBB14:
 512:Core/Src/motor.c **** 
ARM GAS  /tmp/ccpEjOub.s 			page 154


 513:Core/Src/motor.c ****   } else {
 514:Core/Src/motor.c **** 
 515:Core/Src/motor.c ****     if (MS.error_state == lowbattery) {
 2844              		.loc 2 515 11
 2845 003a 654B     		ldr	r3, .L137
 2846 003c 93F92E30 		ldrsb	r3, [r3, #46]
 2847              		.loc 2 515 8
 2848 0040 182B     		cmp	r3, #24
 2849 0042 03D1     		bne	.L117
 516:Core/Src/motor.c ****       MS.error_state = none;
 2850              		.loc 2 516 22
 2851 0044 624B     		ldr	r3, .L137
 2852 0046 0022     		movs	r2, #0
 2853 0048 83F82E20 		strb	r2, [r3, #46]
 2854              	.L117:
 517:Core/Src/motor.c ****     }
 518:Core/Src/motor.c **** 
 519:Core/Src/motor.c ****     // i_q current limits
 520:Core/Src/motor.c ****     int16_t phase_current_limit = MSP->phase_current_limit / 38;
 2855              		.loc 2 520 38
 2856 004c FB68     		ldr	r3, [r7, #12]
 2857 004e B3F90430 		ldrsh	r3, [r3, #4]
 2858              		.loc 2 520 13
 2859 0052 604A     		ldr	r2, .L137+4
 2860 0054 82FB0312 		smull	r1, r2, r2, r3
 2861 0058 1211     		asrs	r2, r2, #4
 2862 005a DB17     		asrs	r3, r3, #31
 2863 005c D31A     		subs	r3, r2, r3
 2864 005e 7B81     		strh	r3, [r7, #10]	@ movhi
 521:Core/Src/motor.c ****     if (MSP->i_q_setpoint_target > phase_current_limit) {
 2865              		.loc 2 521 12
 2866 0060 FB68     		ldr	r3, [r7, #12]
 2867 0062 1A68     		ldr	r2, [r3]
 2868              		.loc 2 521 34
 2869 0064 B7F90A30 		ldrsh	r3, [r7, #10]
 2870              		.loc 2 521 8
 2871 0068 9A42     		cmp	r2, r3
 2872 006a 03DD     		ble	.L118
 522:Core/Src/motor.c ****       MS.i_q_setpoint_temp = phase_current_limit;
 2873              		.loc 2 522 28
 2874 006c B7F90A30 		ldrsh	r3, [r7, #10]
 2875 0070 574A     		ldr	r2, .L137
 2876 0072 5361     		str	r3, [r2, #20]
 2877              	.L118:
 523:Core/Src/motor.c ****     }
 524:Core/Src/motor.c **** 
 525:Core/Src/motor.c ****     if (MSP->i_q_setpoint_target < -phase_current_limit) {
 2878              		.loc 2 525 12
 2879 0074 FB68     		ldr	r3, [r7, #12]
 2880 0076 1A68     		ldr	r2, [r3]
 2881              		.loc 2 525 34
 2882 0078 B7F90A30 		ldrsh	r3, [r7, #10]
 2883              		.loc 2 525 36
 2884 007c 5B42     		rsbs	r3, r3, #0
 2885              		.loc 2 525 8
 2886 007e 9A42     		cmp	r2, r3
 2887 0080 04DA     		bge	.L119
ARM GAS  /tmp/ccpEjOub.s 			page 155


 526:Core/Src/motor.c ****       MS.i_q_setpoint_temp = -phase_current_limit;
 2888              		.loc 2 526 30
 2889 0082 B7F90A30 		ldrsh	r3, [r7, #10]
 2890 0086 5B42     		rsbs	r3, r3, #0
 2891              		.loc 2 526 28
 2892 0088 514A     		ldr	r2, .L137
 2893 008a 5361     		str	r3, [r2, #20]
 2894              	.L119:
 527:Core/Src/motor.c ****     }
 528:Core/Src/motor.c **** 
 529:Core/Src/motor.c ****     calculate_tic_limits(MSP->speed_limit);
 2895              		.loc 2 529 5
 2896 008c FB68     		ldr	r3, [r7, #12]
 2897 008e 93F92230 		ldrsb	r3, [r3, #34]
 2898 0092 1846     		mov	r0, r3
 2899 0094 FFF7FEFF 		bl	calculate_tic_limits
 530:Core/Src/motor.c **** 
 531:Core/Src/motor.c ****     // ramp down current at speed limit
 532:Core/Src/motor.c ****     MS.i_q_setpoint_temp = map(ui16_halls_tim2tics_filtered, tics_higher_limit, tics_lower_limit, 0
 2900              		.loc 2 532 28
 2901 0098 4F4B     		ldr	r3, .L137+8
 2902 009a 1B88     		ldrh	r3, [r3]
 2903 009c 1846     		mov	r0, r3
 2904 009e 4F4B     		ldr	r3, .L137+12
 2905 00a0 1968     		ldr	r1, [r3]
 2906 00a2 4F4B     		ldr	r3, .L137+16
 2907 00a4 1A68     		ldr	r2, [r3]
 2908 00a6 FB68     		ldr	r3, [r7, #12]
 2909 00a8 1B68     		ldr	r3, [r3]
 2910 00aa 0093     		str	r3, [sp]
 2911 00ac 0023     		movs	r3, #0
 2912 00ae FFF7FEFF 		bl	map
 2913 00b2 0346     		mov	r3, r0
 2914              		.loc 2 532 26
 2915 00b4 464A     		ldr	r2, .L137
 2916 00b6 5361     		str	r3, [r2, #20]
 533:Core/Src/motor.c **** 
 534:Core/Src/motor.c ****     if (MSP->field_weakening_enable) {
 2917              		.loc 2 534 12
 2918 00b8 FB68     		ldr	r3, [r7, #12]
 2919 00ba 93F82930 		ldrb	r3, [r3, #41]	@ zero_extendqisi2
 2920              		.loc 2 534 8
 2921 00be 002B     		cmp	r3, #0
 2922 00c0 34D0     		beq	.L120
 535:Core/Src/motor.c ****       
 536:Core/Src/motor.c ****       MS.i_d_setpoint_temp =
 537:Core/Src/motor.c ****         -map(MSP->speed,
 2923              		.loc 2 537 17
 2924 00c2 FB68     		ldr	r3, [r7, #12]
 2925 00c4 5B6A     		ldr	r3, [r3, #36]
 2926              		.loc 2 537 10
 2927 00c6 1C46     		mov	r4, r3
 538:Core/Src/motor.c ****             (ui32_KV * MSP->battery_voltage / 100000) - 8,
 2928              		.loc 2 538 22
 2929 00c8 464B     		ldr	r3, .L137+20
 2930 00ca B3F90030 		ldrsh	r3, [r3]
 2931 00ce 1A46     		mov	r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 156


 2932              		.loc 2 538 27
 2933 00d0 FB68     		ldr	r3, [r7, #12]
 2934 00d2 9B68     		ldr	r3, [r3, #8]
 2935              		.loc 2 538 22
 2936 00d4 03FB02F3 		mul	r3, r3, r2
 2937              		.loc 2 538 45
 2938 00d8 434A     		ldr	r2, .L137+24
 2939 00da 82FB0312 		smull	r1, r2, r2, r3
 2940 00de 5213     		asrs	r2, r2, #13
 2941 00e0 DB17     		asrs	r3, r3, #31
 2942 00e2 D31A     		subs	r3, r2, r3
 537:Core/Src/motor.c ****             (ui32_KV * MSP->battery_voltage / 100000) - 8,
 2943              		.loc 2 537 10
 2944 00e4 A3F10801 		sub	r1, r3, #8
 539:Core/Src/motor.c ****             (ui32_KV * MSP->battery_voltage / 100000) + 30,
 2945              		.loc 2 539 22
 2946 00e8 3E4B     		ldr	r3, .L137+20
 2947 00ea B3F90030 		ldrsh	r3, [r3]
 2948 00ee 1A46     		mov	r2, r3
 2949              		.loc 2 539 27
 2950 00f0 FB68     		ldr	r3, [r7, #12]
 2951 00f2 9B68     		ldr	r3, [r3, #8]
 2952              		.loc 2 539 22
 2953 00f4 03FB02F3 		mul	r3, r3, r2
 2954              		.loc 2 539 45
 2955 00f8 3B4A     		ldr	r2, .L137+24
 2956 00fa 82FB0302 		smull	r0, r2, r2, r3
 2957 00fe 5213     		asrs	r2, r2, #13
 2958 0100 DB17     		asrs	r3, r3, #31
 2959 0102 D31A     		subs	r3, r2, r3
 537:Core/Src/motor.c ****             (ui32_KV * MSP->battery_voltage / 100000) - 8,
 2960              		.loc 2 537 10
 2961 0104 03F11E02 		add	r2, r3, #30
 540:Core/Src/motor.c ****             0,
 541:Core/Src/motor.c ****             (MSP->field_weakening_current_max / CAL_I));
 2962              		.loc 2 541 17
 2963 0108 FB68     		ldr	r3, [r7, #12]
 2964 010a 1B8A     		ldrh	r3, [r3, #16]
 537:Core/Src/motor.c ****             (ui32_KV * MSP->battery_voltage / 100000) - 8,
 2965              		.loc 2 537 10
 2966 010c 5B08     		lsrs	r3, r3, #1
 2967 010e 3148     		ldr	r0, .L137+4
 2968 0110 A0FB0303 		umull	r0, r3, r0, r3
 2969 0114 DB08     		lsrs	r3, r3, #3
 2970 0116 9BB2     		uxth	r3, r3
 2971 0118 0093     		str	r3, [sp]
 2972 011a 0023     		movs	r3, #0
 2973 011c 2046     		mov	r0, r4
 2974 011e FFF7FEFF 		bl	map
 2975 0122 0346     		mov	r3, r0
 537:Core/Src/motor.c ****             (ui32_KV * MSP->battery_voltage / 100000) - 8,
 2976              		.loc 2 537 9
 2977 0124 5B42     		rsbs	r3, r3, #0
 536:Core/Src/motor.c ****         -map(MSP->speed,
 2978              		.loc 2 536 28
 2979 0126 2A4A     		ldr	r2, .L137
 2980 0128 9361     		str	r3, [r2, #24]
ARM GAS  /tmp/ccpEjOub.s 			page 157


 2981 012a 02E0     		b	.L121
 2982              	.L120:
 542:Core/Src/motor.c **** 
 543:Core/Src/motor.c ****     } else {
 544:Core/Src/motor.c ****       MS.i_d_setpoint_temp = 0;
 2983              		.loc 2 544 28
 2984 012c 284B     		ldr	r3, .L137
 2985 012e 0022     		movs	r2, #0
 2986 0130 9A61     		str	r2, [r3, #24]
 2987              	.L121:
 545:Core/Src/motor.c ****     }
 546:Core/Src/motor.c **** 
 547:Core/Src/motor.c ****     // check and limit absolute value of current vector
 548:Core/Src/motor.c ****     arm_sqrt_q31((MS.i_q_setpoint_temp * MS.i_q_setpoint_temp + MS.i_d_setpoint_temp * MS.i_d_setpo
 2988              		.loc 2 548 21
 2989 0132 274B     		ldr	r3, .L137
 2990 0134 5B69     		ldr	r3, [r3, #20]
 2991              		.loc 2 548 44
 2992 0136 264A     		ldr	r2, .L137
 2993 0138 5269     		ldr	r2, [r2, #20]
 2994              		.loc 2 548 40
 2995 013a 02FB03F2 		mul	r2, r2, r3
 2996              		.loc 2 548 67
 2997 013e 244B     		ldr	r3, .L137
 2998 0140 9B69     		ldr	r3, [r3, #24]
 2999              		.loc 2 548 90
 3000 0142 2349     		ldr	r1, .L137
 3001 0144 8969     		ldr	r1, [r1, #24]
 3002              		.loc 2 548 86
 3003 0146 01FB03F3 		mul	r3, r1, r3
 3004              		.loc 2 548 63
 3005 014a 1344     		add	r3, r3, r2
 3006              		.loc 2 548 5
 3007 014c 5B00     		lsls	r3, r3, #1
 3008 014e 2749     		ldr	r1, .L137+28
 3009 0150 1846     		mov	r0, r3
 3010 0152 FFF7FEFF 		bl	arm_sqrt_q31
 549:Core/Src/motor.c ****     MS.i_setpoint_abs = (MS.i_setpoint_abs >> 16) + 1;
 3011              		.loc 2 549 28
 3012 0156 1E4B     		ldr	r3, .L137
 3013 0158 1B69     		ldr	r3, [r3, #16]
 3014              		.loc 2 549 44
 3015 015a 1B14     		asrs	r3, r3, #16
 3016              		.loc 2 549 51
 3017 015c 0133     		adds	r3, r3, #1
 3018              		.loc 2 549 23
 3019 015e 1C4A     		ldr	r2, .L137
 3020 0160 1361     		str	r3, [r2, #16]
 550:Core/Src/motor.c **** 
 551:Core/Src/motor.c ****     if (MS.hall_angle_detect_flag == false) {
 3021              		.loc 2 551 11
 3022 0162 1B4B     		ldr	r3, .L137
 3023 0164 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 3024              		.loc 2 551 35
 3025 0168 83F00103 		eor	r3, r3, #1
 3026 016c DBB2     		uxtb	r3, r3
 3027              		.loc 2 551 8
ARM GAS  /tmp/ccpEjOub.s 			page 158


 3028 016e 002B     		cmp	r3, #0
 3029 0170 4ED0     		beq	.L122
 552:Core/Src/motor.c ****       if (MS.i_setpoint_abs > MSP->phase_current_limit) {
 3030              		.loc 2 552 13
 3031 0172 174B     		ldr	r3, .L137
 3032 0174 1B69     		ldr	r3, [r3, #16]
 3033              		.loc 2 552 34
 3034 0176 FA68     		ldr	r2, [r7, #12]
 3035 0178 B2F90420 		ldrsh	r2, [r2, #4]
 3036              		.loc 2 552 10
 3037 017c 9342     		cmp	r3, r2
 3038 017e 39DD     		ble	.L123
 553:Core/Src/motor.c ****         MS.i_q_setpoint = i8_direction * (MS.i_q_setpoint_temp * MSP->phase_current_limit) / MS.i_s
 3039              		.loc 2 553 40
 3040 0180 1B4B     		ldr	r3, .L137+32
 3041 0182 93F90030 		ldrsb	r3, [r3]
 3042 0186 1946     		mov	r1, r3
 3043              		.loc 2 553 45
 3044 0188 114B     		ldr	r3, .L137
 3045 018a 5B69     		ldr	r3, [r3, #20]
 3046              		.loc 2 553 69
 3047 018c FA68     		ldr	r2, [r7, #12]
 3048 018e B2F90420 		ldrsh	r2, [r2, #4]
 3049              		.loc 2 553 64
 3050 0192 02FB03F3 		mul	r3, r2, r3
 3051              		.loc 2 553 40
 3052 0196 03FB01F2 		mul	r2, r3, r1
 3053              		.loc 2 553 96
 3054 019a 0D4B     		ldr	r3, .L137
 3055 019c 1B69     		ldr	r3, [r3, #16]
 3056              		.loc 2 553 92
 3057 019e 92FBF3F3 		sdiv	r3, r2, r3
 3058              		.loc 2 553 25
 3059 01a2 0B4A     		ldr	r2, .L137
 3060 01a4 9360     		str	r3, [r2, #8]
 554:Core/Src/motor.c ****         MS.i_d_setpoint = (MS.i_d_setpoint_temp * MSP->phase_current_limit) / MS.i_setpoint_abs; //
 3061              		.loc 2 554 30
 3062 01a6 0A4B     		ldr	r3, .L137
 3063 01a8 9B69     		ldr	r3, [r3, #24]
 3064              		.loc 2 554 54
 3065 01aa FA68     		ldr	r2, [r7, #12]
 3066 01ac B2F90420 		ldrsh	r2, [r2, #4]
 3067              		.loc 2 554 49
 3068 01b0 02FB03F2 		mul	r2, r2, r3
 3069              		.loc 2 554 81
 3070 01b4 064B     		ldr	r3, .L137
 3071 01b6 1B69     		ldr	r3, [r3, #16]
 3072              		.loc 2 554 77
 3073 01b8 92FBF3F3 		sdiv	r3, r2, r3
 3074              		.loc 2 554 25
 3075 01bc 044A     		ldr	r2, .L137
 3076 01be D360     		str	r3, [r2, #12]
 555:Core/Src/motor.c ****         MS.i_setpoint_abs = MSP->phase_current_limit;
 3077              		.loc 2 555 32
 3078 01c0 FB68     		ldr	r3, [r7, #12]
 3079 01c2 B3F90430 		ldrsh	r3, [r3, #4]
 3080 01c6 1A46     		mov	r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 159


 3081              		.loc 2 555 27
 3082 01c8 014B     		ldr	r3, .L137
 3083 01ca 1A61     		str	r2, [r3, #16]
 3084 01cc 20E0     		b	.L122
 3085              	.L138:
 3086 01ce 00BF     		.align	2
 3087              	.L137:
 3088 01d0 00000000 		.word	MS
 3089 01d4 F31ACA6B 		.word	1808407283
 3090 01d8 00000000 		.word	ui16_halls_tim2tics_filtered
 3091 01dc 00000000 		.word	tics_higher_limit
 3092 01e0 00000000 		.word	tics_lower_limit
 3093 01e4 00000000 		.word	ui32_KV
 3094 01e8 89B5F814 		.word	351843721
 3095 01ec 10000000 		.word	MS+16
 3096 01f0 00000000 		.word	i8_direction
 3097              	.L123:
 556:Core/Src/motor.c ****       } else {
 557:Core/Src/motor.c ****         MS.i_q_setpoint = i8_direction * MS.i_q_setpoint_temp;
 3098              		.loc 2 557 40
 3099 01f4 8F4B     		ldr	r3, .L139
 3100 01f6 93F90030 		ldrsb	r3, [r3]
 3101 01fa 1A46     		mov	r2, r3
 3102              		.loc 2 557 44
 3103 01fc 8E4B     		ldr	r3, .L139+4
 3104 01fe 5B69     		ldr	r3, [r3, #20]
 3105              		.loc 2 557 40
 3106 0200 03FB02F3 		mul	r3, r3, r2
 3107              		.loc 2 557 25
 3108 0204 8C4A     		ldr	r2, .L139+4
 3109 0206 9360     		str	r3, [r2, #8]
 558:Core/Src/motor.c ****         MS.i_d_setpoint = MS.i_d_setpoint_temp;
 3110              		.loc 2 558 29
 3111 0208 8B4B     		ldr	r3, .L139+4
 3112 020a 9B69     		ldr	r3, [r3, #24]
 3113              		.loc 2 558 25
 3114 020c 8A4A     		ldr	r2, .L139+4
 3115 020e D360     		str	r3, [r2, #12]
 3116              	.L122:
 559:Core/Src/motor.c ****       }
 560:Core/Src/motor.c ****     }
 561:Core/Src/motor.c **** 
 562:Core/Src/motor.c ****     // run KV detection
 563:Core/Src/motor.c ****     if (MS.KV_detect_flag > 0) {
 3117              		.loc 2 563 11
 3118 0210 894B     		ldr	r3, .L139+4
 3119 0212 B3F93430 		ldrsh	r3, [r3, #52]
 3120              		.loc 2 563 8
 3121 0216 002B     		cmp	r3, #0
 3122 0218 40F39680 		ble	.L116
 3123              	.LBB15:
 564:Core/Src/motor.c ****       static int8_t dir = 1;
 565:Core/Src/motor.c ****       static uint16_t KVtemp;
 566:Core/Src/motor.c ****       MS.i_q_setpoint = 1;
 3124              		.loc 2 566 23
 3125 021c 864B     		ldr	r3, .L139+4
 3126 021e 0122     		movs	r2, #1
ARM GAS  /tmp/ccpEjOub.s 			page 160


 3127 0220 9A60     		str	r2, [r3, #8]
 567:Core/Src/motor.c ****       MS.angle_estimation = EXTRAPOLATION; // switch to angle extrapolation
 3128              		.loc 2 567 27
 3129 0222 854B     		ldr	r3, .L139+4
 3130 0224 0022     		movs	r2, #0
 3131 0226 83F83320 		strb	r2, [r3, #51]
 568:Core/Src/motor.c ****       
 569:Core/Src/motor.c ****       if ((MSP->battery_voltage * MS.u_q) >> (21 - SPEEDFILTER)) {
 3132              		.loc 2 569 15
 3133 022a FB68     		ldr	r3, [r7, #12]
 3134 022c 9B68     		ldr	r3, [r3, #8]
 3135              		.loc 2 569 37
 3136 022e 824A     		ldr	r2, .L139+4
 3137 0230 126A     		ldr	r2, [r2, #32]
 3138              		.loc 2 569 33
 3139 0232 02FB03F3 		mul	r3, r2, r3
 3140              		.loc 2 569 43
 3141 0236 9B14     		asrs	r3, r3, #18
 3142              		.loc 2 569 10
 3143 0238 002B     		cmp	r3, #0
 3144 023a 23D0     		beq	.L124
 570:Core/Src/motor.c ****         ui32_KV -= ui32_KV >> 4;
 3145              		.loc 2 570 17
 3146 023c 7F4B     		ldr	r3, .L139+8
 3147 023e B3F90030 		ldrsh	r3, [r3]
 3148 0242 9AB2     		uxth	r2, r3
 3149 0244 7D4B     		ldr	r3, .L139+8
 3150 0246 B3F90030 		ldrsh	r3, [r3]
 3151 024a 1B11     		asrs	r3, r3, #4
 3152 024c 1BB2     		sxth	r3, r3
 3153 024e 9BB2     		uxth	r3, r3
 3154 0250 D31A     		subs	r3, r2, r3
 3155 0252 9BB2     		uxth	r3, r3
 3156 0254 1AB2     		sxth	r2, r3
 3157 0256 794B     		ldr	r3, .L139+8
 3158 0258 1A80     		strh	r2, [r3]	@ movhi
 571:Core/Src/motor.c ****         ui32_KV += (uint32_SPEEDx100_cumulated) / ((MSP->battery_voltage * MS.u_q) >> (21 - SPEEDFI
 3159              		.loc 2 571 49
 3160 025a 794B     		ldr	r3, .L139+12
 3161 025c 1B68     		ldr	r3, [r3]
 3162              		.loc 2 571 56
 3163 025e FA68     		ldr	r2, [r7, #12]
 3164 0260 9268     		ldr	r2, [r2, #8]
 3165              		.loc 2 571 78
 3166 0262 7549     		ldr	r1, .L139+4
 3167 0264 096A     		ldr	r1, [r1, #32]
 3168              		.loc 2 571 74
 3169 0266 01FB02F2 		mul	r2, r1, r2
 3170              		.loc 2 571 84
 3171 026a 9214     		asrs	r2, r2, #18
 3172              		.loc 2 571 49
 3173 026c B3FBF2F3 		udiv	r3, r3, r2
 3174              		.loc 2 571 17
 3175 0270 9AB2     		uxth	r2, r3
 3176 0272 724B     		ldr	r3, .L139+8
 3177 0274 B3F90030 		ldrsh	r3, [r3]
 3178 0278 9BB2     		uxth	r3, r3
ARM GAS  /tmp/ccpEjOub.s 			page 161


 3179 027a 1344     		add	r3, r3, r2
 3180 027c 9BB2     		uxth	r3, r3
 3181 027e 1AB2     		sxth	r2, r3
 3182 0280 6E4B     		ldr	r3, .L139+8
 3183 0282 1A80     		strh	r2, [r3]	@ movhi
 3184              	.L124:
 572:Core/Src/motor.c ****       }
 573:Core/Src/motor.c **** 
 574:Core/Src/motor.c ****       if (ui16_KV_detect_counter > 200) {
 3185              		.loc 2 574 34
 3186 0284 6F4B     		ldr	r3, .L139+16
 3187 0286 1B88     		ldrh	r3, [r3]
 3188              		.loc 2 574 10
 3189 0288 C82B     		cmp	r3, #200
 3190 028a 14D9     		bls	.L125
 575:Core/Src/motor.c ****         MS.KV_detect_flag += 10 * dir;
 3191              		.loc 2 575 27
 3192 028c 6A4B     		ldr	r3, .L139+4
 3193 028e B3F93430 		ldrsh	r3, [r3, #52]
 3194 0292 9AB2     		uxth	r2, r3
 3195              		.loc 2 575 33
 3196 0294 6C4B     		ldr	r3, .L139+20
 3197 0296 93F90030 		ldrsb	r3, [r3]
 3198 029a 9BB2     		uxth	r3, r3
 3199 029c 1946     		mov	r1, r3	@ movhi
 3200 029e 8900     		lsls	r1, r1, #2
 3201 02a0 0B44     		add	r3, r3, r1
 3202 02a2 5B00     		lsls	r3, r3, #1
 3203 02a4 9BB2     		uxth	r3, r3
 3204              		.loc 2 575 27
 3205 02a6 1344     		add	r3, r3, r2
 3206 02a8 9BB2     		uxth	r3, r3
 3207 02aa 1AB2     		sxth	r2, r3
 3208 02ac 624B     		ldr	r3, .L139+4
 3209 02ae 9A86     		strh	r2, [r3, #52]	@ movhi
 576:Core/Src/motor.c ****         ui16_KV_detect_counter = 0;
 3210              		.loc 2 576 32
 3211 02b0 644B     		ldr	r3, .L139+16
 3212 02b2 0022     		movs	r2, #0
 3213 02b4 1A80     		strh	r2, [r3]	@ movhi
 3214              	.L125:
 577:Core/Src/motor.c ****       }
 578:Core/Src/motor.c **** 
 579:Core/Src/motor.c ****       if (MS.u_q > 1900) {
 3215              		.loc 2 579 13
 3216 02b6 604B     		ldr	r3, .L139+4
 3217 02b8 1B6A     		ldr	r3, [r3, #32]
 3218              		.loc 2 579 10
 3219 02ba 40F26C72 		movw	r2, #1900
 3220 02be 9342     		cmp	r3, r2
 3221 02c0 0ADD     		ble	.L126
 580:Core/Src/motor.c ****         KVtemp = ui32_KV >> 4;
 3222              		.loc 2 580 16
 3223 02c2 5E4B     		ldr	r3, .L139+8
 3224 02c4 B3F90030 		ldrsh	r3, [r3]
 3225 02c8 1B11     		asrs	r3, r3, #4
 3226 02ca 1BB2     		sxth	r3, r3
ARM GAS  /tmp/ccpEjOub.s 			page 162


 3227 02cc 9AB2     		uxth	r2, r3
 3228 02ce 5F4B     		ldr	r3, .L139+24
 3229 02d0 1A80     		strh	r2, [r3]	@ movhi
 581:Core/Src/motor.c ****         dir = -1;
 3230              		.loc 2 581 13
 3231 02d2 5D4B     		ldr	r3, .L139+20
 3232 02d4 FF22     		movs	r2, #255
 3233 02d6 1A70     		strb	r2, [r3]
 3234              	.L126:
 582:Core/Src/motor.c ****       }
 583:Core/Src/motor.c **** 
 584:Core/Src/motor.c ****       // KV detection finished
 585:Core/Src/motor.c ****       if (MS.KV_detect_flag < 20) {
 3235              		.loc 2 585 13
 3236 02d8 574B     		ldr	r3, .L139+4
 3237 02da B3F93430 		ldrsh	r3, [r3, #52]
 3238              		.loc 2 585 10
 3239 02de 132B     		cmp	r3, #19
 3240 02e0 21DC     		bgt	.L127
 586:Core/Src/motor.c ****         dir = 1;
 3241              		.loc 2 586 13
 3242 02e2 594B     		ldr	r3, .L139+20
 3243 02e4 0122     		movs	r2, #1
 3244 02e6 1A70     		strb	r2, [r3]
 587:Core/Src/motor.c ****         MS.i_q_setpoint = 0;
 3245              		.loc 2 587 25
 3246 02e8 534B     		ldr	r3, .L139+4
 3247 02ea 0022     		movs	r2, #0
 3248 02ec 9A60     		str	r2, [r3, #8]
 588:Core/Src/motor.c ****         ui32_KV = KVtemp;
 3249              		.loc 2 588 17
 3250 02ee 574B     		ldr	r3, .L139+24
 3251 02f0 1B88     		ldrh	r3, [r3]
 3252 02f2 1AB2     		sxth	r2, r3
 3253 02f4 514B     		ldr	r3, .L139+8
 3254 02f6 1A80     		strh	r2, [r3]	@ movhi
 589:Core/Src/motor.c ****         disable_pwm();
 3255              		.loc 2 589 9
 3256 02f8 FFF7FEFF 		bl	disable_pwm
 590:Core/Src/motor.c ****         MS.angle_estimation = SPEED_PLL; // switch back to config setting
 3257              		.loc 2 590 29
 3258 02fc 4E4B     		ldr	r3, .L139+4
 3259 02fe 0122     		movs	r2, #1
 3260 0300 83F83320 		strb	r2, [r3, #51]
 591:Core/Src/motor.c ****         MS.KV_detect_flag = 0;
 3261              		.loc 2 591 27
 3262 0304 4C4B     		ldr	r3, .L139+4
 3263 0306 0022     		movs	r2, #0
 3264 0308 9A86     		strh	r2, [r3, #52]	@ movhi
 592:Core/Src/motor.c ****         i8_direction = REVERSE;
 3265              		.loc 2 592 22
 3266 030a 4A4B     		ldr	r3, .L139
 3267 030c 0122     		movs	r2, #1
 3268 030e 1A70     		strb	r2, [r3]
 593:Core/Src/motor.c ****         HAL_FLASH_Unlock();
 3269              		.loc 2 593 9
 3270 0310 FFF7FEFF 		bl	HAL_FLASH_Unlock
ARM GAS  /tmp/ccpEjOub.s 			page 163


 594:Core/Src/motor.c ****         EE_WriteVariable(EEPROM_POS_KV, (int16_t) (KVtemp));
 3271              		.loc 2 594 9
 3272 0314 4D4B     		ldr	r3, .L139+24
 3273 0316 1B88     		ldrh	r3, [r3]
 3274 0318 1BB2     		sxth	r3, r3
 3275 031a 1946     		mov	r1, r3
 3276 031c 0720     		movs	r0, #7
 3277 031e FFF7FEFF 		bl	EE_WriteVariable
 595:Core/Src/motor.c ****         HAL_FLASH_Lock();
 3278              		.loc 2 595 9
 3279 0322 FFF7FEFF 		bl	HAL_FLASH_Lock
 3280              	.L127:
 596:Core/Src/motor.c ****       }
 597:Core/Src/motor.c **** 
 598:Core/Src/motor.c ****       // abort if over current
 599:Core/Src/motor.c ****       if (abs(MS.i_q > 300)) {
 3281              		.loc 2 599 17
 3282 0326 444B     		ldr	r3, .L139+4
 3283 0328 5B68     		ldr	r3, [r3, #4]
 3284              		.loc 2 599 10
 3285 032a B3F5967F 		cmp	r3, #300
 3286 032e 0BDD     		ble	.L116
 600:Core/Src/motor.c ****         MS.i_q_setpoint = 0;
 3287              		.loc 2 600 25
 3288 0330 414B     		ldr	r3, .L139+4
 3289 0332 0022     		movs	r2, #0
 3290 0334 9A60     		str	r2, [r3, #8]
 601:Core/Src/motor.c ****         disable_pwm();
 3291              		.loc 2 601 9
 3292 0336 FFF7FEFF 		bl	disable_pwm
 602:Core/Src/motor.c ****         MS.KV_detect_flag = 0;
 3293              		.loc 2 602 27
 3294 033a 3F4B     		ldr	r3, .L139+4
 3295 033c 0022     		movs	r2, #0
 3296 033e 9A86     		strh	r2, [r3, #52]	@ movhi
 603:Core/Src/motor.c ****         MS.angle_estimation = SPEED_PLL; // switch back to config setting
 3297              		.loc 2 603 29
 3298 0340 3D4B     		ldr	r3, .L139+4
 3299 0342 0122     		movs	r2, #1
 3300 0344 83F83320 		strb	r2, [r3, #51]
 3301              	.L116:
 3302              	.LBE15:
 3303              	.LBE14:
 604:Core/Src/motor.c ****       }
 605:Core/Src/motor.c ****     }
 606:Core/Src/motor.c ****   }
 607:Core/Src/motor.c **** 
 608:Core/Src/motor.c ****   uint32_SPEEDx100_cumulated -= uint32_SPEEDx100_cumulated >> SPEEDFILTER;
 3304              		.loc 2 608 30
 3305 0348 3D4B     		ldr	r3, .L139+12
 3306 034a 1A68     		ldr	r2, [r3]
 3307              		.loc 2 608 60
 3308 034c 3C4B     		ldr	r3, .L139+12
 3309 034e 1B68     		ldr	r3, [r3]
 3310 0350 DB08     		lsrs	r3, r3, #3
 3311              		.loc 2 608 30
 3312 0352 D31A     		subs	r3, r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 164


 3313 0354 3A4A     		ldr	r2, .L139+12
 3314 0356 1360     		str	r3, [r2]
 609:Core/Src/motor.c ****   uint32_SPEEDx100_cumulated += internal_tics_to_speedx100(ui16_halls_tim2tics_filtered);
 3315              		.loc 2 609 33
 3316 0358 3D4B     		ldr	r3, .L139+28
 3317 035a 1B88     		ldrh	r3, [r3]
 3318 035c 1846     		mov	r0, r3
 3319 035e FFF7FEFF 		bl	internal_tics_to_speedx100
 3320 0362 0346     		mov	r3, r0
 3321 0364 1A46     		mov	r2, r3
 3322              		.loc 2 609 30
 3323 0366 364B     		ldr	r3, .L139+12
 3324 0368 1B68     		ldr	r3, [r3]
 3325 036a 1344     		add	r3, r3, r2
 3326 036c 344A     		ldr	r2, .L139+12
 3327 036e 1360     		str	r3, [r2]
 610:Core/Src/motor.c **** 
 611:Core/Src/motor.c ****   // low pass filter next signals
 612:Core/Src/motor.c ****   static q31_t iq_cum = 0;
 613:Core/Src/motor.c ****   iq_cum -= iq_cum >> 8;
 3328              		.loc 2 613 10
 3329 0370 384B     		ldr	r3, .L139+32
 3330 0372 1A68     		ldr	r2, [r3]
 3331              		.loc 2 613 20
 3332 0374 374B     		ldr	r3, .L139+32
 3333 0376 1B68     		ldr	r3, [r3]
 3334 0378 1B12     		asrs	r3, r3, #8
 3335              		.loc 2 613 10
 3336 037a D31A     		subs	r3, r2, r3
 3337 037c 354A     		ldr	r2, .L139+32
 3338 037e 1360     		str	r3, [r2]
 614:Core/Src/motor.c ****   iq_cum += MS.i_q;
 3339              		.loc 2 614 15
 3340 0380 2D4B     		ldr	r3, .L139+4
 3341 0382 5A68     		ldr	r2, [r3, #4]
 3342              		.loc 2 614 10
 3343 0384 334B     		ldr	r3, .L139+32
 3344 0386 1B68     		ldr	r3, [r3]
 3345 0388 1344     		add	r3, r3, r2
 3346 038a 324A     		ldr	r2, .L139+32
 3347 038c 1360     		str	r3, [r2]
 615:Core/Src/motor.c ****   iq_filtered = iq_cum >> 8;
 3348              		.loc 2 615 24
 3349 038e 314B     		ldr	r3, .L139+32
 3350 0390 1B68     		ldr	r3, [r3]
 3351 0392 1B12     		asrs	r3, r3, #8
 3352              		.loc 2 615 15
 3353 0394 304A     		ldr	r2, .L139+36
 3354 0396 1360     		str	r3, [r2]
 616:Core/Src/motor.c **** 
 617:Core/Src/motor.c ****   static q31_t id_cum = 0;
 618:Core/Src/motor.c ****   id_cum -= id_cum >> 8;
 3355              		.loc 2 618 10
 3356 0398 304B     		ldr	r3, .L139+40
 3357 039a 1A68     		ldr	r2, [r3]
 3358              		.loc 2 618 20
 3359 039c 2F4B     		ldr	r3, .L139+40
ARM GAS  /tmp/ccpEjOub.s 			page 165


 3360 039e 1B68     		ldr	r3, [r3]
 3361 03a0 1B12     		asrs	r3, r3, #8
 3362              		.loc 2 618 10
 3363 03a2 D31A     		subs	r3, r2, r3
 3364 03a4 2D4A     		ldr	r2, .L139+40
 3365 03a6 1360     		str	r3, [r2]
 619:Core/Src/motor.c ****   id_cum += MS.i_d;
 3366              		.loc 2 619 15
 3367 03a8 234B     		ldr	r3, .L139+4
 3368 03aa 1A68     		ldr	r2, [r3]
 3369              		.loc 2 619 10
 3370 03ac 2B4B     		ldr	r3, .L139+40
 3371 03ae 1B68     		ldr	r3, [r3]
 3372 03b0 1344     		add	r3, r3, r2
 3373 03b2 2A4A     		ldr	r2, .L139+40
 3374 03b4 1360     		str	r3, [r2]
 620:Core/Src/motor.c ****   id_filtered = id_cum >> 8;
 3375              		.loc 2 620 24
 3376 03b6 294B     		ldr	r3, .L139+40
 3377 03b8 1B68     		ldr	r3, [r3]
 3378 03ba 1B12     		asrs	r3, r3, #8
 3379              		.loc 2 620 15
 3380 03bc 284A     		ldr	r2, .L139+44
 3381 03be 1360     		str	r3, [r2]
 621:Core/Src/motor.c **** 
 622:Core/Src/motor.c ****   static q31_t uq_cum = 0;
 623:Core/Src/motor.c ****   uq_cum -= uq_cum >> 8;
 3382              		.loc 2 623 10
 3383 03c0 284B     		ldr	r3, .L139+48
 3384 03c2 1A68     		ldr	r2, [r3]
 3385              		.loc 2 623 20
 3386 03c4 274B     		ldr	r3, .L139+48
 3387 03c6 1B68     		ldr	r3, [r3]
 3388 03c8 1B12     		asrs	r3, r3, #8
 3389              		.loc 2 623 10
 3390 03ca D31A     		subs	r3, r2, r3
 3391 03cc 254A     		ldr	r2, .L139+48
 3392 03ce 1360     		str	r3, [r2]
 624:Core/Src/motor.c ****   uq_cum += MS.u_q;
 3393              		.loc 2 624 15
 3394 03d0 194B     		ldr	r3, .L139+4
 3395 03d2 1A6A     		ldr	r2, [r3, #32]
 3396              		.loc 2 624 10
 3397 03d4 234B     		ldr	r3, .L139+48
 3398 03d6 1B68     		ldr	r3, [r3]
 3399 03d8 1344     		add	r3, r3, r2
 3400 03da 224A     		ldr	r2, .L139+48
 3401 03dc 1360     		str	r3, [r2]
 625:Core/Src/motor.c ****   uq_filtered = uq_cum >> 8;
 3402              		.loc 2 625 24
 3403 03de 214B     		ldr	r3, .L139+48
 3404 03e0 1B68     		ldr	r3, [r3]
 3405 03e2 1B12     		asrs	r3, r3, #8
 3406              		.loc 2 625 15
 3407 03e4 204A     		ldr	r2, .L139+52
 3408 03e6 1360     		str	r3, [r2]
 626:Core/Src/motor.c **** 
ARM GAS  /tmp/ccpEjOub.s 			page 166


 627:Core/Src/motor.c ****   static q31_t ud_cum = 0;
 628:Core/Src/motor.c ****   ud_cum -= ud_cum >> 8;
 3409              		.loc 2 628 10
 3410 03e8 204B     		ldr	r3, .L139+56
 3411 03ea 1A68     		ldr	r2, [r3]
 3412              		.loc 2 628 20
 3413 03ec 1F4B     		ldr	r3, .L139+56
 3414 03ee 1B68     		ldr	r3, [r3]
 3415 03f0 1B12     		asrs	r3, r3, #8
 3416              		.loc 2 628 10
 3417 03f2 D31A     		subs	r3, r2, r3
 3418 03f4 1D4A     		ldr	r2, .L139+56
 3419 03f6 1360     		str	r3, [r2]
 629:Core/Src/motor.c ****   ud_cum += MS.u_d;
 3420              		.loc 2 629 15
 3421 03f8 0F4B     		ldr	r3, .L139+4
 3422 03fa DA69     		ldr	r2, [r3, #28]
 3423              		.loc 2 629 10
 3424 03fc 1B4B     		ldr	r3, .L139+56
 3425 03fe 1B68     		ldr	r3, [r3]
 3426 0400 1344     		add	r3, r3, r2
 3427 0402 1A4A     		ldr	r2, .L139+56
 3428 0404 1360     		str	r3, [r2]
 630:Core/Src/motor.c ****   ud_filtered = ud_cum >> 8;
 3429              		.loc 2 630 24
 3430 0406 194B     		ldr	r3, .L139+56
 3431 0408 1B68     		ldr	r3, [r3]
 3432 040a 1B12     		asrs	r3, r3, #8
 3433              		.loc 2 630 15
 3434 040c 184A     		ldr	r2, .L139+60
 3435 040e 1360     		str	r3, [r2]
 631:Core/Src/motor.c **** 
 632:Core/Src/motor.c ****   MS.Battery_Current = get_battery_current(iq_filtered, id_filtered, uq_filtered, ud_filtered) * si
 3436              		.loc 2 632 24
 3437 0410 114B     		ldr	r3, .L139+36
 3438 0412 1868     		ldr	r0, [r3]
 3439 0414 124B     		ldr	r3, .L139+44
 3440 0416 1968     		ldr	r1, [r3]
 3441 0418 134B     		ldr	r3, .L139+52
 3442 041a 1A68     		ldr	r2, [r3]
 3443 041c 144B     		ldr	r3, .L139+60
 3444 041e 1B68     		ldr	r3, [r3]
 3445 0420 FFF7FEFF 		bl	get_battery_current
 3446 0424 0246     		mov	r2, r0
 3447              		.loc 2 632 98
 3448 0426 0C4B     		ldr	r3, .L139+36
 3449 0428 1B68     		ldr	r3, [r3]
 3450 042a 002B     		cmp	r3, #0
 3451 042c 22DB     		blt	.L128
 3452              		.loc 2 632 98 is_stmt 0 discriminator 1
 3453 042e 0123     		movs	r3, #1
 3454 0430 22E0     		b	.L129
 3455              	.L140:
 3456 0432 00BF     		.align	2
 3457              	.L139:
 3458 0434 00000000 		.word	i8_direction
 3459 0438 00000000 		.word	MS
ARM GAS  /tmp/ccpEjOub.s 			page 167


 3460 043c 00000000 		.word	ui32_KV
 3461 0440 00000000 		.word	uint32_SPEEDx100_cumulated
 3462 0444 00000000 		.word	ui16_KV_detect_counter
 3463 0448 00000000 		.word	dir.10077
 3464 044c 00000000 		.word	KVtemp.10078
 3465 0450 00000000 		.word	ui16_halls_tim2tics_filtered
 3466 0454 00000000 		.word	iq_cum.10079
 3467 0458 00000000 		.word	iq_filtered
 3468 045c 00000000 		.word	id_cum.10080
 3469 0460 00000000 		.word	id_filtered
 3470 0464 00000000 		.word	uq_cum.10081
 3471 0468 00000000 		.word	uq_filtered
 3472 046c 00000000 		.word	ud_cum.10082
 3473 0470 00000000 		.word	ud_filtered
 3474              	.L128:
 3475              		.loc 2 632 98 discriminator 2
 3476 0474 4FF0FF33 		mov	r3, #-1
 3477              	.L129:
 3478              		.loc 2 632 96 is_stmt 1 discriminator 4
 3479 0478 02FB03F3 		mul	r3, r2, r3
 3480              		.loc 2 632 116 discriminator 4
 3481 047c 534A     		ldr	r2, .L141
 3482 047e 92F90020 		ldrsb	r2, [r2]
 3483 0482 02FB03F3 		mul	r3, r2, r3
 3484              		.loc 2 632 131 discriminator 4
 3485 0486 524A     		ldr	r2, .L141+4
 3486 0488 92F90020 		ldrsb	r2, [r2]
 3487 048c 02FB03F3 		mul	r3, r2, r3
 3488              		.loc 2 632 22 discriminator 4
 3489 0490 504A     		ldr	r2, .L141+8
 3490 0492 9362     		str	r3, [r2, #40]
 633:Core/Src/motor.c **** 
 634:Core/Src/motor.c ****   // enable PWM if power is wanted and speed is lower than idle speed
 635:Core/Src/motor.c ****   if (MS.i_q_setpoint && pwm_is_enabled() == 0 && (uint32_SPEEDx100_cumulated >> SPEEDFILTER) * 100
 3491              		.loc 2 635 9 discriminator 4
 3492 0494 4F4B     		ldr	r3, .L141+8
 3493 0496 9B68     		ldr	r3, [r3, #8]
 3494              		.loc 2 635 6 discriminator 4
 3495 0498 002B     		cmp	r3, #0
 3496 049a 6BD0     		beq	.L130
 3497              		.loc 2 635 26 discriminator 1
 3498 049c FFF7FEFF 		bl	pwm_is_enabled
 3499 04a0 0346     		mov	r3, r0
 3500              		.loc 2 635 43 discriminator 1
 3501 04a2 83F00103 		eor	r3, r3, #1
 3502 04a6 DBB2     		uxtb	r3, r3
 3503              		.loc 2 635 23 discriminator 1
 3504 04a8 002B     		cmp	r3, #0
 3505 04aa 63D0     		beq	.L130
 3506              		.loc 2 635 79 discriminator 2
 3507 04ac 4A4B     		ldr	r3, .L141+12
 3508 04ae 1B68     		ldr	r3, [r3]
 3509 04b0 DB08     		lsrs	r3, r3, #3
 3510              		.loc 2 635 95 discriminator 2
 3511 04b2 4FF47A72 		mov	r2, #1000
 3512 04b6 02FB03F3 		mul	r3, r2, r3
 3513              		.loc 2 635 113 discriminator 2
ARM GAS  /tmp/ccpEjOub.s 			page 168


 3514 04ba 484A     		ldr	r2, .L141+16
 3515 04bc B2F90020 		ldrsh	r2, [r2]
 3516 04c0 1146     		mov	r1, r2
 3517              		.loc 2 635 118 discriminator 2
 3518 04c2 FA68     		ldr	r2, [r7, #12]
 3519 04c4 9268     		ldr	r2, [r2, #8]
 3520              		.loc 2 635 113 discriminator 2
 3521 04c6 02FB01F2 		mul	r2, r2, r1
 3522              		.loc 2 635 48 discriminator 2
 3523 04ca 9342     		cmp	r3, r2
 3524 04cc 52D2     		bcs	.L130
 636:Core/Src/motor.c ****     
 637:Core/Src/motor.c ****     // set initial PWM values
 638:Core/Src/motor.c ****     TIM1->CCR1 = 1023; 
 3525              		.loc 2 638 9
 3526 04ce 444B     		ldr	r3, .L141+20
 3527              		.loc 2 638 16
 3528 04d0 40F2FF32 		movw	r2, #1023
 3529 04d4 5A63     		str	r2, [r3, #52]
 639:Core/Src/motor.c ****     TIM1->CCR2 = 1023;
 3530              		.loc 2 639 9
 3531 04d6 424B     		ldr	r3, .L141+20
 3532              		.loc 2 639 16
 3533 04d8 40F2FF32 		movw	r2, #1023
 3534 04dc 9A63     		str	r2, [r3, #56]
 640:Core/Src/motor.c ****     TIM1->CCR3 = 1023;
 3535              		.loc 2 640 9
 3536 04de 404B     		ldr	r3, .L141+20
 3537              		.loc 2 640 16
 3538 04e0 40F2FF32 		movw	r2, #1023
 3539 04e4 DA63     		str	r2, [r3, #60]
 641:Core/Src/motor.c ****     
 642:Core/Src/motor.c ****     uint16_half_rotation_counter = 0;
 3540              		.loc 2 642 34
 3541 04e6 3F4B     		ldr	r3, .L141+24
 3542 04e8 0022     		movs	r2, #0
 3543 04ea 1A80     		strh	r2, [r3]	@ movhi
 643:Core/Src/motor.c ****     uint16_full_rotation_counter = 0;
 3544              		.loc 2 643 34
 3545 04ec 3E4B     		ldr	r3, .L141+28
 3546 04ee 0022     		movs	r2, #0
 3547 04f0 1A80     		strh	r2, [r3]	@ movhi
 644:Core/Src/motor.c ****     __HAL_TIM_SET_COUNTER(&htim2, 0); //reset tim2 counter
 3548              		.loc 2 644 5
 3549 04f2 3E4B     		ldr	r3, .L141+32
 3550 04f4 1B68     		ldr	r3, [r3]
 3551 04f6 0022     		movs	r2, #0
 3552 04f8 5A62     		str	r2, [r3, #36]
 645:Core/Src/motor.c ****     ui16_halls_tim2tics = 40000; //set interval between two hallevents to a large value
 3553              		.loc 2 645 25
 3554 04fa 3D4B     		ldr	r3, .L141+36
 3555 04fc 49F64042 		movw	r2, #40000
 3556 0500 1A80     		strh	r2, [r3]	@ movhi
 646:Core/Src/motor.c ****     i8_recent_rotor_direction = i8_direction * i8_reverse_flag;
 3557              		.loc 2 646 46
 3558 0502 324B     		ldr	r3, .L141
 3559 0504 93F90030 		ldrsb	r3, [r3]
ARM GAS  /tmp/ccpEjOub.s 			page 169


 3560 0508 DBB2     		uxtb	r3, r3
 3561 050a 314A     		ldr	r2, .L141+4
 3562 050c 92F90020 		ldrsb	r2, [r2]
 3563 0510 D2B2     		uxtb	r2, r2
 3564 0512 02FB03F3 		mul	r3, r2, r3
 3565 0516 DBB2     		uxtb	r3, r3
 3566 0518 5AB2     		sxtb	r2, r3
 3567              		.loc 2 646 31
 3568 051a 364B     		ldr	r3, .L141+40
 3569 051c 1A70     		strb	r2, [r3]
 647:Core/Src/motor.c ****     enable_pwm();
 3570              		.loc 2 647 5
 3571 051e FFF7FEFF 		bl	enable_pwm
 648:Core/Src/motor.c **** 
 649:Core/Src/motor.c ****     if (MS.system_state == Stop) {
 3572              		.loc 2 649 11
 3573 0522 2C4B     		ldr	r3, .L141+8
 3574 0524 93F92D30 		ldrsb	r3, [r3, #45]
 3575              		.loc 2 649 8
 3576 0528 002B     		cmp	r3, #0
 3577 052a 04D1     		bne	.L131
 650:Core/Src/motor.c ****       speed_PLL(0, 0); //reset integral part
 3578              		.loc 2 650 7
 3579 052c 0021     		movs	r1, #0
 3580 052e 0020     		movs	r0, #0
 3581 0530 FFF7FEFF 		bl	speed_PLL
 3582 0534 1BE0     		b	.L132
 3583              	.L131:
 651:Core/Src/motor.c ****     } else {
 652:Core/Src/motor.c ****       PI_iq.integral_part = (((uint32_SPEEDx100_cumulated >> SPEEDFILTER) << 11) * 1000 / (ui32_KV 
 3584              		.loc 2 652 59
 3585 0536 284B     		ldr	r3, .L141+12
 3586 0538 1B68     		ldr	r3, [r3]
 3587 053a DB08     		lsrs	r3, r3, #3
 3588              		.loc 2 652 82
 3589 053c 4FF4FA12 		mov	r2, #2048000
 3590 0540 02FB03F3 		mul	r3, r2, r3
 3591              		.loc 2 652 100
 3592 0544 254A     		ldr	r2, .L141+16
 3593 0546 B2F90020 		ldrsh	r2, [r2]
 3594 054a 1146     		mov	r1, r2
 3595              		.loc 2 652 105
 3596 054c FA68     		ldr	r2, [r7, #12]
 3597 054e 9268     		ldr	r2, [r2, #8]
 3598              		.loc 2 652 100
 3599 0550 02FB01F2 		mul	r2, r2, r1
 3600              		.loc 2 652 89
 3601 0554 B3FBF2F3 		udiv	r3, r3, r2
 3602              		.loc 2 652 133
 3603 0558 274A     		ldr	r2, .L141+44
 3604 055a 92F91C20 		ldrsb	r2, [r2, #28]
 3605              		.loc 2 652 125
 3606 055e 9340     		lsls	r3, r3, r2
 3607 0560 1A46     		mov	r2, r3
 3608              		.loc 2 652 27
 3609 0562 254B     		ldr	r3, .L141+44
 3610 0564 1A61     		str	r2, [r3, #16]
ARM GAS  /tmp/ccpEjOub.s 			page 170


 653:Core/Src/motor.c ****       PI_iq.out = PI_iq.integral_part;
 3611              		.loc 2 653 24
 3612 0566 244B     		ldr	r3, .L141+44
 3613 0568 1B69     		ldr	r3, [r3, #16]
 3614              		.loc 2 653 17
 3615 056a 234A     		ldr	r2, .L141+44
 3616 056c 9361     		str	r3, [r2, #24]
 3617              	.L132:
 654:Core/Src/motor.c ****     }
 655:Core/Src/motor.c **** 
 656:Core/Src/motor.c ****     get_standstill_position();
 3618              		.loc 2 656 5
 3619 056e FFF7FEFF 		bl	get_standstill_position
 657:Core/Src/motor.c ****     
 658:Core/Src/motor.c ****   } else {
 659:Core/Src/motor.c **** #ifdef KILL_ON_ZERO
 660:Core/Src/motor.c ****                 if(uint16_mapped_throttle==0&&READ_BIT(TIM1->BDTR, TIM_BDTR_MOE)){
 661:Core/Src/motor.c ****       CLEAR_BIT(TIM1->BDTR, TIM_BDTR_MOE); //Disable PWM if motor is not turning
 662:Core/Src/motor.c ****       get_standstill_position();
 663:Core/Src/motor.c ****                         printf_("shutdown %d\n", q31_rotorposition_absolute);
 664:Core/Src/motor.c ****                 }
 665:Core/Src/motor.c **** #endif
 666:Core/Src/motor.c **** 
 667:Core/Src/motor.c ****     // calculate wheel speed
 668:Core/Src/motor.c ****     MSP->speed = tics_to_speed(ui16_halls_tim2tics_filtered);
 669:Core/Src/motor.c **** 
 670:Core/Src/motor.c ****     // see if PWM should be disable
 671:Core/Src/motor.c ****     if (MS.i_q_setpoint == 0 && (uint16_full_rotation_counter > 7999 || uint16_half_rotation_counte
 672:Core/Src/motor.c **** 
 673:Core/Src/motor.c ****       if (pwm_is_enabled()) {
 674:Core/Src/motor.c ****         disable_pwm();
 675:Core/Src/motor.c ****         get_standstill_position();
 676:Core/Src/motor.c ****       }
 677:Core/Src/motor.c **** 
 678:Core/Src/motor.c ****       MSP->speed = 0;
 679:Core/Src/motor.c ****       MS.system_state = Stop;
 680:Core/Src/motor.c ****     }
 681:Core/Src/motor.c ****   }
 682:Core/Src/motor.c **** }
 3620              		.loc 2 682 1
 3621 0572 26E0     		b	.L136
 3622              	.L130:
 668:Core/Src/motor.c **** 
 3623              		.loc 2 668 18
 3624 0574 214B     		ldr	r3, .L141+48
 3625 0576 1B88     		ldrh	r3, [r3]
 3626 0578 1846     		mov	r0, r3
 3627 057a FFF7FEFF 		bl	tics_to_speed
 3628 057e 0346     		mov	r3, r0
 3629 0580 1A46     		mov	r2, r3
 668:Core/Src/motor.c **** 
 3630              		.loc 2 668 16
 3631 0582 FB68     		ldr	r3, [r7, #12]
 3632 0584 5A62     		str	r2, [r3, #36]
 671:Core/Src/motor.c **** 
 3633              		.loc 2 671 11
 3634 0586 134B     		ldr	r3, .L141+8
ARM GAS  /tmp/ccpEjOub.s 			page 171


 3635 0588 9B68     		ldr	r3, [r3, #8]
 671:Core/Src/motor.c **** 
 3636              		.loc 2 671 8
 3637 058a 002B     		cmp	r3, #0
 3638 058c 19D1     		bne	.L136
 671:Core/Src/motor.c **** 
 3639              		.loc 2 671 63 discriminator 1
 3640 058e 164B     		ldr	r3, .L141+28
 3641 0590 1B88     		ldrh	r3, [r3]
 671:Core/Src/motor.c **** 
 3642              		.loc 2 671 30 discriminator 1
 3643 0592 B3F5FA5F 		cmp	r3, #8000
 3644 0596 04D2     		bcs	.L134
 671:Core/Src/motor.c **** 
 3645              		.loc 2 671 102 discriminator 2
 3646 0598 124B     		ldr	r3, .L141+24
 3647 059a 1B88     		ldrh	r3, [r3]
 671:Core/Src/motor.c **** 
 3648              		.loc 2 671 70 discriminator 2
 3649 059c B3F5FA5F 		cmp	r3, #8000
 3650 05a0 0FD3     		bcc	.L136
 3651              	.L134:
 673:Core/Src/motor.c ****         disable_pwm();
 3652              		.loc 2 673 11
 3653 05a2 FFF7FEFF 		bl	pwm_is_enabled
 3654 05a6 0346     		mov	r3, r0
 673:Core/Src/motor.c ****         disable_pwm();
 3655              		.loc 2 673 10
 3656 05a8 002B     		cmp	r3, #0
 3657 05aa 03D0     		beq	.L135
 674:Core/Src/motor.c ****         get_standstill_position();
 3658              		.loc 2 674 9
 3659 05ac FFF7FEFF 		bl	disable_pwm
 675:Core/Src/motor.c ****       }
 3660              		.loc 2 675 9
 3661 05b0 FFF7FEFF 		bl	get_standstill_position
 3662              	.L135:
 678:Core/Src/motor.c ****       MS.system_state = Stop;
 3663              		.loc 2 678 18
 3664 05b4 FB68     		ldr	r3, [r7, #12]
 3665 05b6 0022     		movs	r2, #0
 3666 05b8 5A62     		str	r2, [r3, #36]
 679:Core/Src/motor.c ****     }
 3667              		.loc 2 679 23
 3668 05ba 064B     		ldr	r3, .L141+8
 3669 05bc 0022     		movs	r2, #0
 3670 05be 83F82D20 		strb	r2, [r3, #45]
 3671              	.L136:
 3672              		.loc 2 682 1
 3673 05c2 00BF     		nop
 3674 05c4 1437     		adds	r7, r7, #20
 3675              	.LCFI107:
 3676              		.cfi_def_cfa_offset 12
 3677 05c6 BD46     		mov	sp, r7
 3678              	.LCFI108:
 3679              		.cfi_def_cfa_register 13
 3680              		@ sp needed
ARM GAS  /tmp/ccpEjOub.s 			page 172


 3681 05c8 90BD     		pop	{r4, r7, pc}
 3682              	.L142:
 3683 05ca 00BF     		.align	2
 3684              	.L141:
 3685 05cc 00000000 		.word	i8_direction
 3686 05d0 00000000 		.word	i8_reverse_flag
 3687 05d4 00000000 		.word	MS
 3688 05d8 00000000 		.word	uint32_SPEEDx100_cumulated
 3689 05dc 00000000 		.word	ui32_KV
 3690 05e0 002C0140 		.word	1073818624
 3691 05e4 00000000 		.word	uint16_half_rotation_counter
 3692 05e8 00000000 		.word	uint16_full_rotation_counter
 3693 05ec 00000000 		.word	htim2
 3694 05f0 00000000 		.word	ui16_halls_tim2tics
 3695 05f4 00000000 		.word	i8_recent_rotor_direction
 3696 05f8 00000000 		.word	PI_iq
 3697 05fc 00000000 		.word	ui16_halls_tim2tics_filtered
 3698              		.cfi_endproc
 3699              	.LFE135:
 3701              		.section	.text.DMA_Init,"ax",%progbits
 3702              		.align	1
 3703              		.syntax unified
 3704              		.thumb
 3705              		.thumb_func
 3706              		.fpu softvfp
 3708              	DMA_Init:
 3709              	.LFB136:
 683:Core/Src/motor.c **** 
 684:Core/Src/motor.c **** /**
 685:Core/Src/motor.c ****  * Enable DMA controller clock
 686:Core/Src/motor.c ****  */
 687:Core/Src/motor.c **** static void DMA_Init(void) {
 3710              		.loc 2 687 28
 3711              		.cfi_startproc
 3712              		@ args = 0, pretend = 0, frame = 8
 3713              		@ frame_needed = 1, uses_anonymous_args = 0
 3714 0000 80B5     		push	{r7, lr}
 3715              	.LCFI109:
 3716              		.cfi_def_cfa_offset 8
 3717              		.cfi_offset 7, -8
 3718              		.cfi_offset 14, -4
 3719 0002 82B0     		sub	sp, sp, #8
 3720              	.LCFI110:
 3721              		.cfi_def_cfa_offset 16
 3722 0004 00AF     		add	r7, sp, #0
 3723              	.LCFI111:
 3724              		.cfi_def_cfa_register 7
 3725              	.LBB16:
 688:Core/Src/motor.c **** 
 689:Core/Src/motor.c **** 	/* DMA controller clock enable */
 690:Core/Src/motor.c **** 	__HAL_RCC_DMA1_CLK_ENABLE();
 3726              		.loc 2 690 2
 3727 0006 0C4B     		ldr	r3, .L144
 3728 0008 5B69     		ldr	r3, [r3, #20]
 3729 000a 0B4A     		ldr	r2, .L144
 3730 000c 43F00103 		orr	r3, r3, #1
 3731 0010 5361     		str	r3, [r2, #20]
ARM GAS  /tmp/ccpEjOub.s 			page 173


 3732 0012 094B     		ldr	r3, .L144
 3733 0014 5B69     		ldr	r3, [r3, #20]
 3734 0016 03F00103 		and	r3, r3, #1
 3735 001a 7B60     		str	r3, [r7, #4]
 3736 001c 7B68     		ldr	r3, [r7, #4]
 3737              	.LBE16:
 691:Core/Src/motor.c **** 
 692:Core/Src/motor.c **** 	// DMA channel 1: used for ADC
 693:Core/Src/motor.c ****   /* DMA1_Channel1_IRQn interrupt configuration */
 694:Core/Src/motor.c **** 	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 3738              		.loc 2 694 2
 3739 001e 0022     		movs	r2, #0
 3740 0020 0021     		movs	r1, #0
 3741 0022 0B20     		movs	r0, #11
 3742 0024 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 695:Core/Src/motor.c **** 	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 3743              		.loc 2 695 2
 3744 0028 0B20     		movs	r0, #11
 3745 002a FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 696:Core/Src/motor.c **** }
 3746              		.loc 2 696 1
 3747 002e 00BF     		nop
 3748 0030 0837     		adds	r7, r7, #8
 3749              	.LCFI112:
 3750              		.cfi_def_cfa_offset 8
 3751 0032 BD46     		mov	sp, r7
 3752              	.LCFI113:
 3753              		.cfi_def_cfa_register 13
 3754              		@ sp needed
 3755 0034 80BD     		pop	{r7, pc}
 3756              	.L145:
 3757 0036 00BF     		.align	2
 3758              	.L144:
 3759 0038 00100240 		.word	1073876992
 3760              		.cfi_endproc
 3761              	.LFE136:
 3763              		.section	.rodata
 3764              		.align	2
 3765              	.LC0:
 3766 0000 436F7265 		.ascii	"Core/Src/motor.c\000"
 3766      2F537263 
 3766      2F6D6F74 
 3766      6F722E63 
 3766      00
 3767              		.section	.text.ADC1_Init,"ax",%progbits
 3768              		.align	1
 3769              		.syntax unified
 3770              		.thumb
 3771              		.thumb_func
 3772              		.fpu softvfp
 3774              	ADC1_Init:
 3775              	.LFB137:
 697:Core/Src/motor.c **** 
 698:Core/Src/motor.c **** /**
 699:Core/Src/motor.c ****  * @brief ADC1 Initialization Function
 700:Core/Src/motor.c ****  * @param None
 701:Core/Src/motor.c ****  * @retval None
ARM GAS  /tmp/ccpEjOub.s 			page 174


 702:Core/Src/motor.c ****  */
 703:Core/Src/motor.c **** static void ADC1_Init(void) {
 3776              		.loc 2 703 29
 3777              		.cfi_startproc
 3778              		@ args = 0, pretend = 0, frame = 48
 3779              		@ frame_needed = 1, uses_anonymous_args = 0
 3780 0000 80B5     		push	{r7, lr}
 3781              	.LCFI114:
 3782              		.cfi_def_cfa_offset 8
 3783              		.cfi_offset 7, -8
 3784              		.cfi_offset 14, -4
 3785 0002 8CB0     		sub	sp, sp, #48
 3786              	.LCFI115:
 3787              		.cfi_def_cfa_offset 56
 3788 0004 00AF     		add	r7, sp, #0
 3789              	.LCFI116:
 3790              		.cfi_def_cfa_register 7
 704:Core/Src/motor.c **** 	/**Common config
 705:Core/Src/motor.c **** 	 */
 706:Core/Src/motor.c **** 	hadc1.Instance = ADC1;
 3791              		.loc 2 706 17
 3792 0006 684B     		ldr	r3, .L157
 3793 0008 684A     		ldr	r2, .L157+4
 3794 000a 1A60     		str	r2, [r3]
 707:Core/Src/motor.c **** 	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 3795              		.loc 2 707 26
 3796 000c 664B     		ldr	r3, .L157
 3797 000e 4FF48072 		mov	r2, #256
 3798 0012 9A60     		str	r2, [r3, #8]
 708:Core/Src/motor.c **** 	hadc1.Init.ContinuousConvMode = DISABLE;
 3799              		.loc 2 708 32
 3800 0014 644B     		ldr	r3, .L157
 3801 0016 0022     		movs	r2, #0
 3802 0018 1A73     		strb	r2, [r3, #12]
 709:Core/Src/motor.c **** 	hadc1.Init.DiscontinuousConvMode = DISABLE;
 3803              		.loc 2 709 35
 3804 001a 634B     		ldr	r3, .L157
 3805 001c 0022     		movs	r2, #0
 3806 001e 1A75     		strb	r2, [r3, #20]
 710:Core/Src/motor.c ****   hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T3_TRGO;
 3807              		.loc 2 710 31
 3808 0020 614B     		ldr	r3, .L157
 3809 0022 4FF40022 		mov	r2, #524288
 3810 0026 DA61     		str	r2, [r3, #28]
 711:Core/Src/motor.c **** 	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 3811              		.loc 2 711 23
 3812 0028 5F4B     		ldr	r3, .L157
 3813 002a 0022     		movs	r2, #0
 3814 002c 5A60     		str	r2, [r3, #4]
 712:Core/Src/motor.c **** 	hadc1.Init.NbrOfConversion = 6;
 3815              		.loc 2 712 29
 3816 002e 5E4B     		ldr	r3, .L157
 3817 0030 0622     		movs	r2, #6
 3818 0032 1A61     		str	r2, [r3, #16]
 713:Core/Src/motor.c **** 	hadc1.Init.NbrOfDiscConversion = 0;
 3819              		.loc 2 713 33
 3820 0034 5C4B     		ldr	r3, .L157
ARM GAS  /tmp/ccpEjOub.s 			page 175


 3821 0036 0022     		movs	r2, #0
 3822 0038 9A61     		str	r2, [r3, #24]
 714:Core/Src/motor.c **** 
 715:Core/Src/motor.c **** 	if (HAL_ADC_Init(&hadc1) != HAL_OK) {
 3823              		.loc 2 715 6
 3824 003a 5B48     		ldr	r0, .L157
 3825 003c FFF7FEFF 		bl	HAL_ADC_Init
 3826 0040 0346     		mov	r3, r0
 3827              		.loc 2 715 5
 3828 0042 002B     		cmp	r3, #0
 3829 0044 04D0     		beq	.L147
 716:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3830              		.loc 2 716 3
 3831 0046 4FF43371 		mov	r1, #716
 3832 004a 5948     		ldr	r0, .L157+8
 3833 004c FFF7FEFF 		bl	_motor_error_handler
 3834              	.L147:
 717:Core/Src/motor.c **** 	}
 718:Core/Src/motor.c **** 
 719:Core/Src/motor.c **** 	/**Configure the ADC multi-mode
 720:Core/Src/motor.c **** 	 */
 721:Core/Src/motor.c ****   ADC_MultiModeTypeDef multimode;
 722:Core/Src/motor.c **** 	multimode.Mode = ADC_DUALMODE_REGSIMULT_INJECSIMULT;
 3835              		.loc 2 722 17
 3836 0050 4FF48033 		mov	r3, #65536
 3837 0054 FB62     		str	r3, [r7, #44]
 723:Core/Src/motor.c **** 	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK) {
 3838              		.loc 2 723 6
 3839 0056 07F12C03 		add	r3, r7, #44
 3840 005a 1946     		mov	r1, r3
 3841 005c 5248     		ldr	r0, .L157
 3842 005e FFF7FEFF 		bl	HAL_ADCEx_MultiModeConfigChannel
 3843 0062 0346     		mov	r3, r0
 3844              		.loc 2 723 5
 3845 0064 002B     		cmp	r3, #0
 3846 0066 04D0     		beq	.L148
 724:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3847              		.loc 2 724 3
 3848 0068 4FF43571 		mov	r1, #724
 3849 006c 5048     		ldr	r0, .L157+8
 3850 006e FFF7FEFF 		bl	_motor_error_handler
 3851              	.L148:
 725:Core/Src/motor.c **** 	}
 726:Core/Src/motor.c **** 
 727:Core/Src/motor.c **** 	/**Configure Injected Channel
 728:Core/Src/motor.c **** 	 */
 729:Core/Src/motor.c ****   ADC_InjectionConfTypeDef sConfigInjected;
 730:Core/Src/motor.c **** 	sConfigInjected.InjectedChannel = ADC_CHANNEL_3;
 3852              		.loc 2 730 34
 3853 0072 0323     		movs	r3, #3
 3854 0074 3B61     		str	r3, [r7, #16]
 731:Core/Src/motor.c **** 	sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 3855              		.loc 2 731 31
 3856 0076 0123     		movs	r3, #1
 3857 0078 7B61     		str	r3, [r7, #20]
 732:Core/Src/motor.c **** 	sConfigInjected.InjectedNbrOfConversion = 1;
 3858              		.loc 2 732 42
ARM GAS  /tmp/ccpEjOub.s 			page 176


 3859 007a 0123     		movs	r3, #1
 3860 007c 3B62     		str	r3, [r7, #32]
 733:Core/Src/motor.c **** 	sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 3861              		.loc 2 733 39
 3862 007e 0023     		movs	r3, #0
 3863 0080 BB61     		str	r3, [r7, #24]
 734:Core/Src/motor.c **** 	sConfigInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T1_CC4; // Hier bin ich nicht si
 3864              		.loc 2 734 40
 3865 0082 4FF48053 		mov	r3, #4096
 3866 0086 BB62     		str	r3, [r7, #40]
 735:Core/Src/motor.c **** 	sConfigInjected.AutoInjectedConv = DISABLE; //mu aus sein
 3867              		.loc 2 735 35
 3868 0088 0023     		movs	r3, #0
 3869 008a 87F82530 		strb	r3, [r7, #37]
 736:Core/Src/motor.c **** 	sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 3870              		.loc 2 736 48
 3871 008e 0023     		movs	r3, #0
 3872 0090 87F82430 		strb	r3, [r7, #36]
 737:Core/Src/motor.c **** 	sConfigInjected.InjectedOffset = 0;
 3873              		.loc 2 737 33
 3874 0094 0023     		movs	r3, #0
 3875 0096 FB61     		str	r3, [r7, #28]
 738:Core/Src/motor.c **** 	HAL_ADC_Stop(&hadc1); //ADC mu gestoppt sein, damit Triggerquelle gesetzt werden kann.
 3876              		.loc 2 738 2
 3877 0098 4348     		ldr	r0, .L157
 3878 009a FFF7FEFF 		bl	HAL_ADC_Stop
 739:Core/Src/motor.c **** 	if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK) {
 3879              		.loc 2 739 6
 3880 009e 07F11003 		add	r3, r7, #16
 3881 00a2 1946     		mov	r1, r3
 3882 00a4 4048     		ldr	r0, .L157
 3883 00a6 FFF7FEFF 		bl	HAL_ADCEx_InjectedConfigChannel
 3884 00aa 0346     		mov	r3, r0
 3885              		.loc 2 739 5
 3886 00ac 002B     		cmp	r3, #0
 3887 00ae 04D0     		beq	.L149
 740:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3888              		.loc 2 740 3
 3889 00b0 4FF43971 		mov	r1, #740
 3890 00b4 3E48     		ldr	r0, .L157+8
 3891 00b6 FFF7FEFF 		bl	_motor_error_handler
 3892              	.L149:
 741:Core/Src/motor.c **** 	}
 742:Core/Src/motor.c **** 
 743:Core/Src/motor.c **** 	/**Configure Regular Channel
 744:Core/Src/motor.c **** 	 */
 745:Core/Src/motor.c ****   ADC_ChannelConfTypeDef sConfig;
 746:Core/Src/motor.c **** 	sConfig.Channel = ADC_CHANNEL_2;
 3893              		.loc 2 746 18
 3894 00ba 0223     		movs	r3, #2
 3895 00bc 7B60     		str	r3, [r7, #4]
 747:Core/Src/motor.c **** 	sConfig.Rank = ADC_REGULAR_RANK_1;
 3896              		.loc 2 747 15
 3897 00be 0123     		movs	r3, #1
 3898 00c0 BB60     		str	r3, [r7, #8]
 748:Core/Src/motor.c **** 	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 3899              		.loc 2 748 23
ARM GAS  /tmp/ccpEjOub.s 			page 177


 3900 00c2 0023     		movs	r3, #0
 3901 00c4 FB60     		str	r3, [r7, #12]
 749:Core/Src/motor.c **** 	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 3902              		.loc 2 749 6
 3903 00c6 3B1D     		adds	r3, r7, #4
 3904 00c8 1946     		mov	r1, r3
 3905 00ca 3748     		ldr	r0, .L157
 3906 00cc FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 3907 00d0 0346     		mov	r3, r0
 3908              		.loc 2 749 5
 3909 00d2 002B     		cmp	r3, #0
 3910 00d4 04D0     		beq	.L150
 750:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3911              		.loc 2 750 3
 3912 00d6 40F2EE21 		movw	r1, #750
 3913 00da 3548     		ldr	r0, .L157+8
 3914 00dc FFF7FEFF 		bl	_motor_error_handler
 3915              	.L150:
 751:Core/Src/motor.c **** 	}
 752:Core/Src/motor.c **** 
 753:Core/Src/motor.c **** 	/**Configure Regular Channel
 754:Core/Src/motor.c **** 	 */
 755:Core/Src/motor.c **** 	sConfig.Channel = ADC_CHANNEL_7;
 3916              		.loc 2 755 18
 3917 00e0 0723     		movs	r3, #7
 3918 00e2 7B60     		str	r3, [r7, #4]
 756:Core/Src/motor.c **** 	sConfig.Rank = ADC_REGULAR_RANK_2;
 3919              		.loc 2 756 15
 3920 00e4 0223     		movs	r3, #2
 3921 00e6 BB60     		str	r3, [r7, #8]
 757:Core/Src/motor.c **** 	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 3922              		.loc 2 757 23
 3923 00e8 0023     		movs	r3, #0
 3924 00ea FB60     		str	r3, [r7, #12]
 758:Core/Src/motor.c **** 	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 3925              		.loc 2 758 6
 3926 00ec 3B1D     		adds	r3, r7, #4
 3927 00ee 1946     		mov	r1, r3
 3928 00f0 2D48     		ldr	r0, .L157
 3929 00f2 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 3930 00f6 0346     		mov	r3, r0
 3931              		.loc 2 758 5
 3932 00f8 002B     		cmp	r3, #0
 3933 00fa 04D0     		beq	.L151
 759:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3934              		.loc 2 759 3
 3935 00fc 40F2F721 		movw	r1, #759
 3936 0100 2B48     		ldr	r0, .L157+8
 3937 0102 FFF7FEFF 		bl	_motor_error_handler
 3938              	.L151:
 760:Core/Src/motor.c **** 	}
 761:Core/Src/motor.c **** 	/**Configure Regular Channel
 762:Core/Src/motor.c **** 	 */
 763:Core/Src/motor.c **** 	sConfig.Channel = ADC_CHANNEL_0;
 3939              		.loc 2 763 18
 3940 0106 0023     		movs	r3, #0
 3941 0108 7B60     		str	r3, [r7, #4]
ARM GAS  /tmp/ccpEjOub.s 			page 178


 764:Core/Src/motor.c **** 	sConfig.Rank = ADC_REGULAR_RANK_3;
 3942              		.loc 2 764 15
 3943 010a 0323     		movs	r3, #3
 3944 010c BB60     		str	r3, [r7, #8]
 765:Core/Src/motor.c **** 	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 3945              		.loc 2 765 23
 3946 010e 0023     		movs	r3, #0
 3947 0110 FB60     		str	r3, [r7, #12]
 766:Core/Src/motor.c **** 	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 3948              		.loc 2 766 6
 3949 0112 3B1D     		adds	r3, r7, #4
 3950 0114 1946     		mov	r1, r3
 3951 0116 2448     		ldr	r0, .L157
 3952 0118 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 3953 011c 0346     		mov	r3, r0
 3954              		.loc 2 766 5
 3955 011e 002B     		cmp	r3, #0
 3956 0120 04D0     		beq	.L152
 767:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3957              		.loc 2 767 3
 3958 0122 40F2FF21 		movw	r1, #767
 3959 0126 2248     		ldr	r0, .L157+8
 3960 0128 FFF7FEFF 		bl	_motor_error_handler
 3961              	.L152:
 768:Core/Src/motor.c **** 	}
 769:Core/Src/motor.c **** 	/**Configure Regular Channel
 770:Core/Src/motor.c **** 	 */
 771:Core/Src/motor.c **** 	sConfig.Channel = JSQR_PHASE_A >> 15;
 3962              		.loc 2 771 18
 3963 012c 0323     		movs	r3, #3
 3964 012e 7B60     		str	r3, [r7, #4]
 772:Core/Src/motor.c **** 	sConfig.Rank = ADC_REGULAR_RANK_4;
 3965              		.loc 2 772 15
 3966 0130 0423     		movs	r3, #4
 3967 0132 BB60     		str	r3, [r7, #8]
 773:Core/Src/motor.c **** 	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 3968              		.loc 2 773 23
 3969 0134 0023     		movs	r3, #0
 3970 0136 FB60     		str	r3, [r7, #12]
 774:Core/Src/motor.c **** 	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 3971              		.loc 2 774 6
 3972 0138 3B1D     		adds	r3, r7, #4
 3973 013a 1946     		mov	r1, r3
 3974 013c 1A48     		ldr	r0, .L157
 3975 013e FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 3976 0142 0346     		mov	r3, r0
 3977              		.loc 2 774 5
 3978 0144 002B     		cmp	r3, #0
 3979 0146 04D0     		beq	.L153
 775:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 3980              		.loc 2 775 3
 3981 0148 40F20731 		movw	r1, #775
 3982 014c 1848     		ldr	r0, .L157+8
 3983 014e FFF7FEFF 		bl	_motor_error_handler
 3984              	.L153:
 776:Core/Src/motor.c **** 	}
 777:Core/Src/motor.c **** 	/**Configure Regular Channel
ARM GAS  /tmp/ccpEjOub.s 			page 179


 778:Core/Src/motor.c **** 	 */
 779:Core/Src/motor.c **** 	sConfig.Channel = JSQR_PHASE_B >> 15;
 3985              		.loc 2 779 18
 3986 0152 0423     		movs	r3, #4
 3987 0154 7B60     		str	r3, [r7, #4]
 780:Core/Src/motor.c **** 	sConfig.Rank = ADC_REGULAR_RANK_5;
 3988              		.loc 2 780 15
 3989 0156 0523     		movs	r3, #5
 3990 0158 BB60     		str	r3, [r7, #8]
 781:Core/Src/motor.c **** 	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 3991              		.loc 2 781 23
 3992 015a 0023     		movs	r3, #0
 3993 015c FB60     		str	r3, [r7, #12]
 782:Core/Src/motor.c **** 	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 3994              		.loc 2 782 6
 3995 015e 3B1D     		adds	r3, r7, #4
 3996 0160 1946     		mov	r1, r3
 3997 0162 1148     		ldr	r0, .L157
 3998 0164 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 3999 0168 0346     		mov	r3, r0
 4000              		.loc 2 782 5
 4001 016a 002B     		cmp	r3, #0
 4002 016c 04D0     		beq	.L154
 783:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4003              		.loc 2 783 3
 4004 016e 40F20F31 		movw	r1, #783
 4005 0172 0F48     		ldr	r0, .L157+8
 4006 0174 FFF7FEFF 		bl	_motor_error_handler
 4007              	.L154:
 784:Core/Src/motor.c **** 	}
 785:Core/Src/motor.c **** 
 786:Core/Src/motor.c **** 	sConfig.Channel = JSQR_PHASE_C >> 15;
 4008              		.loc 2 786 18
 4009 0178 0523     		movs	r3, #5
 4010 017a 7B60     		str	r3, [r7, #4]
 787:Core/Src/motor.c **** 	sConfig.Rank = ADC_REGULAR_RANK_6;
 4011              		.loc 2 787 15
 4012 017c 0623     		movs	r3, #6
 4013 017e BB60     		str	r3, [r7, #8]
 788:Core/Src/motor.c **** 	sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 4014              		.loc 2 788 23
 4015 0180 0023     		movs	r3, #0
 4016 0182 FB60     		str	r3, [r7, #12]
 789:Core/Src/motor.c **** 	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
 4017              		.loc 2 789 6
 4018 0184 3B1D     		adds	r3, r7, #4
 4019 0186 1946     		mov	r1, r3
 4020 0188 0748     		ldr	r0, .L157
 4021 018a FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 4022 018e 0346     		mov	r3, r0
 4023              		.loc 2 789 5
 4024 0190 002B     		cmp	r3, #0
 4025 0192 04D0     		beq	.L156
 790:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4026              		.loc 2 790 3
 4027 0194 40F21631 		movw	r1, #790
 4028 0198 0548     		ldr	r0, .L157+8
ARM GAS  /tmp/ccpEjOub.s 			page 180


 4029 019a FFF7FEFF 		bl	_motor_error_handler
 4030              	.L156:
 791:Core/Src/motor.c **** 	}
 792:Core/Src/motor.c **** }
 4031              		.loc 2 792 1
 4032 019e 00BF     		nop
 4033 01a0 3037     		adds	r7, r7, #48
 4034              	.LCFI117:
 4035              		.cfi_def_cfa_offset 8
 4036 01a2 BD46     		mov	sp, r7
 4037              	.LCFI118:
 4038              		.cfi_def_cfa_register 13
 4039              		@ sp needed
 4040 01a4 80BD     		pop	{r7, pc}
 4041              	.L158:
 4042 01a6 00BF     		.align	2
 4043              	.L157:
 4044 01a8 00000000 		.word	hadc1
 4045 01ac 00240140 		.word	1073816576
 4046 01b0 00000000 		.word	.LC0
 4047              		.cfi_endproc
 4048              	.LFE137:
 4050              		.section	.text.ADC2_Init,"ax",%progbits
 4051              		.align	1
 4052              		.syntax unified
 4053              		.thumb
 4054              		.thumb_func
 4055              		.fpu softvfp
 4057              	ADC2_Init:
 4058              	.LFB138:
 793:Core/Src/motor.c **** 
 794:Core/Src/motor.c **** /**
 795:Core/Src/motor.c ****  * @brief ADC2 Initialization Function
 796:Core/Src/motor.c ****  * @param None
 797:Core/Src/motor.c ****  * @retval None
 798:Core/Src/motor.c ****  */
 799:Core/Src/motor.c **** static void ADC2_Init(void) {
 4059              		.loc 2 799 29
 4060              		.cfi_startproc
 4061              		@ args = 0, pretend = 0, frame = 32
 4062              		@ frame_needed = 1, uses_anonymous_args = 0
 4063 0000 80B5     		push	{r7, lr}
 4064              	.LCFI119:
 4065              		.cfi_def_cfa_offset 8
 4066              		.cfi_offset 7, -8
 4067              		.cfi_offset 14, -4
 4068 0002 88B0     		sub	sp, sp, #32
 4069              	.LCFI120:
 4070              		.cfi_def_cfa_offset 40
 4071 0004 00AF     		add	r7, sp, #0
 4072              	.LCFI121:
 4073              		.cfi_def_cfa_register 7
 800:Core/Src/motor.c **** 
 801:Core/Src/motor.c **** 	ADC_InjectionConfTypeDef sConfigInjected;
 802:Core/Src/motor.c **** 
 803:Core/Src/motor.c **** 	/**Common config
 804:Core/Src/motor.c **** 	 */
ARM GAS  /tmp/ccpEjOub.s 			page 181


 805:Core/Src/motor.c **** 	hadc2.Instance = ADC2;
 4074              		.loc 2 805 17
 4075 0006 224B     		ldr	r3, .L163
 4076 0008 224A     		ldr	r2, .L163+4
 4077 000a 1A60     		str	r2, [r3]
 806:Core/Src/motor.c **** 	hadc2.Init.ScanConvMode = ADC_SCAN_ENABLE; //hier auch Scan enable?!
 4078              		.loc 2 806 26
 4079 000c 204B     		ldr	r3, .L163
 4080 000e 4FF48072 		mov	r2, #256
 4081 0012 9A60     		str	r2, [r3, #8]
 807:Core/Src/motor.c **** 	hadc2.Init.ContinuousConvMode = DISABLE;
 4082              		.loc 2 807 32
 4083 0014 1E4B     		ldr	r3, .L163
 4084 0016 0022     		movs	r2, #0
 4085 0018 1A73     		strb	r2, [r3, #12]
 808:Core/Src/motor.c **** 	hadc2.Init.DiscontinuousConvMode = DISABLE;
 4086              		.loc 2 808 35
 4087 001a 1D4B     		ldr	r3, .L163
 4088 001c 0022     		movs	r2, #0
 4089 001e 1A75     		strb	r2, [r3, #20]
 809:Core/Src/motor.c **** 	hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 4090              		.loc 2 809 30
 4091 0020 1B4B     		ldr	r3, .L163
 4092 0022 4FF46022 		mov	r2, #917504
 4093 0026 DA61     		str	r2, [r3, #28]
 810:Core/Src/motor.c **** 	hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 4094              		.loc 2 810 23
 4095 0028 194B     		ldr	r3, .L163
 4096 002a 0022     		movs	r2, #0
 4097 002c 5A60     		str	r2, [r3, #4]
 811:Core/Src/motor.c **** 	hadc2.Init.NbrOfConversion = 1;
 4098              		.loc 2 811 29
 4099 002e 184B     		ldr	r3, .L163
 4100 0030 0122     		movs	r2, #1
 4101 0032 1A61     		str	r2, [r3, #16]
 812:Core/Src/motor.c **** 	if (HAL_ADC_Init(&hadc2) != HAL_OK) {
 4102              		.loc 2 812 6
 4103 0034 1648     		ldr	r0, .L163
 4104 0036 FFF7FEFF 		bl	HAL_ADC_Init
 4105 003a 0346     		mov	r3, r0
 4106              		.loc 2 812 5
 4107 003c 002B     		cmp	r3, #0
 4108 003e 04D0     		beq	.L160
 813:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4109              		.loc 2 813 3
 4110 0040 40F22D31 		movw	r1, #813
 4111 0044 1448     		ldr	r0, .L163+8
 4112 0046 FFF7FEFF 		bl	_motor_error_handler
 4113              	.L160:
 814:Core/Src/motor.c **** 	}
 815:Core/Src/motor.c **** 
 816:Core/Src/motor.c **** 	/**Configure Injected Channel
 817:Core/Src/motor.c **** 	 */
 818:Core/Src/motor.c **** 	sConfigInjected.InjectedChannel = ADC_CHANNEL_4;
 4114              		.loc 2 818 34
 4115 004a 0423     		movs	r3, #4
 4116 004c 7B60     		str	r3, [r7, #4]
ARM GAS  /tmp/ccpEjOub.s 			page 182


 819:Core/Src/motor.c **** 	sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
 4117              		.loc 2 819 31
 4118 004e 0123     		movs	r3, #1
 4119 0050 BB60     		str	r3, [r7, #8]
 820:Core/Src/motor.c **** 	sConfigInjected.InjectedNbrOfConversion = 1;
 4120              		.loc 2 820 42
 4121 0052 0123     		movs	r3, #1
 4122 0054 7B61     		str	r3, [r7, #20]
 821:Core/Src/motor.c **** 	sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 4123              		.loc 2 821 39
 4124 0056 0023     		movs	r3, #0
 4125 0058 FB60     		str	r3, [r7, #12]
 822:Core/Src/motor.c **** 	sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
 4126              		.loc 2 822 40
 4127 005a 4FF4E043 		mov	r3, #28672
 4128 005e FB61     		str	r3, [r7, #28]
 823:Core/Src/motor.c **** 	sConfigInjected.AutoInjectedConv = DISABLE;
 4129              		.loc 2 823 35
 4130 0060 0023     		movs	r3, #0
 4131 0062 7B76     		strb	r3, [r7, #25]
 824:Core/Src/motor.c **** 	sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
 4132              		.loc 2 824 48
 4133 0064 0023     		movs	r3, #0
 4134 0066 3B76     		strb	r3, [r7, #24]
 825:Core/Src/motor.c **** 	sConfigInjected.InjectedOffset = 0;
 4135              		.loc 2 825 33
 4136 0068 0023     		movs	r3, #0
 4137 006a 3B61     		str	r3, [r7, #16]
 826:Core/Src/motor.c **** 	if (HAL_ADCEx_InjectedConfigChannel(&hadc2, &sConfigInjected) != HAL_OK) {
 4138              		.loc 2 826 6
 4139 006c 3B1D     		adds	r3, r7, #4
 4140 006e 1946     		mov	r1, r3
 4141 0070 0748     		ldr	r0, .L163
 4142 0072 FFF7FEFF 		bl	HAL_ADCEx_InjectedConfigChannel
 4143 0076 0346     		mov	r3, r0
 4144              		.loc 2 826 5
 4145 0078 002B     		cmp	r3, #0
 4146 007a 04D0     		beq	.L162
 827:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4147              		.loc 2 827 3
 4148 007c 40F23B31 		movw	r1, #827
 4149 0080 0548     		ldr	r0, .L163+8
 4150 0082 FFF7FEFF 		bl	_motor_error_handler
 4151              	.L162:
 828:Core/Src/motor.c **** 	}
 829:Core/Src/motor.c **** }
 4152              		.loc 2 829 1
 4153 0086 00BF     		nop
 4154 0088 2037     		adds	r7, r7, #32
 4155              	.LCFI122:
 4156              		.cfi_def_cfa_offset 8
 4157 008a BD46     		mov	sp, r7
 4158              	.LCFI123:
 4159              		.cfi_def_cfa_register 13
 4160              		@ sp needed
 4161 008c 80BD     		pop	{r7, pc}
 4162              	.L164:
ARM GAS  /tmp/ccpEjOub.s 			page 183


 4163 008e 00BF     		.align	2
 4164              	.L163:
 4165 0090 00000000 		.word	hadc2
 4166 0094 00280140 		.word	1073817600
 4167 0098 00000000 		.word	.LC0
 4168              		.cfi_endproc
 4169              	.LFE138:
 4171              		.section	.text.TIM1_Init,"ax",%progbits
 4172              		.align	1
 4173              		.syntax unified
 4174              		.thumb
 4175              		.thumb_func
 4176              		.fpu softvfp
 4178              	TIM1_Init:
 4179              	.LFB139:
 830:Core/Src/motor.c **** 
 831:Core/Src/motor.c **** /**
 832:Core/Src/motor.c ****  * @brief TIM1 Initialization Function
 833:Core/Src/motor.c ****  * @param None
 834:Core/Src/motor.c ****  * @retval None
 835:Core/Src/motor.c ****  */
 836:Core/Src/motor.c **** static void TIM1_Init(void) {
 4180              		.loc 2 836 29
 4181              		.cfi_startproc
 4182              		@ args = 0, pretend = 0, frame = 88
 4183              		@ frame_needed = 1, uses_anonymous_args = 0
 4184 0000 80B5     		push	{r7, lr}
 4185              	.LCFI124:
 4186              		.cfi_def_cfa_offset 8
 4187              		.cfi_offset 7, -8
 4188              		.cfi_offset 14, -4
 4189 0002 96B0     		sub	sp, sp, #88
 4190              	.LCFI125:
 4191              		.cfi_def_cfa_offset 96
 4192 0004 00AF     		add	r7, sp, #0
 4193              	.LCFI126:
 4194              		.cfi_def_cfa_register 7
 837:Core/Src/motor.c **** 
 838:Core/Src/motor.c **** 	TIM_ClockConfigTypeDef sClockSourceConfig;
 839:Core/Src/motor.c **** 	TIM_MasterConfigTypeDef sMasterConfig;
 840:Core/Src/motor.c **** 	TIM_OC_InitTypeDef sConfigOC;
 841:Core/Src/motor.c **** 	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
 842:Core/Src/motor.c **** 
 843:Core/Src/motor.c **** 	htim1.Instance = TIM1;
 4195              		.loc 2 843 17
 4196 0006 664B     		ldr	r3, .L176
 4197 0008 664A     		ldr	r2, .L176+4
 4198 000a 1A60     		str	r2, [r3]
 844:Core/Src/motor.c **** 	htim1.Init.Prescaler = 0;
 4199              		.loc 2 844 23
 4200 000c 644B     		ldr	r3, .L176
 4201 000e 0022     		movs	r2, #0
 4202 0010 5A60     		str	r2, [r3, #4]
 845:Core/Src/motor.c **** 	htim1.Init.CounterMode = TIM_COUNTERMODE_CENTERALIGNED1;
 4203              		.loc 2 845 25
 4204 0012 634B     		ldr	r3, .L176
 4205 0014 2022     		movs	r2, #32
ARM GAS  /tmp/ccpEjOub.s 			page 184


 4206 0016 9A60     		str	r2, [r3, #8]
 846:Core/Src/motor.c **** 	htim1.Init.Period = _T;
 4207              		.loc 2 846 20
 4208 0018 614B     		ldr	r3, .L176
 4209 001a 40F2EC72 		movw	r2, #2028
 4210 001e DA60     		str	r2, [r3, #12]
 847:Core/Src/motor.c **** 	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 4211              		.loc 2 847 27
 4212 0020 5F4B     		ldr	r3, .L176
 4213 0022 0022     		movs	r2, #0
 4214 0024 1A61     		str	r2, [r3, #16]
 848:Core/Src/motor.c **** 	htim1.Init.RepetitionCounter = 0;
 4215              		.loc 2 848 31
 4216 0026 5E4B     		ldr	r3, .L176
 4217 0028 0022     		movs	r2, #0
 4218 002a 5A61     		str	r2, [r3, #20]
 849:Core/Src/motor.c **** 	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 4219              		.loc 2 849 31
 4220 002c 5C4B     		ldr	r3, .L176
 4221 002e 0022     		movs	r2, #0
 4222 0030 9A61     		str	r2, [r3, #24]
 850:Core/Src/motor.c **** 	if (HAL_TIM_Base_Init(&htim1) != HAL_OK) {
 4223              		.loc 2 850 6
 4224 0032 5B48     		ldr	r0, .L176
 4225 0034 FFF7FEFF 		bl	HAL_TIM_Base_Init
 4226 0038 0346     		mov	r3, r0
 4227              		.loc 2 850 5
 4228 003a 002B     		cmp	r3, #0
 4229 003c 04D0     		beq	.L166
 851:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4230              		.loc 2 851 3
 4231 003e 40F25331 		movw	r1, #851
 4232 0042 5948     		ldr	r0, .L176+8
 4233 0044 FFF7FEFF 		bl	_motor_error_handler
 4234              	.L166:
 852:Core/Src/motor.c **** 	}
 853:Core/Src/motor.c **** 
 854:Core/Src/motor.c **** 	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 4235              		.loc 2 854 33
 4236 0048 4FF48053 		mov	r3, #4096
 4237 004c BB64     		str	r3, [r7, #72]
 855:Core/Src/motor.c **** 	if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK) {
 4238              		.loc 2 855 6
 4239 004e 07F14803 		add	r3, r7, #72
 4240 0052 1946     		mov	r1, r3
 4241 0054 5248     		ldr	r0, .L176
 4242 0056 FFF7FEFF 		bl	HAL_TIM_ConfigClockSource
 4243 005a 0346     		mov	r3, r0
 4244              		.loc 2 855 5
 4245 005c 002B     		cmp	r3, #0
 4246 005e 04D0     		beq	.L167
 856:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4247              		.loc 2 856 3
 4248 0060 4FF45671 		mov	r1, #856
 4249 0064 5048     		ldr	r0, .L176+8
 4250 0066 FFF7FEFF 		bl	_motor_error_handler
 4251              	.L167:
ARM GAS  /tmp/ccpEjOub.s 			page 185


 857:Core/Src/motor.c **** 	}
 858:Core/Src/motor.c **** 
 859:Core/Src/motor.c **** 	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK) {
 4252              		.loc 2 859 6
 4253 006a 4D48     		ldr	r0, .L176
 4254 006c FFF7FEFF 		bl	HAL_TIM_PWM_Init
 4255 0070 0346     		mov	r3, r0
 4256              		.loc 2 859 5
 4257 0072 002B     		cmp	r3, #0
 4258 0074 04D0     		beq	.L168
 860:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4259              		.loc 2 860 3
 4260 0076 4FF45771 		mov	r1, #860
 4261 007a 4B48     		ldr	r0, .L176+8
 4262 007c FFF7FEFF 		bl	_motor_error_handler
 4263              	.L168:
 861:Core/Src/motor.c **** 	}
 862:Core/Src/motor.c **** 
 863:Core/Src/motor.c **** 	if (HAL_TIM_OC_Init(&htim1) != HAL_OK) {
 4264              		.loc 2 863 6
 4265 0080 4748     		ldr	r0, .L176
 4266 0082 FFF7FEFF 		bl	HAL_TIM_OC_Init
 4267 0086 0346     		mov	r3, r0
 4268              		.loc 2 863 5
 4269 0088 002B     		cmp	r3, #0
 4270 008a 04D0     		beq	.L169
 864:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4271              		.loc 2 864 3
 4272 008c 4FF45871 		mov	r1, #864
 4273 0090 4548     		ldr	r0, .L176+8
 4274 0092 FFF7FEFF 		bl	_motor_error_handler
 4275              	.L169:
 865:Core/Src/motor.c **** 	}
 866:Core/Src/motor.c **** 
 867:Core/Src/motor.c **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC4REF;
 4276              		.loc 2 867 36
 4277 0096 7023     		movs	r3, #112
 4278 0098 3B64     		str	r3, [r7, #64]
 868:Core/Src/motor.c **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 4279              		.loc 2 868 32
 4280 009a 0023     		movs	r3, #0
 4281 009c 7B64     		str	r3, [r7, #68]
 869:Core/Src/motor.c **** 	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig)
 4282              		.loc 2 869 6
 4283 009e 07F14003 		add	r3, r7, #64
 4284 00a2 1946     		mov	r1, r3
 4285 00a4 3E48     		ldr	r0, .L176
 4286 00a6 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 4287 00aa 0346     		mov	r3, r0
 4288              		.loc 2 869 5
 4289 00ac 002B     		cmp	r3, #0
 4290 00ae 04D0     		beq	.L170
 870:Core/Src/motor.c **** 			!= HAL_OK) {
 871:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4291              		.loc 2 871 3
 4292 00b0 40F26731 		movw	r1, #871
 4293 00b4 3C48     		ldr	r0, .L176+8
ARM GAS  /tmp/ccpEjOub.s 			page 186


 4294 00b6 FFF7FEFF 		bl	_motor_error_handler
 4295              	.L170:
 872:Core/Src/motor.c **** 	}
 873:Core/Src/motor.c **** 
 874:Core/Src/motor.c **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 4296              		.loc 2 874 19
 4297 00ba 6023     		movs	r3, #96
 4298 00bc 7B62     		str	r3, [r7, #36]
 875:Core/Src/motor.c **** 	sConfigOC.Pulse = 1;
 4299              		.loc 2 875 18
 4300 00be 0123     		movs	r3, #1
 4301 00c0 BB62     		str	r3, [r7, #40]
 876:Core/Src/motor.c **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 4302              		.loc 2 876 23
 4303 00c2 0023     		movs	r3, #0
 4304 00c4 FB62     		str	r3, [r7, #44]
 877:Core/Src/motor.c **** 	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH; //TODO: depends on gate driver!
 4305              		.loc 2 877 24
 4306 00c6 0023     		movs	r3, #0
 4307 00c8 3B63     		str	r3, [r7, #48]
 878:Core/Src/motor.c **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 4308              		.loc 2 878 23
 4309 00ca 0023     		movs	r3, #0
 4310 00cc 7B63     		str	r3, [r7, #52]
 879:Core/Src/motor.c **** 	sConfigOC.OCIdleState = TIM_OCIDLESTATE_SET;
 4311              		.loc 2 879 24
 4312 00ce 4FF48073 		mov	r3, #256
 4313 00d2 BB63     		str	r3, [r7, #56]
 880:Core/Src/motor.c **** 	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 4314              		.loc 2 880 25
 4315 00d4 0023     		movs	r3, #0
 4316 00d6 FB63     		str	r3, [r7, #60]
 881:Core/Src/motor.c **** 	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1)
 4317              		.loc 2 881 6
 4318 00d8 07F12403 		add	r3, r7, #36
 4319 00dc 0022     		movs	r2, #0
 4320 00de 1946     		mov	r1, r3
 4321 00e0 2F48     		ldr	r0, .L176
 4322 00e2 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 4323 00e6 0346     		mov	r3, r0
 4324              		.loc 2 881 5
 4325 00e8 002B     		cmp	r3, #0
 4326 00ea 04D0     		beq	.L171
 882:Core/Src/motor.c **** 			!= HAL_OK) {
 883:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4327              		.loc 2 883 3
 4328 00ec 40F27331 		movw	r1, #883
 4329 00f0 2D48     		ldr	r0, .L176+8
 4330 00f2 FFF7FEFF 		bl	_motor_error_handler
 4331              	.L171:
 884:Core/Src/motor.c **** 	}
 885:Core/Src/motor.c **** 
 886:Core/Src/motor.c **** 	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2)
 4332              		.loc 2 886 6
 4333 00f6 07F12403 		add	r3, r7, #36
 4334 00fa 0422     		movs	r2, #4
 4335 00fc 1946     		mov	r1, r3
ARM GAS  /tmp/ccpEjOub.s 			page 187


 4336 00fe 2848     		ldr	r0, .L176
 4337 0100 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 4338 0104 0346     		mov	r3, r0
 4339              		.loc 2 886 5
 4340 0106 002B     		cmp	r3, #0
 4341 0108 04D0     		beq	.L172
 887:Core/Src/motor.c **** 			!= HAL_OK) {
 888:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4342              		.loc 2 888 3
 4343 010a 4FF45E71 		mov	r1, #888
 4344 010e 2648     		ldr	r0, .L176+8
 4345 0110 FFF7FEFF 		bl	_motor_error_handler
 4346              	.L172:
 889:Core/Src/motor.c **** 	}
 890:Core/Src/motor.c **** 
 891:Core/Src/motor.c **** 	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3)
 4347              		.loc 2 891 6
 4348 0114 07F12403 		add	r3, r7, #36
 4349 0118 0822     		movs	r2, #8
 4350 011a 1946     		mov	r1, r3
 4351 011c 2048     		ldr	r0, .L176
 4352 011e FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 4353 0122 0346     		mov	r3, r0
 4354              		.loc 2 891 5
 4355 0124 002B     		cmp	r3, #0
 4356 0126 04D0     		beq	.L173
 892:Core/Src/motor.c **** 			!= HAL_OK) {
 893:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4357              		.loc 2 893 3
 4358 0128 40F27D31 		movw	r1, #893
 4359 012c 1E48     		ldr	r0, .L176+8
 4360 012e FFF7FEFF 		bl	_motor_error_handler
 4361              	.L173:
 894:Core/Src/motor.c **** 	}
 895:Core/Src/motor.c **** 
 896:Core/Src/motor.c **** 	sConfigOC.OCMode = TIM_OCMODE_PWM2;
 4362              		.loc 2 896 19
 4363 0132 7023     		movs	r3, #112
 4364 0134 7B62     		str	r3, [r7, #36]
 897:Core/Src/motor.c **** 	sConfigOC.Pulse = _T - 1;
 4365              		.loc 2 897 18
 4366 0136 40F2EB73 		movw	r3, #2027
 4367 013a BB62     		str	r3, [r7, #40]
 898:Core/Src/motor.c **** 	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4)
 4368              		.loc 2 898 6
 4369 013c 07F12403 		add	r3, r7, #36
 4370 0140 0C22     		movs	r2, #12
 4371 0142 1946     		mov	r1, r3
 4372 0144 1648     		ldr	r0, .L176
 4373 0146 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 4374 014a 0346     		mov	r3, r0
 4375              		.loc 2 898 5
 4376 014c 002B     		cmp	r3, #0
 4377 014e 04D0     		beq	.L174
 899:Core/Src/motor.c **** 			!= HAL_OK) {
 900:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4378              		.loc 2 900 3
ARM GAS  /tmp/ccpEjOub.s 			page 188


 4379 0150 4FF46171 		mov	r1, #900
 4380 0154 1448     		ldr	r0, .L176+8
 4381 0156 FFF7FEFF 		bl	_motor_error_handler
 4382              	.L174:
 901:Core/Src/motor.c **** 	}
 902:Core/Src/motor.c **** 
 903:Core/Src/motor.c **** 	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 4383              		.loc 2 903 39
 4384 015a 0023     		movs	r3, #0
 4385 015c 7B60     		str	r3, [r7, #4]
 904:Core/Src/motor.c **** 	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 4386              		.loc 2 904 40
 4387 015e 0023     		movs	r3, #0
 4388 0160 BB60     		str	r3, [r7, #8]
 905:Core/Src/motor.c **** 	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 4389              		.loc 2 905 33
 4390 0162 0023     		movs	r3, #0
 4391 0164 FB60     		str	r3, [r7, #12]
 906:Core/Src/motor.c **** 	sBreakDeadTimeConfig.DeadTime = 32;
 4392              		.loc 2 906 32
 4393 0166 2023     		movs	r3, #32
 4394 0168 3B61     		str	r3, [r7, #16]
 907:Core/Src/motor.c **** 	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 4395              		.loc 2 907 34
 4396 016a 0023     		movs	r3, #0
 4397 016c 7B61     		str	r3, [r7, #20]
 908:Core/Src/motor.c **** 	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 4398              		.loc 2 908 37
 4399 016e 4FF40053 		mov	r3, #8192
 4400 0172 BB61     		str	r3, [r7, #24]
 909:Core/Src/motor.c **** 	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 4401              		.loc 2 909 39
 4402 0174 0023     		movs	r3, #0
 4403 0176 3B62     		str	r3, [r7, #32]
 910:Core/Src/motor.c **** 	if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig)
 4404              		.loc 2 910 6
 4405 0178 3B1D     		adds	r3, r7, #4
 4406 017a 1946     		mov	r1, r3
 4407 017c 0848     		ldr	r0, .L176
 4408 017e FFF7FEFF 		bl	HAL_TIMEx_ConfigBreakDeadTime
 4409 0182 0346     		mov	r3, r0
 4410              		.loc 2 910 5
 4411 0184 002B     		cmp	r3, #0
 4412 0186 04D0     		beq	.L175
 911:Core/Src/motor.c **** 			!= HAL_OK) {
 912:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4413              		.loc 2 912 3
 4414 0188 4FF46471 		mov	r1, #912
 4415 018c 0648     		ldr	r0, .L176+8
 4416 018e FFF7FEFF 		bl	_motor_error_handler
 4417              	.L175:
 913:Core/Src/motor.c **** 	}
 914:Core/Src/motor.c **** 
 915:Core/Src/motor.c **** 	HAL_TIM_MspPostInit(&htim1);
 4418              		.loc 2 915 2
 4419 0192 0348     		ldr	r0, .L176
 4420 0194 FFF7FEFF 		bl	HAL_TIM_MspPostInit
ARM GAS  /tmp/ccpEjOub.s 			page 189


 916:Core/Src/motor.c **** }
 4421              		.loc 2 916 1
 4422 0198 00BF     		nop
 4423 019a 5837     		adds	r7, r7, #88
 4424              	.LCFI127:
 4425              		.cfi_def_cfa_offset 8
 4426 019c BD46     		mov	sp, r7
 4427              	.LCFI128:
 4428              		.cfi_def_cfa_register 13
 4429              		@ sp needed
 4430 019e 80BD     		pop	{r7, pc}
 4431              	.L177:
 4432              		.align	2
 4433              	.L176:
 4434 01a0 00000000 		.word	htim1
 4435 01a4 002C0140 		.word	1073818624
 4436 01a8 00000000 		.word	.LC0
 4437              		.cfi_endproc
 4438              	.LFE139:
 4440              		.section	.text.TIM2_Init,"ax",%progbits
 4441              		.align	1
 4442              		.syntax unified
 4443              		.thumb
 4444              		.thumb_func
 4445              		.fpu softvfp
 4447              	TIM2_Init:
 4448              	.LFB140:
 917:Core/Src/motor.c **** 
 918:Core/Src/motor.c **** /**
 919:Core/Src/motor.c ****  * @brief TIM2 Initialization Function
 920:Core/Src/motor.c ****  * @param None
 921:Core/Src/motor.c ****  * @retval None
 922:Core/Src/motor.c ****  */
 923:Core/Src/motor.c **** static void TIM2_Init(void) {
 4449              		.loc 2 923 29
 4450              		.cfi_startproc
 4451              		@ args = 0, pretend = 0, frame = 24
 4452              		@ frame_needed = 1, uses_anonymous_args = 0
 4453 0000 80B5     		push	{r7, lr}
 4454              	.LCFI129:
 4455              		.cfi_def_cfa_offset 8
 4456              		.cfi_offset 7, -8
 4457              		.cfi_offset 14, -4
 4458 0002 86B0     		sub	sp, sp, #24
 4459              	.LCFI130:
 4460              		.cfi_def_cfa_offset 32
 4461 0004 00AF     		add	r7, sp, #0
 4462              	.LCFI131:
 4463              		.cfi_def_cfa_register 7
 924:Core/Src/motor.c **** 
 925:Core/Src/motor.c **** 	TIM_ClockConfigTypeDef sClockSourceConfig;
 926:Core/Src/motor.c **** 	TIM_MasterConfigTypeDef sMasterConfig;
 927:Core/Src/motor.c **** 
 928:Core/Src/motor.c ****   // CPU clock is 64MHz, so Timer2 ticks are 1/128 = 128ms
 929:Core/Src/motor.c **** 	htim2.Instance = TIM2;
 4464              		.loc 2 929 17
 4465 0006 224B     		ldr	r3, .L183
ARM GAS  /tmp/ccpEjOub.s 			page 190


 4466 0008 4FF08042 		mov	r2, #1073741824
 4467 000c 1A60     		str	r2, [r3]
 930:Core/Src/motor.c **** 	htim2.Init.Prescaler = 128;
 4468              		.loc 2 930 23
 4469 000e 204B     		ldr	r3, .L183
 4470 0010 8022     		movs	r2, #128
 4471 0012 5A60     		str	r2, [r3, #4]
 931:Core/Src/motor.c **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 4472              		.loc 2 931 25
 4473 0014 1E4B     		ldr	r3, .L183
 4474 0016 0022     		movs	r2, #0
 4475 0018 9A60     		str	r2, [r3, #8]
 932:Core/Src/motor.c **** 	htim2.Init.Period = 64000;
 4476              		.loc 2 932 20
 4477 001a 1D4B     		ldr	r3, .L183
 4478 001c 4FF47A42 		mov	r2, #64000
 4479 0020 DA60     		str	r2, [r3, #12]
 933:Core/Src/motor.c **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 4480              		.loc 2 933 27
 4481 0022 1B4B     		ldr	r3, .L183
 4482 0024 0022     		movs	r2, #0
 4483 0026 1A61     		str	r2, [r3, #16]
 934:Core/Src/motor.c **** 	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 4484              		.loc 2 934 31
 4485 0028 194B     		ldr	r3, .L183
 4486 002a 0022     		movs	r2, #0
 4487 002c 9A61     		str	r2, [r3, #24]
 935:Core/Src/motor.c **** 	if (HAL_TIM_Base_Init(&htim2) != HAL_OK) {
 4488              		.loc 2 935 6
 4489 002e 1848     		ldr	r0, .L183
 4490 0030 FFF7FEFF 		bl	HAL_TIM_Base_Init
 4491 0034 0346     		mov	r3, r0
 4492              		.loc 2 935 5
 4493 0036 002B     		cmp	r3, #0
 4494 0038 04D0     		beq	.L179
 936:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4495              		.loc 2 936 3
 4496 003a 4FF46A71 		mov	r1, #936
 4497 003e 1548     		ldr	r0, .L183+4
 4498 0040 FFF7FEFF 		bl	_motor_error_handler
 4499              	.L179:
 937:Core/Src/motor.c **** 	}
 938:Core/Src/motor.c **** 
 939:Core/Src/motor.c **** 	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 4500              		.loc 2 939 33
 4501 0044 4FF48053 		mov	r3, #4096
 4502 0048 BB60     		str	r3, [r7, #8]
 940:Core/Src/motor.c **** 	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) {
 4503              		.loc 2 940 6
 4504 004a 07F10803 		add	r3, r7, #8
 4505 004e 1946     		mov	r1, r3
 4506 0050 0F48     		ldr	r0, .L183
 4507 0052 FFF7FEFF 		bl	HAL_TIM_ConfigClockSource
 4508 0056 0346     		mov	r3, r0
 4509              		.loc 2 940 5
 4510 0058 002B     		cmp	r3, #0
 4511 005a 04D0     		beq	.L180
ARM GAS  /tmp/ccpEjOub.s 			page 191


 941:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4512              		.loc 2 941 3
 4513 005c 40F2AD31 		movw	r1, #941
 4514 0060 0C48     		ldr	r0, .L183+4
 4515 0062 FFF7FEFF 		bl	_motor_error_handler
 4516              	.L180:
 942:Core/Src/motor.c **** 	}
 943:Core/Src/motor.c **** 
 944:Core/Src/motor.c **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 4517              		.loc 2 944 36
 4518 0066 0023     		movs	r3, #0
 4519 0068 3B60     		str	r3, [r7]
 945:Core/Src/motor.c **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 4520              		.loc 2 945 32
 4521 006a 0023     		movs	r3, #0
 4522 006c 7B60     		str	r3, [r7, #4]
 946:Core/Src/motor.c **** 	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig)
 4523              		.loc 2 946 6
 4524 006e 3B46     		mov	r3, r7
 4525 0070 1946     		mov	r1, r3
 4526 0072 0748     		ldr	r0, .L183
 4527 0074 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 4528 0078 0346     		mov	r3, r0
 4529              		.loc 2 946 5
 4530 007a 002B     		cmp	r3, #0
 4531 007c 04D0     		beq	.L182
 947:Core/Src/motor.c **** 			!= HAL_OK) {
 948:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 4532              		.loc 2 948 3
 4533 007e 4FF46D71 		mov	r1, #948
 4534 0082 0448     		ldr	r0, .L183+4
 4535 0084 FFF7FEFF 		bl	_motor_error_handler
 4536              	.L182:
 949:Core/Src/motor.c **** 	}
 950:Core/Src/motor.c **** }
 4537              		.loc 2 950 1
 4538 0088 00BF     		nop
 4539 008a 1837     		adds	r7, r7, #24
 4540              	.LCFI132:
 4541              		.cfi_def_cfa_offset 8
 4542 008c BD46     		mov	sp, r7
 4543              	.LCFI133:
 4544              		.cfi_def_cfa_register 13
 4545              		@ sp needed
 4546 008e 80BD     		pop	{r7, pc}
 4547              	.L184:
 4548              		.align	2
 4549              	.L183:
 4550 0090 00000000 		.word	htim2
 4551 0094 00000000 		.word	.LC0
 4552              		.cfi_endproc
 4553              	.LFE140:
 4555              		.section	.text.GPIO_Init,"ax",%progbits
 4556              		.align	1
 4557              		.syntax unified
 4558              		.thumb
 4559              		.thumb_func
ARM GAS  /tmp/ccpEjOub.s 			page 192


 4560              		.fpu softvfp
 4562              	GPIO_Init:
 4563              	.LFB141:
 951:Core/Src/motor.c **** 
 952:Core/Src/motor.c **** static void GPIO_Init(void) {
 4564              		.loc 2 952 29
 4565              		.cfi_startproc
 4566              		@ args = 0, pretend = 0, frame = 24
 4567              		@ frame_needed = 1, uses_anonymous_args = 0
 4568 0000 80B5     		push	{r7, lr}
 4569              	.LCFI134:
 4570              		.cfi_def_cfa_offset 8
 4571              		.cfi_offset 7, -8
 4572              		.cfi_offset 14, -4
 4573 0002 86B0     		sub	sp, sp, #24
 4574              	.LCFI135:
 4575              		.cfi_def_cfa_offset 32
 4576 0004 00AF     		add	r7, sp, #0
 4577              	.LCFI136:
 4578              		.cfi_def_cfa_register 7
 953:Core/Src/motor.c **** 	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
 4579              		.loc 2 953 19
 4580 0006 3B1D     		adds	r3, r7, #4
 4581 0008 0022     		movs	r2, #0
 4582 000a 1A60     		str	r2, [r3]
 4583 000c 5A60     		str	r2, [r3, #4]
 4584 000e 9A60     		str	r2, [r3, #8]
 4585 0010 DA60     		str	r2, [r3, #12]
 4586              	.LBB17:
 954:Core/Src/motor.c **** 
 955:Core/Src/motor.c **** 	/* GPIO Ports Clock Enable */
 956:Core/Src/motor.c **** 	__HAL_RCC_GPIOB_CLK_ENABLE();
 4587              		.loc 2 956 2
 4588 0012 204B     		ldr	r3, .L186
 4589 0014 9B69     		ldr	r3, [r3, #24]
 4590 0016 1F4A     		ldr	r2, .L186
 4591 0018 43F00803 		orr	r3, r3, #8
 4592 001c 9361     		str	r3, [r2, #24]
 4593 001e 1D4B     		ldr	r3, .L186
 4594 0020 9B69     		ldr	r3, [r3, #24]
 4595 0022 03F00803 		and	r3, r3, #8
 4596 0026 3B60     		str	r3, [r7]
 4597 0028 3B68     		ldr	r3, [r7]
 4598              	.LBE17:
 957:Core/Src/motor.c **** 
 958:Core/Src/motor.c **** 	/* Configure GPIO pins for motor hall sensors */
 959:Core/Src/motor.c **** 	GPIO_InitStruct.Pin = HALL_1_Pin | HALL_2_Pin | HALL_3_Pin;
 4599              		.loc 2 959 22
 4600 002a 3123     		movs	r3, #49
 4601 002c 7B60     		str	r3, [r7, #4]
 960:Core/Src/motor.c **** 	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 4602              		.loc 2 960 23
 4603 002e 1A4B     		ldr	r3, .L186+4
 4604 0030 BB60     		str	r3, [r7, #8]
 961:Core/Src/motor.c **** 	GPIO_InitStruct.Pull = GPIO_PULLUP;
 4605              		.loc 2 961 23
 4606 0032 0123     		movs	r3, #1
ARM GAS  /tmp/ccpEjOub.s 			page 193


 4607 0034 FB60     		str	r3, [r7, #12]
 962:Core/Src/motor.c **** 	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 4608              		.loc 2 962 2
 4609 0036 3B1D     		adds	r3, r7, #4
 4610 0038 1946     		mov	r1, r3
 4611 003a 1848     		ldr	r0, .L186+8
 4612 003c FFF7FEFF 		bl	HAL_GPIO_Init
 4613              	.LBB18:
 963:Core/Src/motor.c **** 
 964:Core/Src/motor.c **** 
 965:Core/Src/motor.c **** 	/*Configure peripheral I/O remapping */
 966:Core/Src/motor.c **** 	__HAL_AFIO_REMAP_PD01_ENABLE();
 4614              		.loc 2 966 2
 4615 0040 174B     		ldr	r3, .L186+12
 4616 0042 5B68     		ldr	r3, [r3, #4]
 4617 0044 7B61     		str	r3, [r7, #20]
 4618 0046 7B69     		ldr	r3, [r7, #20]
 4619 0048 43F0E063 		orr	r3, r3, #117440512
 4620 004c 7B61     		str	r3, [r7, #20]
 4621 004e 7B69     		ldr	r3, [r7, #20]
 4622 0050 43F40043 		orr	r3, r3, #32768
 4623 0054 7B61     		str	r3, [r7, #20]
 4624 0056 124A     		ldr	r2, .L186+12
 4625 0058 7B69     		ldr	r3, [r7, #20]
 4626 005a 5360     		str	r3, [r2, #4]
 4627              	.LBE18:
 967:Core/Src/motor.c **** 
 968:Core/Src/motor.c **** 	/* EXTI interrupt init*/
 969:Core/Src/motor.c **** 	HAL_NVIC_SetPriority(EXTI4_IRQn, 1, 0);
 4628              		.loc 2 969 2
 4629 005c 0022     		movs	r2, #0
 4630 005e 0121     		movs	r1, #1
 4631 0060 0A20     		movs	r0, #10
 4632 0062 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 970:Core/Src/motor.c **** 	HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 4633              		.loc 2 970 2
 4634 0066 0A20     		movs	r0, #10
 4635 0068 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 971:Core/Src/motor.c **** 
 972:Core/Src/motor.c **** 	HAL_NVIC_SetPriority(EXTI9_5_IRQn, 1, 0);
 4636              		.loc 2 972 2
 4637 006c 0022     		movs	r2, #0
 4638 006e 0121     		movs	r1, #1
 4639 0070 1720     		movs	r0, #23
 4640 0072 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 973:Core/Src/motor.c **** 	HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 4641              		.loc 2 973 2
 4642 0076 1720     		movs	r0, #23
 4643 0078 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 974:Core/Src/motor.c **** 
 975:Core/Src/motor.c **** 	HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0);
 4644              		.loc 2 975 2
 4645 007c 0022     		movs	r2, #0
 4646 007e 0121     		movs	r1, #1
 4647 0080 0620     		movs	r0, #6
 4648 0082 FFF7FEFF 		bl	HAL_NVIC_SetPriority
 976:Core/Src/motor.c **** 	HAL_NVIC_EnableIRQ(EXTI0_IRQn);
ARM GAS  /tmp/ccpEjOub.s 			page 194


 4649              		.loc 2 976 2
 4650 0086 0620     		movs	r0, #6
 4651 0088 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 977:Core/Src/motor.c **** }
 4652              		.loc 2 977 1
 4653 008c 00BF     		nop
 4654 008e 1837     		adds	r7, r7, #24
 4655              	.LCFI137:
 4656              		.cfi_def_cfa_offset 8
 4657 0090 BD46     		mov	sp, r7
 4658              	.LCFI138:
 4659              		.cfi_def_cfa_register 13
 4660              		@ sp needed
 4661 0092 80BD     		pop	{r7, pc}
 4662              	.L187:
 4663              		.align	2
 4664              	.L186:
 4665 0094 00100240 		.word	1073876992
 4666 0098 00003110 		.word	271646720
 4667 009c 000C0140 		.word	1073810432
 4668 00a0 00000140 		.word	1073807360
 4669              		.cfi_endproc
 4670              	.LFE141:
 4672              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 4673              		.align	1
 4674              		.global	HAL_TIM_PeriodElapsedCallback
 4675              		.syntax unified
 4676              		.thumb
 4677              		.thumb_func
 4678              		.fpu softvfp
 4680              	HAL_TIM_PeriodElapsedCallback:
 4681              	.LFB142:
 978:Core/Src/motor.c **** 
 979:Core/Src/motor.c **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 4682              		.loc 2 979 61
 4683              		.cfi_startproc
 4684              		@ args = 0, pretend = 0, frame = 8
 4685              		@ frame_needed = 1, uses_anonymous_args = 0
 4686 0000 80B5     		push	{r7, lr}
 4687              	.LCFI139:
 4688              		.cfi_def_cfa_offset 8
 4689              		.cfi_offset 7, -8
 4690              		.cfi_offset 14, -4
 4691 0002 82B0     		sub	sp, sp, #8
 4692              	.LCFI140:
 4693              		.cfi_def_cfa_offset 16
 4694 0004 00AF     		add	r7, sp, #0
 4695              	.LCFI141:
 4696              		.cfi_def_cfa_register 7
 4697 0006 7860     		str	r0, [r7, #4]
 980:Core/Src/motor.c **** 	
 981:Core/Src/motor.c ****   if (htim == &htim3) {
 4698              		.loc 2 981 6
 4699 0008 7B68     		ldr	r3, [r7, #4]
 4700 000a 1E4A     		ldr	r2, .L194
 4701 000c 9342     		cmp	r3, r2
 4702 000e 35D1     		bne	.L193
ARM GAS  /tmp/ccpEjOub.s 			page 195


 982:Core/Src/motor.c **** 
 983:Core/Src/motor.c ****     if (MS.angle_estimation == SPEED_PLL) {
 4703              		.loc 2 983 11
 4704 0010 1D4B     		ldr	r3, .L194+4
 4705 0012 93F83330 		ldrb	r3, [r3, #51]	@ zero_extendqisi2
 4706              		.loc 2 983 8
 4707 0016 012B     		cmp	r3, #1
 4708 0018 0FD1     		bne	.L190
 984:Core/Src/motor.c ****       //keep q31_rotorposition_PLL updated when PWM is off
 985:Core/Src/motor.c ****       if (pwm_is_enabled() == false) {
 4709              		.loc 2 985 11
 4710 001a FFF7FEFF 		bl	pwm_is_enabled
 4711 001e 0346     		mov	r3, r0
 4712              		.loc 2 985 28
 4713 0020 83F00103 		eor	r3, r3, #1
 4714 0024 DBB2     		uxtb	r3, r3
 4715              		.loc 2 985 10
 4716 0026 002B     		cmp	r3, #0
 4717 0028 07D0     		beq	.L190
 986:Core/Src/motor.c ****         q31_rotorposition_PLL += (q31_angle_per_tic << 1);
 4718              		.loc 2 986 53
 4719 002a 184B     		ldr	r3, .L194+8
 4720 002c 1B68     		ldr	r3, [r3]
 4721 002e 5A00     		lsls	r2, r3, #1
 4722              		.loc 2 986 31
 4723 0030 174B     		ldr	r3, .L194+12
 4724 0032 1B68     		ldr	r3, [r3]
 4725 0034 1344     		add	r3, r3, r2
 4726 0036 164A     		ldr	r2, .L194+12
 4727 0038 1360     		str	r3, [r2]
 4728              	.L190:
 987:Core/Src/motor.c ****       }
 988:Core/Src/motor.c ****     }
 989:Core/Src/motor.c **** 		
 990:Core/Src/motor.c ****     if (MS.KV_detect_flag > 0) {
 4729              		.loc 2 990 11
 4730 003a 134B     		ldr	r3, .L194+4
 4731 003c B3F93430 		ldrsh	r3, [r3, #52]
 4732              		.loc 2 990 8
 4733 0040 002B     		cmp	r3, #0
 4734 0042 05DD     		ble	.L191
 991:Core/Src/motor.c ****       ui16_KV_detect_counter++;
 4735              		.loc 2 991 29
 4736 0044 134B     		ldr	r3, .L194+16
 4737 0046 1B88     		ldrh	r3, [r3]
 4738 0048 0133     		adds	r3, r3, #1
 4739 004a 9AB2     		uxth	r2, r3
 4740 004c 114B     		ldr	r3, .L194+16
 4741 004e 1A80     		strh	r2, [r3]	@ movhi
 4742              	.L191:
 992:Core/Src/motor.c ****     }
 993:Core/Src/motor.c **** 
 994:Core/Src/motor.c ****     if (uint16_full_rotation_counter < 8000) {
 4743              		.loc 2 994 38
 4744 0050 114B     		ldr	r3, .L194+20
 4745 0052 1B88     		ldrh	r3, [r3]
 4746              		.loc 2 994 8
ARM GAS  /tmp/ccpEjOub.s 			page 196


 4747 0054 B3F5FA5F 		cmp	r3, #8000
 4748 0058 05D2     		bcs	.L192
 995:Core/Src/motor.c **** 			uint16_full_rotation_counter++;	//full rotation counter for motor standstill detection
 4749              		.loc 2 995 32
 4750 005a 0F4B     		ldr	r3, .L194+20
 4751 005c 1B88     		ldrh	r3, [r3]
 4752 005e 0133     		adds	r3, r3, #1
 4753 0060 9AB2     		uxth	r2, r3
 4754 0062 0D4B     		ldr	r3, .L194+20
 4755 0064 1A80     		strh	r2, [r3]	@ movhi
 4756              	.L192:
 996:Core/Src/motor.c ****     }
 997:Core/Src/motor.c **** 
 998:Core/Src/motor.c ****     if (uint16_half_rotation_counter < 8000) {
 4757              		.loc 2 998 38
 4758 0066 0D4B     		ldr	r3, .L194+24
 4759 0068 1B88     		ldrh	r3, [r3]
 4760              		.loc 2 998 8
 4761 006a B3F5FA5F 		cmp	r3, #8000
 4762 006e 05D2     		bcs	.L193
 999:Core/Src/motor.c **** 			uint16_half_rotation_counter++;	//half rotation counter for motor standstill detectio
 4763              		.loc 2 999 32
 4764 0070 0A4B     		ldr	r3, .L194+24
 4765 0072 1B88     		ldrh	r3, [r3]
 4766 0074 0133     		adds	r3, r3, #1
 4767 0076 9AB2     		uxth	r2, r3
 4768 0078 084B     		ldr	r3, .L194+24
 4769 007a 1A80     		strh	r2, [r3]	@ movhi
 4770              	.L193:
1000:Core/Src/motor.c ****     }
1001:Core/Src/motor.c ****   }
1002:Core/Src/motor.c **** }
 4771              		.loc 2 1002 1
 4772 007c 00BF     		nop
 4773 007e 0837     		adds	r7, r7, #8
 4774              	.LCFI142:
 4775              		.cfi_def_cfa_offset 8
 4776 0080 BD46     		mov	sp, r7
 4777              	.LCFI143:
 4778              		.cfi_def_cfa_register 13
 4779              		@ sp needed
 4780 0082 80BD     		pop	{r7, pc}
 4781              	.L195:
 4782              		.align	2
 4783              	.L194:
 4784 0084 00000000 		.word	htim3
 4785 0088 00000000 		.word	MS
 4786 008c 00000000 		.word	q31_angle_per_tic
 4787 0090 00000000 		.word	q31_rotorposition_PLL
 4788 0094 00000000 		.word	ui16_KV_detect_counter
 4789 0098 00000000 		.word	uint16_full_rotation_counter
 4790 009c 00000000 		.word	uint16_half_rotation_counter
 4791              		.cfi_endproc
 4792              	.LFE142:
 4794              		.section	.text.dyn_adc_state,"ax",%progbits
 4795              		.align	1
 4796              		.global	dyn_adc_state
ARM GAS  /tmp/ccpEjOub.s 			page 197


 4797              		.syntax unified
 4798              		.thumb
 4799              		.thumb_func
 4800              		.fpu softvfp
 4802              	dyn_adc_state:
 4803              	.LFB143:
1003:Core/Src/motor.c **** 
1004:Core/Src/motor.c **** //assuming, a proper AD conversion takes 350 timer tics, to be confirmed. DT+TR+TS deadtime + noise
1005:Core/Src/motor.c **** void dyn_adc_state(q31_t angle) {
 4804              		.loc 2 1005 33
 4805              		.cfi_startproc
 4806              		@ args = 0, pretend = 0, frame = 8
 4807              		@ frame_needed = 1, uses_anonymous_args = 0
 4808              		@ link register save eliminated.
 4809 0000 80B4     		push	{r7}
 4810              	.LCFI144:
 4811              		.cfi_def_cfa_offset 4
 4812              		.cfi_offset 7, -4
 4813 0002 83B0     		sub	sp, sp, #12
 4814              	.LCFI145:
 4815              		.cfi_def_cfa_offset 16
 4816 0004 00AF     		add	r7, sp, #0
 4817              	.LCFI146:
 4818              		.cfi_def_cfa_register 7
 4819 0006 7860     		str	r0, [r7, #4]
1006:Core/Src/motor.c **** 	if (switchtime[2] > switchtime[0] && switchtime[2] > switchtime[1]) {
 4820              		.loc 2 1006 16
 4821 0008 334B     		ldr	r3, .L204
 4822 000a 9A68     		ldr	r2, [r3, #8]
 4823              		.loc 2 1006 32
 4824 000c 324B     		ldr	r3, .L204
 4825 000e 1B68     		ldr	r3, [r3]
 4826              		.loc 2 1006 5
 4827 0010 9A42     		cmp	r2, r3
 4828 0012 1ADD     		ble	.L197
 4829              		.loc 2 1006 49 discriminator 1
 4830 0014 304B     		ldr	r3, .L204
 4831 0016 9A68     		ldr	r2, [r3, #8]
 4832              		.loc 2 1006 65 discriminator 1
 4833 0018 2F4B     		ldr	r3, .L204
 4834 001a 5B68     		ldr	r3, [r3, #4]
 4835              		.loc 2 1006 36 discriminator 1
 4836 001c 9A42     		cmp	r2, r3
 4837 001e 14DD     		ble	.L197
1007:Core/Src/motor.c **** 		MS.char_dyn_adc_state = 1; // -90 .. +30: Phase C at high dutycycles
 4838              		.loc 2 1007 25
 4839 0020 2E4B     		ldr	r3, .L204+4
 4840 0022 0122     		movs	r2, #1
 4841 0024 83F82C20 		strb	r2, [r3, #44]
1008:Core/Src/motor.c **** 		if (switchtime[2] > 1500)
 4842              		.loc 2 1008 17
 4843 0028 2B4B     		ldr	r3, .L204
 4844 002a 9B68     		ldr	r3, [r3, #8]
 4845              		.loc 2 1008 6
 4846 002c 40F2DC52 		movw	r2, #1500
 4847 0030 9342     		cmp	r3, r2
 4848 0032 06DD     		ble	.L198
ARM GAS  /tmp/ccpEjOub.s 			page 198


1009:Core/Src/motor.c **** 			TIM1->CCR4 = switchtime[2] - TRIGGER_OFFSET_ADC;
 4849              		.loc 2 1009 27
 4850 0034 284B     		ldr	r3, .L204
 4851 0036 9B68     		ldr	r3, [r3, #8]
 4852              		.loc 2 1009 31
 4853 0038 A3F13202 		sub	r2, r3, #50
 4854              		.loc 2 1009 8
 4855 003c 284B     		ldr	r3, .L204+8
 4856              		.loc 2 1009 15
 4857 003e 1A64     		str	r2, [r3, #64]
 4858 0040 03E0     		b	.L197
 4859              	.L198:
1010:Core/Src/motor.c **** 		else
1011:Core/Src/motor.c **** 			TIM1->CCR4 = TRIGGER_DEFAULT;
 4860              		.loc 2 1011 8
 4861 0042 274B     		ldr	r3, .L204+8
 4862              		.loc 2 1011 15
 4863 0044 40F2E472 		movw	r2, #2020
 4864 0048 1A64     		str	r2, [r3, #64]
 4865              	.L197:
1012:Core/Src/motor.c **** 	}
1013:Core/Src/motor.c **** 
1014:Core/Src/motor.c **** 	if (switchtime[0] > switchtime[1] && switchtime[0] > switchtime[2]) {
 4866              		.loc 2 1014 16
 4867 004a 234B     		ldr	r3, .L204
 4868 004c 1A68     		ldr	r2, [r3]
 4869              		.loc 2 1014 32
 4870 004e 224B     		ldr	r3, .L204
 4871 0050 5B68     		ldr	r3, [r3, #4]
 4872              		.loc 2 1014 5
 4873 0052 9A42     		cmp	r2, r3
 4874 0054 1ADD     		ble	.L199
 4875              		.loc 2 1014 49 discriminator 1
 4876 0056 204B     		ldr	r3, .L204
 4877 0058 1A68     		ldr	r2, [r3]
 4878              		.loc 2 1014 65 discriminator 1
 4879 005a 1F4B     		ldr	r3, .L204
 4880 005c 9B68     		ldr	r3, [r3, #8]
 4881              		.loc 2 1014 36 discriminator 1
 4882 005e 9A42     		cmp	r2, r3
 4883 0060 14DD     		ble	.L199
1015:Core/Src/motor.c **** 		MS.char_dyn_adc_state = 2; // +30 .. 150 Phase A at high dutycycles
 4884              		.loc 2 1015 25
 4885 0062 1E4B     		ldr	r3, .L204+4
 4886 0064 0222     		movs	r2, #2
 4887 0066 83F82C20 		strb	r2, [r3, #44]
1016:Core/Src/motor.c **** 		if (switchtime[0] > 1500)
 4888              		.loc 2 1016 17
 4889 006a 1B4B     		ldr	r3, .L204
 4890 006c 1B68     		ldr	r3, [r3]
 4891              		.loc 2 1016 6
 4892 006e 40F2DC52 		movw	r2, #1500
 4893 0072 9342     		cmp	r3, r2
 4894 0074 06DD     		ble	.L200
1017:Core/Src/motor.c **** 			TIM1->CCR4 = switchtime[0] - TRIGGER_OFFSET_ADC;
 4895              		.loc 2 1017 27
 4896 0076 184B     		ldr	r3, .L204
ARM GAS  /tmp/ccpEjOub.s 			page 199


 4897 0078 1B68     		ldr	r3, [r3]
 4898              		.loc 2 1017 31
 4899 007a A3F13202 		sub	r2, r3, #50
 4900              		.loc 2 1017 8
 4901 007e 184B     		ldr	r3, .L204+8
 4902              		.loc 2 1017 15
 4903 0080 1A64     		str	r2, [r3, #64]
 4904 0082 03E0     		b	.L199
 4905              	.L200:
1018:Core/Src/motor.c **** 		else
1019:Core/Src/motor.c **** 			TIM1->CCR4 = TRIGGER_DEFAULT;
 4906              		.loc 2 1019 8
 4907 0084 164B     		ldr	r3, .L204+8
 4908              		.loc 2 1019 15
 4909 0086 40F2E472 		movw	r2, #2020
 4910 008a 1A64     		str	r2, [r3, #64]
 4911              	.L199:
1020:Core/Src/motor.c **** 	}
1021:Core/Src/motor.c **** 
1022:Core/Src/motor.c **** 	if (switchtime[1] > switchtime[0] && switchtime[1] > switchtime[2]) {
 4912              		.loc 2 1022 16
 4913 008c 124B     		ldr	r3, .L204
 4914 008e 5A68     		ldr	r2, [r3, #4]
 4915              		.loc 2 1022 32
 4916 0090 114B     		ldr	r3, .L204
 4917 0092 1B68     		ldr	r3, [r3]
 4918              		.loc 2 1022 5
 4919 0094 9A42     		cmp	r2, r3
 4920 0096 1ADD     		ble	.L203
 4921              		.loc 2 1022 49 discriminator 1
 4922 0098 0F4B     		ldr	r3, .L204
 4923 009a 5A68     		ldr	r2, [r3, #4]
 4924              		.loc 2 1022 65 discriminator 1
 4925 009c 0E4B     		ldr	r3, .L204
 4926 009e 9B68     		ldr	r3, [r3, #8]
 4927              		.loc 2 1022 36 discriminator 1
 4928 00a0 9A42     		cmp	r2, r3
 4929 00a2 14DD     		ble	.L203
1023:Core/Src/motor.c **** 		MS.char_dyn_adc_state = 3; // +150 .. -90 Phase B at high dutycycles
 4930              		.loc 2 1023 25
 4931 00a4 0D4B     		ldr	r3, .L204+4
 4932 00a6 0322     		movs	r2, #3
 4933 00a8 83F82C20 		strb	r2, [r3, #44]
1024:Core/Src/motor.c **** 		if (switchtime[1] > 1500)
 4934              		.loc 2 1024 17
 4935 00ac 0A4B     		ldr	r3, .L204
 4936 00ae 5B68     		ldr	r3, [r3, #4]
 4937              		.loc 2 1024 6
 4938 00b0 40F2DC52 		movw	r2, #1500
 4939 00b4 9342     		cmp	r3, r2
 4940 00b6 06DD     		ble	.L202
1025:Core/Src/motor.c **** 			TIM1->CCR4 = switchtime[1] - TRIGGER_OFFSET_ADC;
 4941              		.loc 2 1025 27
 4942 00b8 074B     		ldr	r3, .L204
 4943 00ba 5B68     		ldr	r3, [r3, #4]
 4944              		.loc 2 1025 31
 4945 00bc A3F13202 		sub	r2, r3, #50
ARM GAS  /tmp/ccpEjOub.s 			page 200


 4946              		.loc 2 1025 8
 4947 00c0 074B     		ldr	r3, .L204+8
 4948              		.loc 2 1025 15
 4949 00c2 1A64     		str	r2, [r3, #64]
1026:Core/Src/motor.c **** 		else
1027:Core/Src/motor.c **** 			TIM1->CCR4 = TRIGGER_DEFAULT;
1028:Core/Src/motor.c **** 	}
1029:Core/Src/motor.c **** }
 4950              		.loc 2 1029 1
 4951 00c4 03E0     		b	.L203
 4952              	.L202:
1027:Core/Src/motor.c **** 	}
 4953              		.loc 2 1027 8
 4954 00c6 064B     		ldr	r3, .L204+8
1027:Core/Src/motor.c **** 	}
 4955              		.loc 2 1027 15
 4956 00c8 40F2E472 		movw	r2, #2020
 4957 00cc 1A64     		str	r2, [r3, #64]
 4958              	.L203:
 4959              		.loc 2 1029 1
 4960 00ce 00BF     		nop
 4961 00d0 0C37     		adds	r7, r7, #12
 4962              	.LCFI147:
 4963              		.cfi_def_cfa_offset 4
 4964 00d2 BD46     		mov	sp, r7
 4965              	.LCFI148:
 4966              		.cfi_def_cfa_register 13
 4967              		@ sp needed
 4968 00d4 80BC     		pop	{r7}
 4969              	.LCFI149:
 4970              		.cfi_restore 7
 4971              		.cfi_def_cfa_offset 0
 4972 00d6 7047     		bx	lr
 4973              	.L205:
 4974              		.align	2
 4975              	.L204:
 4976 00d8 00000000 		.word	switchtime
 4977 00dc 00000000 		.word	MS
 4978 00e0 002C0140 		.word	1073818624
 4979              		.cfi_endproc
 4980              	.LFE143:
 4982              		.section	.text.set_inj_channel,"ax",%progbits
 4983              		.align	1
 4984              		.syntax unified
 4985              		.thumb
 4986              		.thumb_func
 4987              		.fpu softvfp
 4989              	set_inj_channel:
 4990              	.LFB144:
1030:Core/Src/motor.c **** 
1031:Core/Src/motor.c **** static void set_inj_channel(char state) {
 4991              		.loc 2 1031 41
 4992              		.cfi_startproc
 4993              		@ args = 0, pretend = 0, frame = 8
 4994              		@ frame_needed = 1, uses_anonymous_args = 0
 4995              		@ link register save eliminated.
 4996 0000 80B4     		push	{r7}
ARM GAS  /tmp/ccpEjOub.s 			page 201


 4997              	.LCFI150:
 4998              		.cfi_def_cfa_offset 4
 4999              		.cfi_offset 7, -4
 5000 0002 83B0     		sub	sp, sp, #12
 5001              	.LCFI151:
 5002              		.cfi_def_cfa_offset 16
 5003 0004 00AF     		add	r7, sp, #0
 5004              	.LCFI152:
 5005              		.cfi_def_cfa_register 7
 5006 0006 0346     		mov	r3, r0
 5007 0008 FB71     		strb	r3, [r7, #7]
1032:Core/Src/motor.c **** 	switch (state) {
 5008              		.loc 2 1032 2
 5009 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5010 000c 032B     		cmp	r3, #3
 5011 000e 28D0     		beq	.L207
 5012 0010 032B     		cmp	r3, #3
 5013 0012 37DC     		bgt	.L211
 5014 0014 012B     		cmp	r3, #1
 5015 0016 02D0     		beq	.L209
 5016 0018 022B     		cmp	r3, #2
 5017 001a 11D0     		beq	.L210
1033:Core/Src/motor.c **** 	case 1: //Phase C at high dutycycles, read current from phase A + B
1034:Core/Src/motor.c **** 		ADC1->JSQR = JSQR_PHASE_A; //ADC1 injected reads phase A JL = 0b00, JSQ4 = 0b00100 (decimal 4 = c
1035:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph1_offset;
1036:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
1037:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph2_offset;
1038:Core/Src/motor.c **** 		break;
1039:Core/Src/motor.c **** 
1040:Core/Src/motor.c **** 	case 2: //Phase A at high dutycycles, read current from phase C + B
1041:Core/Src/motor.c **** 		ADC1->JSQR = JSQR_PHASE_C; //ADC1 injected reads phase C, JSQ4 = 0b00110, decimal 6
1042:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph3_offset;
1043:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
1044:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph2_offset;
1045:Core/Src/motor.c **** 		break;
1046:Core/Src/motor.c **** 
1047:Core/Src/motor.c **** 	case 3: //Phase B at high dutycycles, read current from phase A + C
1048:Core/Src/motor.c **** 		ADC1->JSQR = JSQR_PHASE_A; //ADC1 injected reads phase A JL = 0b00, JSQ4 = 0b00100 (decimal 4 = c
1049:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph1_offset;
1050:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_C; //ADC2 injected reads phase C, JSQ4 = 0b00110, decimal 6
1051:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph3_offset;
1052:Core/Src/motor.c **** 		break;
1053:Core/Src/motor.c **** 	}
1054:Core/Src/motor.c **** }
 5018              		.loc 2 1054 1
 5019 001c 32E0     		b	.L211
 5020              	.L209:
1034:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph1_offset;
 5021              		.loc 2 1034 7
 5022 001e 1C4B     		ldr	r3, .L212
1034:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph1_offset;
 5023              		.loc 2 1034 14
 5024 0020 4FF4C032 		mov	r2, #98304
 5025 0024 9A63     		str	r2, [r3, #56]
1035:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
 5026              		.loc 2 1035 15
 5027 0026 1B4B     		ldr	r3, .L212+4
ARM GAS  /tmp/ccpEjOub.s 			page 202


 5028 0028 1A88     		ldrh	r2, [r3]
1035:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
 5029              		.loc 2 1035 7
 5030 002a 194B     		ldr	r3, .L212
1035:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
 5031              		.loc 2 1035 15
 5032 002c 5A61     		str	r2, [r3, #20]
1036:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph2_offset;
 5033              		.loc 2 1036 7
 5034 002e 1A4B     		ldr	r3, .L212+8
1036:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph2_offset;
 5035              		.loc 2 1036 14
 5036 0030 4FF40032 		mov	r2, #131072
 5037 0034 9A63     		str	r2, [r3, #56]
1037:Core/Src/motor.c **** 		break;
 5038              		.loc 2 1037 15
 5039 0036 194B     		ldr	r3, .L212+12
 5040 0038 1A88     		ldrh	r2, [r3]
1037:Core/Src/motor.c **** 		break;
 5041              		.loc 2 1037 7
 5042 003a 174B     		ldr	r3, .L212+8
1037:Core/Src/motor.c **** 		break;
 5043              		.loc 2 1037 15
 5044 003c 5A61     		str	r2, [r3, #20]
1038:Core/Src/motor.c **** 
 5045              		.loc 2 1038 3
 5046 003e 21E0     		b	.L208
 5047              	.L210:
1041:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph3_offset;
 5048              		.loc 2 1041 7
 5049 0040 134B     		ldr	r3, .L212
1041:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph3_offset;
 5050              		.loc 2 1041 14
 5051 0042 4FF42032 		mov	r2, #163840
 5052 0046 9A63     		str	r2, [r3, #56]
1042:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
 5053              		.loc 2 1042 15
 5054 0048 154B     		ldr	r3, .L212+16
 5055 004a 1A88     		ldrh	r2, [r3]
1042:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
 5056              		.loc 2 1042 7
 5057 004c 104B     		ldr	r3, .L212
1042:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_B; //ADC2 injected reads phase B, JSQ4 = 0b00101, decimal 5
 5058              		.loc 2 1042 15
 5059 004e 5A61     		str	r2, [r3, #20]
1043:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph2_offset;
 5060              		.loc 2 1043 7
 5061 0050 114B     		ldr	r3, .L212+8
1043:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph2_offset;
 5062              		.loc 2 1043 14
 5063 0052 4FF40032 		mov	r2, #131072
 5064 0056 9A63     		str	r2, [r3, #56]
1044:Core/Src/motor.c **** 		break;
 5065              		.loc 2 1044 15
 5066 0058 104B     		ldr	r3, .L212+12
 5067 005a 1A88     		ldrh	r2, [r3]
1044:Core/Src/motor.c **** 		break;
ARM GAS  /tmp/ccpEjOub.s 			page 203


 5068              		.loc 2 1044 7
 5069 005c 0E4B     		ldr	r3, .L212+8
1044:Core/Src/motor.c **** 		break;
 5070              		.loc 2 1044 15
 5071 005e 5A61     		str	r2, [r3, #20]
1045:Core/Src/motor.c **** 
 5072              		.loc 2 1045 3
 5073 0060 10E0     		b	.L208
 5074              	.L207:
1048:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph1_offset;
 5075              		.loc 2 1048 7
 5076 0062 0B4B     		ldr	r3, .L212
1048:Core/Src/motor.c **** 		ADC1->JOFR1 = ui16_ph1_offset;
 5077              		.loc 2 1048 14
 5078 0064 4FF4C032 		mov	r2, #98304
 5079 0068 9A63     		str	r2, [r3, #56]
1049:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_C; //ADC2 injected reads phase C, JSQ4 = 0b00110, decimal 6
 5080              		.loc 2 1049 15
 5081 006a 0A4B     		ldr	r3, .L212+4
 5082 006c 1A88     		ldrh	r2, [r3]
1049:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_C; //ADC2 injected reads phase C, JSQ4 = 0b00110, decimal 6
 5083              		.loc 2 1049 7
 5084 006e 084B     		ldr	r3, .L212
1049:Core/Src/motor.c **** 		ADC2->JSQR = JSQR_PHASE_C; //ADC2 injected reads phase C, JSQ4 = 0b00110, decimal 6
 5085              		.loc 2 1049 15
 5086 0070 5A61     		str	r2, [r3, #20]
1050:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph3_offset;
 5087              		.loc 2 1050 7
 5088 0072 094B     		ldr	r3, .L212+8
1050:Core/Src/motor.c **** 		ADC2->JOFR1 = ui16_ph3_offset;
 5089              		.loc 2 1050 14
 5090 0074 4FF42032 		mov	r2, #163840
 5091 0078 9A63     		str	r2, [r3, #56]
1051:Core/Src/motor.c **** 		break;
 5092              		.loc 2 1051 15
 5093 007a 094B     		ldr	r3, .L212+16
 5094 007c 1A88     		ldrh	r2, [r3]
1051:Core/Src/motor.c **** 		break;
 5095              		.loc 2 1051 7
 5096 007e 064B     		ldr	r3, .L212+8
1051:Core/Src/motor.c **** 		break;
 5097              		.loc 2 1051 15
 5098 0080 5A61     		str	r2, [r3, #20]
1052:Core/Src/motor.c **** 	}
 5099              		.loc 2 1052 3
 5100 0082 00BF     		nop
 5101              	.L208:
 5102              	.L211:
 5103              		.loc 2 1054 1
 5104 0084 00BF     		nop
 5105 0086 0C37     		adds	r7, r7, #12
 5106              	.LCFI153:
 5107              		.cfi_def_cfa_offset 4
 5108 0088 BD46     		mov	sp, r7
 5109              	.LCFI154:
 5110              		.cfi_def_cfa_register 13
 5111              		@ sp needed
ARM GAS  /tmp/ccpEjOub.s 			page 204


 5112 008a 80BC     		pop	{r7}
 5113              	.LCFI155:
 5114              		.cfi_restore 7
 5115              		.cfi_def_cfa_offset 0
 5116 008c 7047     		bx	lr
 5117              	.L213:
 5118 008e 00BF     		.align	2
 5119              	.L212:
 5120 0090 00240140 		.word	1073816576
 5121 0094 00000000 		.word	ui16_ph1_offset
 5122 0098 00280140 		.word	1073817600
 5123 009c 00000000 		.word	ui16_ph2_offset
 5124 00a0 00000000 		.word	ui16_ph3_offset
 5125              		.cfi_endproc
 5126              	.LFE144:
 5128              		.section	.text.PI_control,"ax",%progbits
 5129              		.align	1
 5130              		.global	PI_control
 5131              		.syntax unified
 5132              		.thumb
 5133              		.thumb_func
 5134              		.fpu softvfp
 5136              	PI_control:
 5137              	.LFB145:
1055:Core/Src/motor.c **** 
1056:Core/Src/motor.c **** // PI Control
1057:Core/Src/motor.c **** q31_t PI_control(PI_control_t* PI_c)
1058:Core/Src/motor.c **** {
 5138              		.loc 2 1058 1
 5139              		.cfi_startproc
 5140              		@ args = 0, pretend = 0, frame = 16
 5141              		@ frame_needed = 1, uses_anonymous_args = 0
 5142 0000 80B5     		push	{r7, lr}
 5143              	.LCFI156:
 5144              		.cfi_def_cfa_offset 8
 5145              		.cfi_offset 7, -8
 5146              		.cfi_offset 14, -4
 5147 0002 84B0     		sub	sp, sp, #16
 5148              	.LCFI157:
 5149              		.cfi_def_cfa_offset 24
 5150 0004 00AF     		add	r7, sp, #0
 5151              	.LCFI158:
 5152              		.cfi_def_cfa_register 7
 5153 0006 7860     		str	r0, [r7, #4]
1059:Core/Src/motor.c ****   q31_t q31_p; //proportional part
1060:Core/Src/motor.c ****   q31_p = ((PI_c->setpoint - PI_c->recent_value)*PI_c->gain_p);
 5154              		.loc 2 1060 17
 5155 0008 7B68     		ldr	r3, [r7, #4]
 5156 000a DB68     		ldr	r3, [r3, #12]
 5157              		.loc 2 1060 34
 5158 000c 7A68     		ldr	r2, [r7, #4]
 5159 000e B2F90820 		ldrsh	r2, [r2, #8]
 5160              		.loc 2 1060 28
 5161 0012 9B1A     		subs	r3, r3, r2
 5162              		.loc 2 1060 54
 5163 0014 7A68     		ldr	r2, [r7, #4]
 5164 0016 B2F90020 		ldrsh	r2, [r2]
ARM GAS  /tmp/ccpEjOub.s 			page 205


 5165              		.loc 2 1060 9
 5166 001a 02FB03F3 		mul	r3, r2, r3
 5167 001e FB60     		str	r3, [r7, #12]
1061:Core/Src/motor.c ****   PI_c->integral_part += ((PI_c->setpoint - PI_c->recent_value)*PI_c->gain_i);
 5168              		.loc 2 1061 23
 5169 0020 7B68     		ldr	r3, [r7, #4]
 5170 0022 1A69     		ldr	r2, [r3, #16]
 5171              		.loc 2 1061 32
 5172 0024 7B68     		ldr	r3, [r7, #4]
 5173 0026 DB68     		ldr	r3, [r3, #12]
 5174              		.loc 2 1061 49
 5175 0028 7968     		ldr	r1, [r7, #4]
 5176 002a B1F90810 		ldrsh	r1, [r1, #8]
 5177              		.loc 2 1061 43
 5178 002e 5B1A     		subs	r3, r3, r1
 5179              		.loc 2 1061 69
 5180 0030 7968     		ldr	r1, [r7, #4]
 5181 0032 B1F90210 		ldrsh	r1, [r1, #2]
 5182              		.loc 2 1061 64
 5183 0036 01FB03F3 		mul	r3, r1, r3
 5184              		.loc 2 1061 23
 5185 003a 1A44     		add	r2, r2, r3
 5186 003c 7B68     		ldr	r3, [r7, #4]
 5187 003e 1A61     		str	r2, [r3, #16]
1062:Core/Src/motor.c **** 
1063:Core/Src/motor.c ****   if (PI_c->integral_part > PI_c->limit_i << PI_c->shift) PI_c->integral_part = PI_c->limit_i << PI
 5188              		.loc 2 1063 11
 5189 0040 7B68     		ldr	r3, [r7, #4]
 5190 0042 1A69     		ldr	r2, [r3, #16]
 5191              		.loc 2 1063 33
 5192 0044 7B68     		ldr	r3, [r7, #4]
 5193 0046 B3F90430 		ldrsh	r3, [r3, #4]
 5194 004a 1946     		mov	r1, r3
 5195              		.loc 2 1063 50
 5196 004c 7B68     		ldr	r3, [r7, #4]
 5197 004e 93F91C30 		ldrsb	r3, [r3, #28]
 5198              		.loc 2 1063 43
 5199 0052 01FA03F3 		lsl	r3, r1, r3
 5200              		.loc 2 1063 6
 5201 0056 9A42     		cmp	r2, r3
 5202 0058 09DD     		ble	.L215
 5203              		.loc 2 1063 85 discriminator 1
 5204 005a 7B68     		ldr	r3, [r7, #4]
 5205 005c B3F90430 		ldrsh	r3, [r3, #4]
 5206 0060 1A46     		mov	r2, r3
 5207              		.loc 2 1063 102 discriminator 1
 5208 0062 7B68     		ldr	r3, [r7, #4]
 5209 0064 93F91C30 		ldrsb	r3, [r3, #28]
 5210              		.loc 2 1063 95 discriminator 1
 5211 0068 9A40     		lsls	r2, r2, r3
 5212              		.loc 2 1063 79 discriminator 1
 5213 006a 7B68     		ldr	r3, [r7, #4]
 5214 006c 1A61     		str	r2, [r3, #16]
 5215              	.L215:
1064:Core/Src/motor.c ****   if (PI_c->integral_part < -(PI_c->limit_i << PI_c->shift)) PI_c->integral_part = -(PI_c->limit_i 
 5216              		.loc 2 1064 11
 5217 006e 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/ccpEjOub.s 			page 206


 5218 0070 1A69     		ldr	r2, [r3, #16]
 5219              		.loc 2 1064 35
 5220 0072 7B68     		ldr	r3, [r7, #4]
 5221 0074 B3F90430 		ldrsh	r3, [r3, #4]
 5222 0078 1946     		mov	r1, r3
 5223              		.loc 2 1064 52
 5224 007a 7B68     		ldr	r3, [r7, #4]
 5225 007c 93F91C30 		ldrsb	r3, [r3, #28]
 5226              		.loc 2 1064 45
 5227 0080 01FA03F3 		lsl	r3, r1, r3
 5228              		.loc 2 1064 29
 5229 0084 5B42     		rsbs	r3, r3, #0
 5230              		.loc 2 1064 6
 5231 0086 9A42     		cmp	r2, r3
 5232 0088 0BDA     		bge	.L216
 5233              		.loc 2 1064 90 discriminator 1
 5234 008a 7B68     		ldr	r3, [r7, #4]
 5235 008c B3F90430 		ldrsh	r3, [r3, #4]
 5236 0090 1A46     		mov	r2, r3
 5237              		.loc 2 1064 107 discriminator 1
 5238 0092 7B68     		ldr	r3, [r7, #4]
 5239 0094 93F91C30 		ldrsb	r3, [r3, #28]
 5240              		.loc 2 1064 100 discriminator 1
 5241 0098 02FA03F3 		lsl	r3, r2, r3
 5242              		.loc 2 1064 84 discriminator 1
 5243 009c 5A42     		rsbs	r2, r3, #0
 5244              		.loc 2 1064 82 discriminator 1
 5245 009e 7B68     		ldr	r3, [r7, #4]
 5246 00a0 1A61     		str	r2, [r3, #16]
 5247              	.L216:
1065:Core/Src/motor.c ****   if (pwm_is_enabled() == false) PI_c->integral_part = 0 ; // reset integral part if PWM is disable
 5248              		.loc 2 1065 7
 5249 00a2 FFF7FEFF 		bl	pwm_is_enabled
 5250 00a6 0346     		mov	r3, r0
 5251              		.loc 2 1065 24
 5252 00a8 83F00103 		eor	r3, r3, #1
 5253 00ac DBB2     		uxtb	r3, r3
 5254              		.loc 2 1065 6
 5255 00ae 002B     		cmp	r3, #0
 5256 00b0 02D0     		beq	.L217
 5257              		.loc 2 1065 54 discriminator 1
 5258 00b2 7B68     		ldr	r3, [r7, #4]
 5259 00b4 0022     		movs	r2, #0
 5260 00b6 1A61     		str	r2, [r3, #16]
 5261              	.L217:
1066:Core/Src/motor.c **** 
1067:Core/Src/motor.c ****   //avoid too big steps in one loop run
1068:Core/Src/motor.c ****   if (q31_p+PI_c->integral_part > PI_c->out+PI_c->max_step) PI_c->out+=PI_c->max_step;
 5262              		.loc 2 1068 17
 5263 00b8 7B68     		ldr	r3, [r7, #4]
 5264 00ba 1A69     		ldr	r2, [r3, #16]
 5265              		.loc 2 1068 12
 5266 00bc FB68     		ldr	r3, [r7, #12]
 5267 00be 1A44     		add	r2, r2, r3
 5268              		.loc 2 1068 39
 5269 00c0 7B68     		ldr	r3, [r7, #4]
 5270 00c2 9B69     		ldr	r3, [r3, #24]
ARM GAS  /tmp/ccpEjOub.s 			page 207


 5271              		.loc 2 1068 49
 5272 00c4 7968     		ldr	r1, [r7, #4]
 5273 00c6 B1F91410 		ldrsh	r1, [r1, #20]
 5274              		.loc 2 1068 44
 5275 00ca 0B44     		add	r3, r3, r1
 5276              		.loc 2 1068 6
 5277 00cc 9A42     		cmp	r2, r3
 5278 00ce 08DD     		ble	.L218
 5279              		.loc 2 1068 70 discriminator 1
 5280 00d0 7B68     		ldr	r3, [r7, #4]
 5281 00d2 9B69     		ldr	r3, [r3, #24]
 5282              		.loc 2 1068 76 discriminator 1
 5283 00d4 7A68     		ldr	r2, [r7, #4]
 5284 00d6 B2F91420 		ldrsh	r2, [r2, #20]
 5285              		.loc 2 1068 70 discriminator 1
 5286 00da 1A44     		add	r2, r2, r3
 5287 00dc 7B68     		ldr	r3, [r7, #4]
 5288 00de 9A61     		str	r2, [r3, #24]
 5289 00e0 1AE0     		b	.L219
 5290              	.L218:
1069:Core/Src/motor.c ****   else if  (q31_p+PI_c->integral_part < PI_c->out-PI_c->max_step)PI_c->out-=PI_c->max_step;
 5291              		.loc 2 1069 23
 5292 00e2 7B68     		ldr	r3, [r7, #4]
 5293 00e4 1A69     		ldr	r2, [r3, #16]
 5294              		.loc 2 1069 18
 5295 00e6 FB68     		ldr	r3, [r7, #12]
 5296 00e8 1A44     		add	r2, r2, r3
 5297              		.loc 2 1069 45
 5298 00ea 7B68     		ldr	r3, [r7, #4]
 5299 00ec 9B69     		ldr	r3, [r3, #24]
 5300              		.loc 2 1069 55
 5301 00ee 7968     		ldr	r1, [r7, #4]
 5302 00f0 B1F91410 		ldrsh	r1, [r1, #20]
 5303              		.loc 2 1069 50
 5304 00f4 5B1A     		subs	r3, r3, r1
 5305              		.loc 2 1069 12
 5306 00f6 9A42     		cmp	r2, r3
 5307 00f8 08DA     		bge	.L220
 5308              		.loc 2 1069 75 discriminator 1
 5309 00fa 7B68     		ldr	r3, [r7, #4]
 5310 00fc 9B69     		ldr	r3, [r3, #24]
 5311              		.loc 2 1069 81 discriminator 1
 5312 00fe 7A68     		ldr	r2, [r7, #4]
 5313 0100 B2F91420 		ldrsh	r2, [r2, #20]
 5314              		.loc 2 1069 75 discriminator 1
 5315 0104 9A1A     		subs	r2, r3, r2
 5316 0106 7B68     		ldr	r3, [r7, #4]
 5317 0108 9A61     		str	r2, [r3, #24]
 5318 010a 05E0     		b	.L219
 5319              	.L220:
1070:Core/Src/motor.c ****   else PI_c->out=(q31_p+PI_c->integral_part);
 5320              		.loc 2 1070 29
 5321 010c 7B68     		ldr	r3, [r7, #4]
 5322 010e 1A69     		ldr	r2, [r3, #16]
 5323              		.loc 2 1070 24
 5324 0110 FB68     		ldr	r3, [r7, #12]
 5325 0112 1A44     		add	r2, r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 208


 5326              		.loc 2 1070 17
 5327 0114 7B68     		ldr	r3, [r7, #4]
 5328 0116 9A61     		str	r2, [r3, #24]
 5329              	.L219:
1071:Core/Src/motor.c **** 
1072:Core/Src/motor.c ****   if (PI_c->out>PI_c->limit_output << PI_c->shift) PI_c->out = PI_c->limit_output<< PI_c->shift;
 5330              		.loc 2 1072 11
 5331 0118 7B68     		ldr	r3, [r7, #4]
 5332 011a 9A69     		ldr	r2, [r3, #24]
 5333              		.loc 2 1072 21
 5334 011c 7B68     		ldr	r3, [r7, #4]
 5335 011e B3F90630 		ldrsh	r3, [r3, #6]
 5336 0122 1946     		mov	r1, r3
 5337              		.loc 2 1072 43
 5338 0124 7B68     		ldr	r3, [r7, #4]
 5339 0126 93F91C30 		ldrsb	r3, [r3, #28]
 5340              		.loc 2 1072 36
 5341 012a 01FA03F3 		lsl	r3, r1, r3
 5342              		.loc 2 1072 6
 5343 012e 9A42     		cmp	r2, r3
 5344 0130 09DD     		ble	.L221
 5345              		.loc 2 1072 68 discriminator 1
 5346 0132 7B68     		ldr	r3, [r7, #4]
 5347 0134 B3F90630 		ldrsh	r3, [r3, #6]
 5348 0138 1A46     		mov	r2, r3
 5349              		.loc 2 1072 89 discriminator 1
 5350 013a 7B68     		ldr	r3, [r7, #4]
 5351 013c 93F91C30 		ldrsb	r3, [r3, #28]
 5352              		.loc 2 1072 82 discriminator 1
 5353 0140 9A40     		lsls	r2, r2, r3
 5354              		.loc 2 1072 62 discriminator 1
 5355 0142 7B68     		ldr	r3, [r7, #4]
 5356 0144 9A61     		str	r2, [r3, #24]
 5357              	.L221:
1073:Core/Src/motor.c ****   if (PI_c->out<-(PI_c->limit_output << PI_c->shift)) PI_c->out = -(PI_c->limit_output<< PI_c->shif
 5358              		.loc 2 1073 11
 5359 0146 7B68     		ldr	r3, [r7, #4]
 5360 0148 9A69     		ldr	r2, [r3, #24]
 5361              		.loc 2 1073 23
 5362 014a 7B68     		ldr	r3, [r7, #4]
 5363 014c B3F90630 		ldrsh	r3, [r3, #6]
 5364 0150 1946     		mov	r1, r3
 5365              		.loc 2 1073 45
 5366 0152 7B68     		ldr	r3, [r7, #4]
 5367 0154 93F91C30 		ldrsb	r3, [r3, #28]
 5368              		.loc 2 1073 38
 5369 0158 01FA03F3 		lsl	r3, r1, r3
 5370              		.loc 2 1073 17
 5371 015c 5B42     		rsbs	r3, r3, #0
 5372              		.loc 2 1073 6
 5373 015e 9A42     		cmp	r2, r3
 5374 0160 0BDA     		bge	.L222
 5375              		.loc 2 1073 73 discriminator 1
 5376 0162 7B68     		ldr	r3, [r7, #4]
 5377 0164 B3F90630 		ldrsh	r3, [r3, #6]
 5378 0168 1A46     		mov	r2, r3
 5379              		.loc 2 1073 94 discriminator 1
ARM GAS  /tmp/ccpEjOub.s 			page 209


 5380 016a 7B68     		ldr	r3, [r7, #4]
 5381 016c 93F91C30 		ldrsb	r3, [r3, #28]
 5382              		.loc 2 1073 87 discriminator 1
 5383 0170 02FA03F3 		lsl	r3, r2, r3
 5384              		.loc 2 1073 67 discriminator 1
 5385 0174 5A42     		rsbs	r2, r3, #0
 5386              		.loc 2 1073 65 discriminator 1
 5387 0176 7B68     		ldr	r3, [r7, #4]
 5388 0178 9A61     		str	r2, [r3, #24]
 5389              	.L222:
1074:Core/Src/motor.c ****   if (pwm_is_enabled() == false) PI_c->out = 0 ; //reset output if PWM is disabled
 5390              		.loc 2 1074 7
 5391 017a FFF7FEFF 		bl	pwm_is_enabled
 5392 017e 0346     		mov	r3, r0
 5393              		.loc 2 1074 24
 5394 0180 83F00103 		eor	r3, r3, #1
 5395 0184 DBB2     		uxtb	r3, r3
 5396              		.loc 2 1074 6
 5397 0186 002B     		cmp	r3, #0
 5398 0188 02D0     		beq	.L223
 5399              		.loc 2 1074 44 discriminator 1
 5400 018a 7B68     		ldr	r3, [r7, #4]
 5401 018c 0022     		movs	r2, #0
 5402 018e 9A61     		str	r2, [r3, #24]
 5403              	.L223:
1075:Core/Src/motor.c **** 
1076:Core/Src/motor.c ****   return (PI_c->out>>PI_c->shift);
 5404              		.loc 2 1076 15
 5405 0190 7B68     		ldr	r3, [r7, #4]
 5406 0192 9B69     		ldr	r3, [r3, #24]
 5407              		.loc 2 1076 26
 5408 0194 7A68     		ldr	r2, [r7, #4]
 5409 0196 92F91C20 		ldrsb	r2, [r2, #28]
 5410              		.loc 2 1076 20
 5411 019a 1341     		asrs	r3, r3, r2
1077:Core/Src/motor.c **** }
 5412              		.loc 2 1077 1
 5413 019c 1846     		mov	r0, r3
 5414 019e 1037     		adds	r7, r7, #16
 5415              	.LCFI159:
 5416              		.cfi_def_cfa_offset 8
 5417 01a0 BD46     		mov	sp, r7
 5418              	.LCFI160:
 5419              		.cfi_def_cfa_register 13
 5420              		@ sp needed
 5421 01a2 80BD     		pop	{r7, pc}
 5422              		.cfi_endproc
 5423              	.LFE145:
 5425              		.section	.text.runPIcontrol,"ax",%progbits
 5426              		.align	1
 5427              		.global	runPIcontrol
 5428              		.syntax unified
 5429              		.thumb
 5430              		.thumb_func
 5431              		.fpu softvfp
 5433              	runPIcontrol:
 5434              	.LFB146:
ARM GAS  /tmp/ccpEjOub.s 			page 210


1078:Core/Src/motor.c **** 
1079:Core/Src/motor.c **** void runPIcontrol() {
 5435              		.loc 2 1079 21
 5436              		.cfi_startproc
 5437              		@ args = 0, pretend = 0, frame = 8
 5438              		@ frame_needed = 1, uses_anonymous_args = 0
 5439 0000 80B5     		push	{r7, lr}
 5440              	.LCFI161:
 5441              		.cfi_def_cfa_offset 8
 5442              		.cfi_offset 7, -8
 5443              		.cfi_offset 14, -4
 5444 0002 82B0     		sub	sp, sp, #8
 5445              	.LCFI162:
 5446              		.cfi_def_cfa_offset 16
 5447 0004 00AF     		add	r7, sp, #0
 5448              	.LCFI163:
 5449              		.cfi_def_cfa_register 7
1080:Core/Src/motor.c **** 	// PI-control processing
1081:Core/Src/motor.c **** 
1082:Core/Src/motor.c ****   //Check battery current limit
1083:Core/Src/motor.c ****   if (MS.Battery_Current > BATTERYCURRENT_MAX)
 5450              		.loc 2 1083 9
 5451 0006 804B     		ldr	r3, .L236
 5452 0008 9B6A     		ldr	r3, [r3, #40]
 5453              		.loc 2 1083 6
 5454 000a 42F21072 		movw	r2, #10000
 5455 000e 9342     		cmp	r3, r2
 5456 0010 02DD     		ble	.L226
1084:Core/Src/motor.c ****     ui8_BC_limit_flag = true;
 5457              		.loc 2 1084 23
 5458 0012 7E4B     		ldr	r3, .L236+4
 5459 0014 0122     		movs	r2, #1
 5460 0016 1A70     		strb	r2, [r3]
 5461              	.L226:
1085:Core/Src/motor.c ****   if (MS.Battery_Current < -REGEN_CURRENT_MAX)
 5462              		.loc 2 1085 9
 5463 0018 7B4B     		ldr	r3, .L236
 5464 001a 9B6A     		ldr	r3, [r3, #40]
 5465              		.loc 2 1085 6
 5466 001c 7C4A     		ldr	r2, .L236+8
 5467 001e 9342     		cmp	r3, r2
 5468 0020 02DA     		bge	.L227
1086:Core/Src/motor.c ****     ui8_BC_limit_flag = true;
 5469              		.loc 2 1086 23
 5470 0022 7A4B     		ldr	r3, .L236+4
 5471 0024 0122     		movs	r2, #1
 5472 0026 1A70     		strb	r2, [r3]
 5473              	.L227:
1087:Core/Src/motor.c **** 
1088:Core/Src/motor.c ****   //reset battery current flag with small hysteresis
1089:Core/Src/motor.c ****   q31_t battery_current = get_battery_current(MS.i_q_setpoint,MS.i_d_setpoint, uq_filtered, ud_filt
 5474              		.loc 2 1089 27
 5475 0028 774B     		ldr	r3, .L236
 5476 002a 9868     		ldr	r0, [r3, #8]
 5477 002c 764B     		ldr	r3, .L236
 5478 002e D968     		ldr	r1, [r3, #12]
 5479 0030 784B     		ldr	r3, .L236+12
ARM GAS  /tmp/ccpEjOub.s 			page 211


 5480 0032 1A68     		ldr	r2, [r3]
 5481 0034 784B     		ldr	r3, .L236+16
 5482 0036 1B68     		ldr	r3, [r3]
 5483 0038 FFF7FEFF 		bl	get_battery_current
 5484 003c 7860     		str	r0, [r7, #4]
1090:Core/Src/motor.c **** 
1091:Core/Src/motor.c ****   // DEBUG
1092:Core/Src/motor.c ****   p_MotorStatePublic->debug[0] = battery_current;
 5485              		.loc 2 1092 21
 5486 003e 774B     		ldr	r3, .L236+20
 5487 0040 1B68     		ldr	r3, [r3]
 5488              		.loc 2 1092 32
 5489 0042 7A68     		ldr	r2, [r7, #4]
 5490 0044 DA62     		str	r2, [r3, #44]
1093:Core/Src/motor.c **** 
1094:Core/Src/motor.c ****   if (MS.i_q * i8_direction * i8_reverse_flag > 100) { // motor mode
 5491              		.loc 2 1094 9
 5492 0046 704B     		ldr	r3, .L236
 5493 0048 5B68     		ldr	r3, [r3, #4]
 5494              		.loc 2 1094 14
 5495 004a 754A     		ldr	r2, .L236+24
 5496 004c 92F90020 		ldrsb	r2, [r2]
 5497 0050 02FB03F3 		mul	r3, r2, r3
 5498              		.loc 2 1094 29
 5499 0054 734A     		ldr	r2, .L236+28
 5500 0056 92F90020 		ldrsb	r2, [r2]
 5501 005a 02FB03F3 		mul	r3, r2, r3
 5502              		.loc 2 1094 6
 5503 005e 642B     		cmp	r3, #100
 5504 0060 08DD     		ble	.L228
1095:Core/Src/motor.c ****     if (battery_current < ((BATTERYCURRENT_MAX * 7) >> 3)) {
 5505              		.loc 2 1095 8
 5506 0062 7B68     		ldr	r3, [r7, #4]
 5507 0064 42F22D22 		movw	r2, #8749
 5508 0068 9342     		cmp	r3, r2
 5509 006a 0BDC     		bgt	.L229
1096:Core/Src/motor.c ****       ui8_BC_limit_flag = false;
 5510              		.loc 2 1096 25
 5511 006c 674B     		ldr	r3, .L236+4
 5512 006e 0022     		movs	r2, #0
 5513 0070 1A70     		strb	r2, [r3]
 5514 0072 07E0     		b	.L229
 5515              	.L228:
1097:Core/Src/motor.c ****     }
1098:Core/Src/motor.c ****   } else { //generator mode
1099:Core/Src/motor.c ****     if (battery_current > ((-REGEN_CURRENT_MAX * 7) >> 3)) { // Battery current not negative yet!!!
 5516              		.loc 2 1099 8
 5517 0074 7B68     		ldr	r3, [r7, #4]
 5518 0076 6FF4A452 		mvn	r2, #5248
 5519 007a 9342     		cmp	r3, r2
 5520 007c 02DB     		blt	.L229
1100:Core/Src/motor.c ****       ui8_BC_limit_flag = false;
 5521              		.loc 2 1100 25
 5522 007e 634B     		ldr	r3, .L236+4
 5523 0080 0022     		movs	r2, #0
 5524 0082 1A70     		strb	r2, [r3]
 5525              	.L229:
ARM GAS  /tmp/ccpEjOub.s 			page 212


1101:Core/Src/motor.c ****     }
1102:Core/Src/motor.c ****   }
1103:Core/Src/motor.c **** 
1104:Core/Src/motor.c ****   if (ui8_BC_limit_flag == false) {
 5526              		.loc 2 1104 25
 5527 0084 614B     		ldr	r3, .L236+4
 5528 0086 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 5529 0088 83F00103 		eor	r3, r3, #1
 5530 008c DBB2     		uxtb	r3, r3
 5531              		.loc 2 1104 6
 5532 008e 002B     		cmp	r3, #0
 5533 0090 09D0     		beq	.L230
1105:Core/Src/motor.c ****     PI_iq.recent_value = MS.i_q;
 5534              		.loc 2 1105 28
 5535 0092 5D4B     		ldr	r3, .L236
 5536 0094 5B68     		ldr	r3, [r3, #4]
 5537              		.loc 2 1105 24
 5538 0096 1AB2     		sxth	r2, r3
 5539 0098 634B     		ldr	r3, .L236+32
 5540 009a 1A81     		strh	r2, [r3, #8]	@ movhi
1106:Core/Src/motor.c ****     PI_iq.setpoint = MS.i_q_setpoint;
 5541              		.loc 2 1106 24
 5542 009c 5A4B     		ldr	r3, .L236
 5543 009e 9B68     		ldr	r3, [r3, #8]
 5544              		.loc 2 1106 20
 5545 00a0 614A     		ldr	r2, .L236+32
 5546 00a2 D360     		str	r3, [r2, #12]
 5547 00a4 4FE0     		b	.L231
 5548              	.L230:
1107:Core/Src/motor.c ****   } else {
1108:Core/Src/motor.c ****     if (MS.brake_active == false) {
 5549              		.loc 2 1108 11
 5550 00a6 584B     		ldr	r3, .L236
 5551 00a8 93F83230 		ldrb	r3, [r3, #50]	@ zero_extendqisi2
 5552              		.loc 2 1108 25
 5553 00ac 83F00103 		eor	r3, r3, #1
 5554 00b0 DBB2     		uxtb	r3, r3
 5555              		.loc 2 1108 8
 5556 00b2 002B     		cmp	r3, #0
 5557 00b4 23D0     		beq	.L232
1109:Core/Src/motor.c ****       PI_iq.recent_value = (MS.Battery_Current >> 6) * i8_direction * i8_reverse_flag;
 5558              		.loc 2 1109 31
 5559 00b6 544B     		ldr	r3, .L236
 5560 00b8 9B6A     		ldr	r3, [r3, #40]
 5561              		.loc 2 1109 48
 5562 00ba 9B11     		asrs	r3, r3, #6
 5563              		.loc 2 1109 26
 5564 00bc 9BB2     		uxth	r3, r3
 5565 00be 584A     		ldr	r2, .L236+24
 5566 00c0 92F90020 		ldrsb	r2, [r2]
 5567 00c4 92B2     		uxth	r2, r2
 5568 00c6 02FB03F3 		mul	r3, r2, r3
 5569 00ca 9BB2     		uxth	r3, r3
 5570 00cc 554A     		ldr	r2, .L236+28
 5571 00ce 92F90020 		ldrsb	r2, [r2]
 5572 00d2 92B2     		uxth	r2, r2
 5573 00d4 02FB03F3 		mul	r3, r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 213


 5574 00d8 9BB2     		uxth	r3, r3
 5575 00da 1AB2     		sxth	r2, r3
 5576 00dc 524B     		ldr	r3, .L236+32
 5577 00de 1A81     		strh	r2, [r3, #8]	@ movhi
1110:Core/Src/motor.c ****       PI_iq.setpoint = (BATTERYCURRENT_MAX >> 6) * i8_direction * i8_reverse_flag;
 5578              		.loc 2 1110 65
 5579 00e0 4F4B     		ldr	r3, .L236+24
 5580 00e2 93F90030 		ldrsb	r3, [r3]
 5581 00e6 1A46     		mov	r2, r3
 5582 00e8 4E4B     		ldr	r3, .L236+28
 5583 00ea 93F90030 		ldrsb	r3, [r3]
 5584 00ee 03FB02F3 		mul	r3, r3, r2
 5585 00f2 9C22     		movs	r2, #156
 5586 00f4 02FB03F3 		mul	r3, r2, r3
 5587              		.loc 2 1110 22
 5588 00f8 4B4A     		ldr	r2, .L236+32
 5589 00fa D360     		str	r3, [r2, #12]
 5590 00fc 23E0     		b	.L231
 5591              	.L232:
1111:Core/Src/motor.c ****     } else {
1112:Core/Src/motor.c ****       PI_iq.recent_value = (MS.Battery_Current >> 6) * i8_direction * i8_reverse_flag;
 5592              		.loc 2 1112 31
 5593 00fe 424B     		ldr	r3, .L236
 5594 0100 9B6A     		ldr	r3, [r3, #40]
 5595              		.loc 2 1112 48
 5596 0102 9B11     		asrs	r3, r3, #6
 5597              		.loc 2 1112 26
 5598 0104 9BB2     		uxth	r3, r3
 5599 0106 464A     		ldr	r2, .L236+24
 5600 0108 92F90020 		ldrsb	r2, [r2]
 5601 010c 92B2     		uxth	r2, r2
 5602 010e 02FB03F3 		mul	r3, r2, r3
 5603 0112 9BB2     		uxth	r3, r3
 5604 0114 434A     		ldr	r2, .L236+28
 5605 0116 92F90020 		ldrsb	r2, [r2]
 5606 011a 92B2     		uxth	r2, r2
 5607 011c 02FB03F3 		mul	r3, r2, r3
 5608 0120 9BB2     		uxth	r3, r3
 5609 0122 1AB2     		sxth	r2, r3
 5610 0124 404B     		ldr	r3, .L236+32
 5611 0126 1A81     		strh	r2, [r3, #8]	@ movhi
1113:Core/Src/motor.c ****       PI_iq.setpoint = (-REGEN_CURRENT_MAX >> 6) * i8_direction * i8_reverse_flag;
 5612              		.loc 2 1113 65
 5613 0128 3D4B     		ldr	r3, .L236+24
 5614 012a 93F90030 		ldrsb	r3, [r3]
 5615 012e 1A46     		mov	r2, r3
 5616 0130 3C4B     		ldr	r3, .L236+28
 5617 0132 93F90030 		ldrsb	r3, [r3]
 5618 0136 03FB02F3 		mul	r3, r3, r2
 5619 013a 6FF05D02 		mvn	r2, #93
 5620 013e 02FB03F3 		mul	r3, r2, r3
 5621              		.loc 2 1113 22
 5622 0142 394A     		ldr	r2, .L236+32
 5623 0144 D360     		str	r3, [r2, #12]
 5624              	.L231:
1114:Core/Src/motor.c ****     }
1115:Core/Src/motor.c ****   }
ARM GAS  /tmp/ccpEjOub.s 			page 214


1116:Core/Src/motor.c ****   q31_u_q_temp = PI_control(&PI_iq);
 5625              		.loc 2 1116 18
 5626 0146 3848     		ldr	r0, .L236+32
 5627 0148 FFF7FEFF 		bl	PI_control
 5628 014c 0346     		mov	r3, r0
 5629              		.loc 2 1116 16
 5630 014e 374A     		ldr	r2, .L236+36
 5631 0150 1360     		str	r3, [r2]
1117:Core/Src/motor.c **** 
1118:Core/Src/motor.c ****   // control id
1119:Core/Src/motor.c ****   PI_id.recent_value = MS.i_d;
 5632              		.loc 2 1119 26
 5633 0152 2D4B     		ldr	r3, .L236
 5634 0154 1B68     		ldr	r3, [r3]
 5635              		.loc 2 1119 22
 5636 0156 1AB2     		sxth	r2, r3
 5637 0158 354B     		ldr	r3, .L236+40
 5638 015a 1A81     		strh	r2, [r3, #8]	@ movhi
1120:Core/Src/motor.c ****   PI_id.setpoint = MS.i_d_setpoint;
 5639              		.loc 2 1120 22
 5640 015c 2A4B     		ldr	r3, .L236
 5641 015e DB68     		ldr	r3, [r3, #12]
 5642              		.loc 2 1120 18
 5643 0160 334A     		ldr	r2, .L236+40
 5644 0162 D360     		str	r3, [r2, #12]
1121:Core/Src/motor.c ****   q31_u_d_temp = -PI_control(&PI_id); // control direct current to zero
 5645              		.loc 2 1121 19
 5646 0164 3248     		ldr	r0, .L236+40
 5647 0166 FFF7FEFF 		bl	PI_control
 5648 016a 0346     		mov	r3, r0
 5649              		.loc 2 1121 18
 5650 016c 5B42     		rsbs	r3, r3, #0
 5651              		.loc 2 1121 16
 5652 016e 314A     		ldr	r2, .L236+44
 5653 0170 1360     		str	r3, [r2]
1122:Core/Src/motor.c **** 
1123:Core/Src/motor.c ****   // DEBUG
1124:Core/Src/motor.c ****   p_MotorStatePublic->debug[1] = MS.i_d;
 5654              		.loc 2 1124 36
 5655 0172 254B     		ldr	r3, .L236
 5656 0174 1A68     		ldr	r2, [r3]
 5657              		.loc 2 1124 21
 5658 0176 294B     		ldr	r3, .L236+20
 5659 0178 1B68     		ldr	r3, [r3]
 5660              		.loc 2 1124 32
 5661 017a 1A63     		str	r2, [r3, #48]
1125:Core/Src/motor.c **** 
1126:Core/Src/motor.c ****   arm_sqrt_q31((q31_u_d_temp*q31_u_d_temp+q31_u_q_temp*q31_u_q_temp)<<1,&MS.u_abs);
 5662              		.loc 2 1126 29
 5663 017c 2D4B     		ldr	r3, .L236+44
 5664 017e 1B68     		ldr	r3, [r3]
 5665 0180 2C4A     		ldr	r2, .L236+44
 5666 0182 1268     		ldr	r2, [r2]
 5667 0184 02FB03F2 		mul	r2, r2, r3
 5668              		.loc 2 1126 55
 5669 0188 284B     		ldr	r3, .L236+36
 5670 018a 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccpEjOub.s 			page 215


 5671 018c 2749     		ldr	r1, .L236+36
 5672 018e 0968     		ldr	r1, [r1]
 5673 0190 01FB03F3 		mul	r3, r1, r3
 5674              		.loc 2 1126 42
 5675 0194 1344     		add	r3, r3, r2
 5676              		.loc 2 1126 3
 5677 0196 5B00     		lsls	r3, r3, #1
 5678 0198 2749     		ldr	r1, .L236+48
 5679 019a 1846     		mov	r0, r3
 5680 019c FFF7FEFF 		bl	arm_sqrt_q31
1127:Core/Src/motor.c ****   MS.u_abs = (MS.u_abs>>16)+1;
 5681              		.loc 2 1127 17
 5682 01a0 194B     		ldr	r3, .L236
 5683 01a2 5B6A     		ldr	r3, [r3, #36]
 5684              		.loc 2 1127 23
 5685 01a4 1B14     		asrs	r3, r3, #16
 5686              		.loc 2 1127 28
 5687 01a6 0133     		adds	r3, r3, #1
 5688              		.loc 2 1127 12
 5689 01a8 174A     		ldr	r2, .L236
 5690 01aa 5362     		str	r3, [r2, #36]
1128:Core/Src/motor.c **** 
1129:Core/Src/motor.c ****   if (MS.u_abs > _U_MAX) {
 5691              		.loc 2 1129 9
 5692 01ac 164B     		ldr	r3, .L236
 5693 01ae 5B6A     		ldr	r3, [r3, #36]
 5694              		.loc 2 1129 6
 5695 01b0 B3F5FA6F 		cmp	r3, #2000
 5696 01b4 1CDD     		ble	.L233
1130:Core/Src/motor.c ****     MS.u_q = (q31_u_q_temp * _U_MAX) / MS.u_abs; // division!
 5697              		.loc 2 1130 28
 5698 01b6 1D4B     		ldr	r3, .L236+36
 5699 01b8 1B68     		ldr	r3, [r3]
 5700 01ba 4FF4FA62 		mov	r2, #2000
 5701 01be 02FB03F2 		mul	r2, r2, r3
 5702              		.loc 2 1130 42
 5703 01c2 114B     		ldr	r3, .L236
 5704 01c4 5B6A     		ldr	r3, [r3, #36]
 5705              		.loc 2 1130 38
 5706 01c6 92FBF3F3 		sdiv	r3, r2, r3
 5707              		.loc 2 1130 12
 5708 01ca 0F4A     		ldr	r2, .L236
 5709 01cc 1362     		str	r3, [r2, #32]
1131:Core/Src/motor.c ****     MS.u_d = (q31_u_d_temp * _U_MAX) / MS.u_abs; // division!
 5710              		.loc 2 1131 28
 5711 01ce 194B     		ldr	r3, .L236+44
 5712 01d0 1B68     		ldr	r3, [r3]
 5713 01d2 4FF4FA62 		mov	r2, #2000
 5714 01d6 02FB03F2 		mul	r2, r2, r3
 5715              		.loc 2 1131 42
 5716 01da 0B4B     		ldr	r3, .L236
 5717 01dc 5B6A     		ldr	r3, [r3, #36]
 5718              		.loc 2 1131 38
 5719 01de 92FBF3F3 		sdiv	r3, r2, r3
 5720              		.loc 2 1131 12
 5721 01e2 094A     		ldr	r2, .L236
 5722 01e4 D361     		str	r3, [r2, #28]
ARM GAS  /tmp/ccpEjOub.s 			page 216


1132:Core/Src/motor.c ****     MS.u_abs = _U_MAX;
 5723              		.loc 2 1132 14
 5724 01e6 084B     		ldr	r3, .L236
 5725 01e8 4FF4FA62 		mov	r2, #2000
 5726 01ec 5A62     		str	r2, [r3, #36]
1133:Core/Src/motor.c ****   } else {
1134:Core/Src/motor.c ****     MS.u_q = q31_u_q_temp;
1135:Core/Src/motor.c ****     MS.u_d = q31_u_d_temp;
1136:Core/Src/motor.c ****   }
1137:Core/Src/motor.c **** }
 5727              		.loc 2 1137 1
 5728 01ee 07E0     		b	.L235
 5729              	.L233:
1134:Core/Src/motor.c ****     MS.u_d = q31_u_d_temp;
 5730              		.loc 2 1134 12
 5731 01f0 0E4B     		ldr	r3, .L236+36
 5732 01f2 1B68     		ldr	r3, [r3]
 5733 01f4 044A     		ldr	r2, .L236
 5734 01f6 1362     		str	r3, [r2, #32]
1135:Core/Src/motor.c ****   }
 5735              		.loc 2 1135 12
 5736 01f8 0E4B     		ldr	r3, .L236+44
 5737 01fa 1B68     		ldr	r3, [r3]
 5738 01fc 024A     		ldr	r2, .L236
 5739 01fe D361     		str	r3, [r2, #28]
 5740              	.L235:
 5741              		.loc 2 1137 1
 5742 0200 00BF     		nop
 5743 0202 0837     		adds	r7, r7, #8
 5744              	.LCFI164:
 5745              		.cfi_def_cfa_offset 8
 5746 0204 BD46     		mov	sp, r7
 5747              	.LCFI165:
 5748              		.cfi_def_cfa_register 13
 5749              		@ sp needed
 5750 0206 80BD     		pop	{r7, pc}
 5751              	.L237:
 5752              		.align	2
 5753              	.L236:
 5754 0208 00000000 		.word	MS
 5755 020c 00000000 		.word	ui8_BC_limit_flag
 5756 0210 90E8FFFF 		.word	-6000
 5757 0214 00000000 		.word	uq_filtered
 5758 0218 00000000 		.word	ud_filtered
 5759 021c 00000000 		.word	p_MotorStatePublic
 5760 0220 00000000 		.word	i8_direction
 5761 0224 00000000 		.word	i8_reverse_flag
 5762 0228 00000000 		.word	PI_iq
 5763 022c 00000000 		.word	q31_u_q_temp
 5764 0230 00000000 		.word	PI_id
 5765 0234 00000000 		.word	q31_u_d_temp
 5766 0238 24000000 		.word	MS+36
 5767              		.cfi_endproc
 5768              	.LFE146:
 5770              		.section	.text.TIM3_Init,"ax",%progbits
 5771              		.align	1
 5772              		.syntax unified
ARM GAS  /tmp/ccpEjOub.s 			page 217


 5773              		.thumb
 5774              		.thumb_func
 5775              		.fpu softvfp
 5777              	TIM3_Init:
 5778              	.LFB147:
1138:Core/Src/motor.c **** 
1139:Core/Src/motor.c **** /* TIM3 init function 8kHz interrupt frequency for regular adc triggering */
1140:Core/Src/motor.c **** static void TIM3_Init(void) {
 5779              		.loc 2 1140 29
 5780              		.cfi_startproc
 5781              		@ args = 0, pretend = 0, frame = 24
 5782              		@ frame_needed = 1, uses_anonymous_args = 0
 5783 0000 80B5     		push	{r7, lr}
 5784              	.LCFI166:
 5785              		.cfi_def_cfa_offset 8
 5786              		.cfi_offset 7, -8
 5787              		.cfi_offset 14, -4
 5788 0002 86B0     		sub	sp, sp, #24
 5789              	.LCFI167:
 5790              		.cfi_def_cfa_offset 32
 5791 0004 00AF     		add	r7, sp, #0
 5792              	.LCFI168:
 5793              		.cfi_def_cfa_register 7
1141:Core/Src/motor.c **** 
1142:Core/Src/motor.c **** 	TIM_ClockConfigTypeDef sClockSourceConfig;
1143:Core/Src/motor.c **** 	TIM_MasterConfigTypeDef sMasterConfig;
1144:Core/Src/motor.c **** 
1145:Core/Src/motor.c **** 	htim3.Instance = TIM3;
 5794              		.loc 2 1145 17
 5795 0006 234B     		ldr	r3, .L242
 5796 0008 234A     		ldr	r2, .L242+4
 5797 000a 1A60     		str	r2, [r3]
1146:Core/Src/motor.c **** 	htim3.Init.Prescaler = 0;
 5798              		.loc 2 1146 23
 5799 000c 214B     		ldr	r3, .L242
 5800 000e 0022     		movs	r2, #0
 5801 0010 5A60     		str	r2, [r3, #4]
1147:Core/Src/motor.c **** 	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 5802              		.loc 2 1147 25
 5803 0012 204B     		ldr	r3, .L242
 5804 0014 0022     		movs	r2, #0
 5805 0016 9A60     		str	r2, [r3, #8]
1148:Core/Src/motor.c **** 	htim3.Init.Period = 7813;
 5806              		.loc 2 1148 20
 5807 0018 1E4B     		ldr	r3, .L242
 5808 001a 41F68562 		movw	r2, #7813
 5809 001e DA60     		str	r2, [r3, #12]
1149:Core/Src/motor.c **** 	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 5810              		.loc 2 1149 27
 5811 0020 1C4B     		ldr	r3, .L242
 5812 0022 0022     		movs	r2, #0
 5813 0024 1A61     		str	r2, [r3, #16]
1150:Core/Src/motor.c **** 	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 5814              		.loc 2 1150 31
 5815 0026 1B4B     		ldr	r3, .L242
 5816 0028 0022     		movs	r2, #0
 5817 002a 9A61     		str	r2, [r3, #24]
ARM GAS  /tmp/ccpEjOub.s 			page 218


1151:Core/Src/motor.c **** 	if (HAL_TIM_Base_Init(&htim3) != HAL_OK) {
 5818              		.loc 2 1151 6
 5819 002c 1948     		ldr	r0, .L242
 5820 002e FFF7FEFF 		bl	HAL_TIM_Base_Init
 5821 0032 0346     		mov	r3, r0
 5822              		.loc 2 1151 5
 5823 0034 002B     		cmp	r3, #0
 5824 0036 04D0     		beq	.L239
1152:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 5825              		.loc 2 1152 3
 5826 0038 4FF49061 		mov	r1, #1152
 5827 003c 1748     		ldr	r0, .L242+8
 5828 003e FFF7FEFF 		bl	_motor_error_handler
 5829              	.L239:
1153:Core/Src/motor.c **** 	}
1154:Core/Src/motor.c **** 
1155:Core/Src/motor.c **** 	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 5830              		.loc 2 1155 33
 5831 0042 4FF48053 		mov	r3, #4096
 5832 0046 BB60     		str	r3, [r7, #8]
1156:Core/Src/motor.c **** 	if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK) {
 5833              		.loc 2 1156 6
 5834 0048 07F10803 		add	r3, r7, #8
 5835 004c 1946     		mov	r1, r3
 5836 004e 1148     		ldr	r0, .L242
 5837 0050 FFF7FEFF 		bl	HAL_TIM_ConfigClockSource
 5838 0054 0346     		mov	r3, r0
 5839              		.loc 2 1156 5
 5840 0056 002B     		cmp	r3, #0
 5841 0058 04D0     		beq	.L240
1157:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 5842              		.loc 2 1157 3
 5843 005a 40F28541 		movw	r1, #1157
 5844 005e 0F48     		ldr	r0, .L242+8
 5845 0060 FFF7FEFF 		bl	_motor_error_handler
 5846              	.L240:
1158:Core/Src/motor.c **** 	}
1159:Core/Src/motor.c **** 
1160:Core/Src/motor.c **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_OC1;
 5847              		.loc 2 1160 36
 5848 0064 3023     		movs	r3, #48
 5849 0066 3B60     		str	r3, [r7]
1161:Core/Src/motor.c **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 5850              		.loc 2 1161 32
 5851 0068 0023     		movs	r3, #0
 5852 006a 7B60     		str	r3, [r7, #4]
1162:Core/Src/motor.c **** 	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig)
 5853              		.loc 2 1162 6
 5854 006c 3B46     		mov	r3, r7
 5855 006e 1946     		mov	r1, r3
 5856 0070 0848     		ldr	r0, .L242
 5857 0072 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 5858 0076 0346     		mov	r3, r0
 5859              		.loc 2 1162 5
 5860 0078 002B     		cmp	r3, #0
 5861 007a 04D0     		beq	.L241
1163:Core/Src/motor.c **** 			!= HAL_OK) {
ARM GAS  /tmp/ccpEjOub.s 			page 219


1164:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 5862              		.loc 2 1164 3
 5863 007c 40F28C41 		movw	r1, #1164
 5864 0080 0648     		ldr	r0, .L242+8
 5865 0082 FFF7FEFF 		bl	_motor_error_handler
 5866              	.L241:
1165:Core/Src/motor.c **** 	}
1166:Core/Src/motor.c **** 
1167:Core/Src/motor.c **** 	HAL_TIM_MspPostInit(&htim3);
 5867              		.loc 2 1167 2
 5868 0086 0348     		ldr	r0, .L242
 5869 0088 FFF7FEFF 		bl	HAL_TIM_MspPostInit
1168:Core/Src/motor.c **** }
 5870              		.loc 2 1168 1
 5871 008c 00BF     		nop
 5872 008e 1837     		adds	r7, r7, #24
 5873              	.LCFI169:
 5874              		.cfi_def_cfa_offset 8
 5875 0090 BD46     		mov	sp, r7
 5876              	.LCFI170:
 5877              		.cfi_def_cfa_register 13
 5878              		@ sp needed
 5879 0092 80BD     		pop	{r7, pc}
 5880              	.L243:
 5881              		.align	2
 5882              	.L242:
 5883 0094 00000000 		.word	htim3
 5884 0098 00040040 		.word	1073742848
 5885 009c 00000000 		.word	.LC0
 5886              		.cfi_endproc
 5887              	.LFE147:
 5889              		.section	.text.motor_init,"ax",%progbits
 5890              		.align	1
 5891              		.global	motor_init
 5892              		.syntax unified
 5893              		.thumb
 5894              		.thumb_func
 5895              		.fpu softvfp
 5897              	motor_init:
 5898              	.LFB148:
1169:Core/Src/motor.c **** 
1170:Core/Src/motor.c **** void motor_init(MotorStatePublic_t* motorStatePublic) {
 5899              		.loc 2 1170 55
 5900              		.cfi_startproc
 5901              		@ args = 0, pretend = 0, frame = 16
 5902              		@ frame_needed = 1, uses_anonymous_args = 0
 5903 0000 80B5     		push	{r7, lr}
 5904              	.LCFI171:
 5905              		.cfi_def_cfa_offset 8
 5906              		.cfi_offset 7, -8
 5907              		.cfi_offset 14, -4
 5908 0002 84B0     		sub	sp, sp, #16
 5909              	.LCFI172:
 5910              		.cfi_def_cfa_offset 24
 5911 0004 00AF     		add	r7, sp, #0
 5912              	.LCFI173:
 5913              		.cfi_def_cfa_register 7
ARM GAS  /tmp/ccpEjOub.s 			page 220


 5914 0006 7860     		str	r0, [r7, #4]
1171:Core/Src/motor.c ****   p_MotorStatePublic = motorStatePublic; // local pointer of MotorStatePublic
 5915              		.loc 2 1171 22
 5916 0008 754A     		ldr	r2, .L254
 5917 000a 7B68     		ldr	r3, [r7, #4]
 5918 000c 1360     		str	r3, [r2]
1172:Core/Src/motor.c **** 
1173:Core/Src/motor.c **** 	// Virtual EEPROM init
1174:Core/Src/motor.c **** 	HAL_FLASH_Unlock();
 5919              		.loc 2 1174 2
 5920 000e FFF7FEFF 		bl	HAL_FLASH_Unlock
1175:Core/Src/motor.c **** 	EE_Init();
 5921              		.loc 2 1175 2
 5922 0012 FFF7FEFF 		bl	EE_Init
1176:Core/Src/motor.c **** 	HAL_FLASH_Lock();
 5923              		.loc 2 1176 2
 5924 0016 FFF7FEFF 		bl	HAL_FLASH_Lock
1177:Core/Src/motor.c **** 
1178:Core/Src/motor.c ****   // init IO pins
1179:Core/Src/motor.c **** 	GPIO_Init();
 5925              		.loc 2 1179 2
 5926 001a FFF7FEFF 		bl	GPIO_Init
1180:Core/Src/motor.c **** 
1181:Core/Src/motor.c ****   // init DMA for ADC
1182:Core/Src/motor.c ****   DMA_Init();
 5927              		.loc 2 1182 3
 5928 001e FFF7FEFF 		bl	DMA_Init
1183:Core/Src/motor.c **** 
1184:Core/Src/motor.c **** 	// initialize MS struct.
1185:Core/Src/motor.c **** 	MS.hall_angle_detect_flag = false;
 5929              		.loc 2 1185 28
 5930 0022 704B     		ldr	r3, .L254+4
 5931 0024 0022     		movs	r2, #0
 5932 0026 83F83620 		strb	r2, [r3, #54]
1186:Core/Src/motor.c ****   MS.KV_detect_flag = 0;
 5933              		.loc 2 1186 21
 5934 002a 6E4B     		ldr	r3, .L254+4
 5935 002c 0022     		movs	r2, #0
 5936 002e 9A86     		strh	r2, [r3, #52]	@ movhi
1187:Core/Src/motor.c **** 	MS.i_q_setpoint = 0;
 5937              		.loc 2 1187 18
 5938 0030 6C4B     		ldr	r3, .L254+4
 5939 0032 0022     		movs	r2, #0
 5940 0034 9A60     		str	r2, [r3, #8]
1188:Core/Src/motor.c **** 	MS.i_d_setpoint = 0;
 5941              		.loc 2 1188 18
 5942 0036 6B4B     		ldr	r3, .L254+4
 5943 0038 0022     		movs	r2, #0
 5944 003a DA60     		str	r2, [r3, #12]
1189:Core/Src/motor.c ****   MS.angle_estimation = SPEED_PLL;
 5945              		.loc 2 1189 23
 5946 003c 694B     		ldr	r3, .L254+4
 5947 003e 0122     		movs	r2, #1
 5948 0040 83F83320 		strb	r2, [r3, #51]
1190:Core/Src/motor.c **** 
1191:Core/Src/motor.c ****   // init PI structs
1192:Core/Src/motor.c ****   PI_id.gain_i = I_FACTOR_I_D;
ARM GAS  /tmp/ccpEjOub.s 			page 221


 5949              		.loc 2 1192 16
 5950 0044 684B     		ldr	r3, .L254+8
 5951 0046 0A22     		movs	r2, #10
 5952 0048 5A80     		strh	r2, [r3, #2]	@ movhi
1193:Core/Src/motor.c ****   PI_id.gain_p = P_FACTOR_I_D;
 5953              		.loc 2 1193 16
 5954 004a 674B     		ldr	r3, .L254+8
 5955 004c 6422     		movs	r2, #100
 5956 004e 1A80     		strh	r2, [r3]	@ movhi
1194:Core/Src/motor.c ****   PI_id.setpoint = 0;
 5957              		.loc 2 1194 18
 5958 0050 654B     		ldr	r3, .L254+8
 5959 0052 0022     		movs	r2, #0
 5960 0054 DA60     		str	r2, [r3, #12]
1195:Core/Src/motor.c ****   PI_id.limit_output = _U_MAX;
 5961              		.loc 2 1195 22
 5962 0056 644B     		ldr	r3, .L254+8
 5963 0058 4FF4FA62 		mov	r2, #2000
 5964 005c DA80     		strh	r2, [r3, #6]	@ movhi
1196:Core/Src/motor.c ****   PI_id.max_step = 5000;
 5965              		.loc 2 1196 18
 5966 005e 624B     		ldr	r3, .L254+8
 5967 0060 41F28832 		movw	r2, #5000
 5968 0064 9A82     		strh	r2, [r3, #20]	@ movhi
1197:Core/Src/motor.c ****   PI_id.shift = 10;
 5969              		.loc 2 1197 15
 5970 0066 604B     		ldr	r3, .L254+8
 5971 0068 0A22     		movs	r2, #10
 5972 006a 1A77     		strb	r2, [r3, #28]
1198:Core/Src/motor.c ****   PI_id.limit_i = 1800;
 5973              		.loc 2 1198 17
 5974 006c 5E4B     		ldr	r3, .L254+8
 5975 006e 4FF4E162 		mov	r2, #1800
 5976 0072 9A80     		strh	r2, [r3, #4]	@ movhi
1199:Core/Src/motor.c **** 
1200:Core/Src/motor.c ****   PI_iq.gain_i = I_FACTOR_I_Q;
 5977              		.loc 2 1200 16
 5978 0074 5D4B     		ldr	r3, .L254+12
 5979 0076 0222     		movs	r2, #2
 5980 0078 5A80     		strh	r2, [r3, #2]	@ movhi
1201:Core/Src/motor.c ****   PI_iq.gain_p = P_FACTOR_I_Q;
 5981              		.loc 2 1201 16
 5982 007a 5C4B     		ldr	r3, .L254+12
 5983 007c 6422     		movs	r2, #100
 5984 007e 1A80     		strh	r2, [r3]	@ movhi
1202:Core/Src/motor.c ****   PI_iq.setpoint = 0;
 5985              		.loc 2 1202 18
 5986 0080 5A4B     		ldr	r3, .L254+12
 5987 0082 0022     		movs	r2, #0
 5988 0084 DA60     		str	r2, [r3, #12]
1203:Core/Src/motor.c ****   PI_iq.limit_output = _U_MAX;
 5989              		.loc 2 1203 22
 5990 0086 594B     		ldr	r3, .L254+12
 5991 0088 4FF4FA62 		mov	r2, #2000
 5992 008c DA80     		strh	r2, [r3, #6]	@ movhi
1204:Core/Src/motor.c ****   PI_iq.max_step = 5000;
 5993              		.loc 2 1204 18
ARM GAS  /tmp/ccpEjOub.s 			page 222


 5994 008e 574B     		ldr	r3, .L254+12
 5995 0090 41F28832 		movw	r2, #5000
 5996 0094 9A82     		strh	r2, [r3, #20]	@ movhi
1205:Core/Src/motor.c ****   PI_iq.shift = 10;
 5997              		.loc 2 1205 15
 5998 0096 554B     		ldr	r3, .L254+12
 5999 0098 0A22     		movs	r2, #10
 6000 009a 1A77     		strb	r2, [r3, #28]
1206:Core/Src/motor.c ****   PI_iq.limit_i = _U_MAX;
 6001              		.loc 2 1206 17
 6002 009c 534B     		ldr	r3, .L254+12
 6003 009e 4FF4FA62 		mov	r2, #2000
 6004 00a2 9A80     		strh	r2, [r3, #4]	@ movhi
1207:Core/Src/motor.c **** 
1208:Core/Src/motor.c **** 	// ADC init and run calibration
1209:Core/Src/motor.c **** 	ADC1_Init();
 6005              		.loc 2 1209 2
 6006 00a4 FFF7FEFF 		bl	ADC1_Init
1210:Core/Src/motor.c **** 	if (HAL_ADCEx_Calibration_Start(&hadc1) != HAL_OK) {
 6007              		.loc 2 1210 6
 6008 00a8 5148     		ldr	r0, .L254+16
 6009 00aa FFF7FEFF 		bl	HAL_ADCEx_Calibration_Start
 6010 00ae 0346     		mov	r3, r0
 6011              		.loc 2 1210 5
 6012 00b0 002B     		cmp	r3, #0
 6013 00b2 04D0     		beq	.L245
1211:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 6014              		.loc 2 1211 3
 6015 00b4 40F2BB41 		movw	r1, #1211
 6016 00b8 4E48     		ldr	r0, .L254+20
 6017 00ba FFF7FEFF 		bl	_motor_error_handler
 6018              	.L245:
1212:Core/Src/motor.c **** 	}
1213:Core/Src/motor.c **** 	ADC2_Init();
 6019              		.loc 2 1213 2
 6020 00be FFF7FEFF 		bl	ADC2_Init
1214:Core/Src/motor.c **** 	if (HAL_ADCEx_Calibration_Start(&hadc2) != HAL_OK) {
 6021              		.loc 2 1214 6
 6022 00c2 4D48     		ldr	r0, .L254+24
 6023 00c4 FFF7FEFF 		bl	HAL_ADCEx_Calibration_Start
 6024 00c8 0346     		mov	r3, r0
 6025              		.loc 2 1214 5
 6026 00ca 002B     		cmp	r3, #0
 6027 00cc 04D0     		beq	.L246
1215:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 6028              		.loc 2 1215 3
 6029 00ce 40F2BF41 		movw	r1, #1215
 6030 00d2 4848     		ldr	r0, .L254+20
 6031 00d4 FFF7FEFF 		bl	_motor_error_handler
 6032              	.L246:
1216:Core/Src/motor.c **** 	}
1217:Core/Src/motor.c **** 
1218:Core/Src/motor.c ****   // enable external trigger
1219:Core/Src/motor.c **** 	SET_BIT(ADC1->CR2, ADC_CR2_JEXTTRIG);
 6033              		.loc 2 1219 2
 6034 00d8 484B     		ldr	r3, .L254+28
 6035 00da 9B68     		ldr	r3, [r3, #8]
ARM GAS  /tmp/ccpEjOub.s 			page 223


 6036 00dc 474A     		ldr	r2, .L254+28
 6037 00de 43F40043 		orr	r3, r3, #32768
 6038 00e2 9360     		str	r3, [r2, #8]
1220:Core/Src/motor.c **** 	__HAL_ADC_ENABLE_IT(&hadc1, ADC_IT_JEOC);
 6039              		.loc 2 1220 2
 6040 00e4 424B     		ldr	r3, .L254+16
 6041 00e6 1B68     		ldr	r3, [r3]
 6042 00e8 5A68     		ldr	r2, [r3, #4]
 6043 00ea 414B     		ldr	r3, .L254+16
 6044 00ec 1B68     		ldr	r3, [r3]
 6045 00ee 42F08002 		orr	r2, r2, #128
 6046 00f2 5A60     		str	r2, [r3, #4]
1221:Core/Src/motor.c **** 	SET_BIT(ADC2->CR2, ADC_CR2_JEXTTRIG);
 6047              		.loc 2 1221 2
 6048 00f4 424B     		ldr	r3, .L254+32
 6049 00f6 9B68     		ldr	r3, [r3, #8]
 6050 00f8 414A     		ldr	r2, .L254+32
 6051 00fa 43F40043 		orr	r3, r3, #32768
 6052 00fe 9360     		str	r3, [r2, #8]
1222:Core/Src/motor.c **** 	__HAL_ADC_ENABLE_IT(&hadc2, ADC_IT_JEOC);
 6053              		.loc 2 1222 2
 6054 0100 3D4B     		ldr	r3, .L254+24
 6055 0102 1B68     		ldr	r3, [r3]
 6056 0104 5A68     		ldr	r2, [r3, #4]
 6057 0106 3C4B     		ldr	r3, .L254+24
 6058 0108 1B68     		ldr	r3, [r3]
 6059 010a 42F08002 		orr	r2, r2, #128
 6060 010e 5A60     		str	r2, [r3, #4]
1223:Core/Src/motor.c **** 
1224:Core/Src/motor.c **** 	HAL_ADCEx_MultiModeStart_DMA(&hadc1, (uint32_t*) p_MotorStatePublic->adcData, 6);
 6061              		.loc 2 1224 69
 6062 0110 334B     		ldr	r3, .L254
 6063 0112 1B68     		ldr	r3, [r3]
 6064              		.loc 2 1224 51
 6065 0114 1633     		adds	r3, r3, #22
 6066              		.loc 2 1224 2
 6067 0116 0622     		movs	r2, #6
 6068 0118 1946     		mov	r1, r3
 6069 011a 3548     		ldr	r0, .L254+16
 6070 011c FFF7FEFF 		bl	HAL_ADCEx_MultiModeStart_DMA
1225:Core/Src/motor.c ****   HAL_ADC_Start_IT(&hadc2);
 6071              		.loc 2 1225 3
 6072 0120 3548     		ldr	r0, .L254+24
 6073 0122 FFF7FEFF 		bl	HAL_ADC_Start_IT
1226:Core/Src/motor.c **** 
1227:Core/Src/motor.c ****   // Timers
1228:Core/Src/motor.c **** 	TIM1_Init(); // Swapped the order here!
 6074              		.loc 2 1228 2
 6075 0126 FFF7FEFF 		bl	TIM1_Init
1229:Core/Src/motor.c **** 	TIM2_Init(); // init Timer2 as a counter, where every tick is 128ms
 6076              		.loc 2 1229 2
 6077 012a FFF7FEFF 		bl	TIM2_Init
1230:Core/Src/motor.c ****   TIM3_Init();
 6078              		.loc 2 1230 3
 6079 012e FFF7FEFF 		bl	TIM3_Init
1231:Core/Src/motor.c **** 
1232:Core/Src/motor.c **** 	// Start Timer 1
ARM GAS  /tmp/ccpEjOub.s 			page 224


1233:Core/Src/motor.c **** 	if (HAL_TIM_Base_Start_IT(&htim1) != HAL_OK) {
 6080              		.loc 2 1233 6
 6081 0132 3448     		ldr	r0, .L254+36
 6082 0134 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 6083 0138 0346     		mov	r3, r0
 6084              		.loc 2 1233 5
 6085 013a 002B     		cmp	r3, #0
 6086 013c 04D0     		beq	.L247
1234:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 6087              		.loc 2 1234 3
 6088 013e 40F2D241 		movw	r1, #1234
 6089 0142 2C48     		ldr	r0, .L254+20
 6090 0144 FFF7FEFF 		bl	_motor_error_handler
 6091              	.L247:
1235:Core/Src/motor.c **** 	}
1236:Core/Src/motor.c **** 
1237:Core/Src/motor.c **** 	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
 6092              		.loc 2 1237 2
 6093 0148 0021     		movs	r1, #0
 6094 014a 2E48     		ldr	r0, .L254+36
 6095 014c FFF7FEFF 		bl	HAL_TIM_PWM_Start
1238:Core/Src/motor.c **** 	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_1); // turn on complementary channel
 6096              		.loc 2 1238 2
 6097 0150 0021     		movs	r1, #0
 6098 0152 2C48     		ldr	r0, .L254+36
 6099 0154 FFF7FEFF 		bl	HAL_TIMEx_PWMN_Start
1239:Core/Src/motor.c **** 	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
 6100              		.loc 2 1239 2
 6101 0158 0421     		movs	r1, #4
 6102 015a 2A48     		ldr	r0, .L254+36
 6103 015c FFF7FEFF 		bl	HAL_TIM_PWM_Start
1240:Core/Src/motor.c **** 	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);
 6104              		.loc 2 1240 2
 6105 0160 0421     		movs	r1, #4
 6106 0162 2848     		ldr	r0, .L254+36
 6107 0164 FFF7FEFF 		bl	HAL_TIMEx_PWMN_Start
1241:Core/Src/motor.c **** 	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
 6108              		.loc 2 1241 2
 6109 0168 0821     		movs	r1, #8
 6110 016a 2648     		ldr	r0, .L254+36
 6111 016c FFF7FEFF 		bl	HAL_TIM_PWM_Start
1242:Core/Src/motor.c **** 	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3);
 6112              		.loc 2 1242 2
 6113 0170 0821     		movs	r1, #8
 6114 0172 2448     		ldr	r0, .L254+36
 6115 0174 FFF7FEFF 		bl	HAL_TIMEx_PWMN_Start
1243:Core/Src/motor.c **** 
1244:Core/Src/motor.c **** 	HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_4);
 6116              		.loc 2 1244 2
 6117 0178 0C21     		movs	r1, #12
 6118 017a 2248     		ldr	r0, .L254+36
 6119 017c FFF7FEFF 		bl	HAL_TIM_PWM_Start_IT
1245:Core/Src/motor.c **** 
1246:Core/Src/motor.c **** 	TIM1->CCR4 = TRIGGER_DEFAULT; //ADC sampling just before timer overflow (just before middle of PWM
 6120              		.loc 2 1246 6
 6121 0180 214B     		ldr	r3, .L254+40
 6122              		.loc 2 1246 13
ARM GAS  /tmp/ccpEjOub.s 			page 225


 6123 0182 40F2E472 		movw	r2, #2020
 6124 0186 1A64     		str	r2, [r3, #64]
1247:Core/Src/motor.c **** 
1248:Core/Src/motor.c **** 	// Start Timer 2
1249:Core/Src/motor.c **** 	if (HAL_TIM_Base_Start_IT(&htim2) != HAL_OK) {
 6125              		.loc 2 1249 6
 6126 0188 2048     		ldr	r0, .L254+44
 6127 018a FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 6128 018e 0346     		mov	r3, r0
 6129              		.loc 2 1249 5
 6130 0190 002B     		cmp	r3, #0
 6131 0192 04D0     		beq	.L248
1250:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 6132              		.loc 2 1250 3
 6133 0194 40F2E241 		movw	r1, #1250
 6134 0198 1648     		ldr	r0, .L254+20
 6135 019a FFF7FEFF 		bl	_motor_error_handler
 6136              	.L248:
1251:Core/Src/motor.c **** 	}
1252:Core/Src/motor.c **** 
1253:Core/Src/motor.c ****   // Start Timer 3
1254:Core/Src/motor.c **** 	if (HAL_TIM_Base_Start_IT(&htim3) != HAL_OK) {
 6137              		.loc 2 1254 6
 6138 019e 1C48     		ldr	r0, .L254+48
 6139 01a0 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 6140 01a4 0346     		mov	r3, r0
 6141              		.loc 2 1254 5
 6142 01a6 002B     		cmp	r3, #0
 6143 01a8 04D0     		beq	.L249
1255:Core/Src/motor.c **** 		_motor_error_handler(__FILE__, __LINE__);
 6144              		.loc 2 1255 3
 6145 01aa 40F2E741 		movw	r1, #1255
 6146 01ae 1148     		ldr	r0, .L254+20
 6147 01b0 FFF7FEFF 		bl	_motor_error_handler
 6148              	.L249:
1256:Core/Src/motor.c **** 	}
1257:Core/Src/motor.c **** 
1258:Core/Src/motor.c **** 	disable_pwm();
 6149              		.loc 2 1258 2
 6150 01b4 FFF7FEFF 		bl	disable_pwm
1259:Core/Src/motor.c **** 	TIM1->CCR1 = 1023; //set initial PWM values
 6151              		.loc 2 1259 6
 6152 01b8 134B     		ldr	r3, .L254+40
 6153              		.loc 2 1259 13
 6154 01ba 40F2FF32 		movw	r2, #1023
 6155 01be 5A63     		str	r2, [r3, #52]
1260:Core/Src/motor.c **** 	TIM1->CCR2 = 1023;
 6156              		.loc 2 1260 6
 6157 01c0 114B     		ldr	r3, .L254+40
 6158              		.loc 2 1260 13
 6159 01c2 40F2FF32 		movw	r2, #1023
 6160 01c6 9A63     		str	r2, [r3, #56]
1261:Core/Src/motor.c **** 	TIM1->CCR3 = 1023;
 6161              		.loc 2 1261 6
 6162 01c8 0F4B     		ldr	r3, .L254+40
 6163              		.loc 2 1261 13
 6164 01ca 40F2FF32 		movw	r2, #1023
ARM GAS  /tmp/ccpEjOub.s 			page 226


 6165 01ce DA63     		str	r2, [r3, #60]
1262:Core/Src/motor.c **** 
1263:Core/Src/motor.c **** 	HAL_Delay(1000);
 6166              		.loc 2 1263 2
 6167 01d0 4FF47A70 		mov	r0, #1000
 6168 01d4 FFF7FEFF 		bl	HAL_Delay
 6169              	.LBB19:
1264:Core/Src/motor.c **** 
1265:Core/Src/motor.c ****   // average measured ADC phase currents, to store as the offset of each one
1266:Core/Src/motor.c **** 	for (uint32_t i = 0; i < 16; i++) {		
 6170              		.loc 2 1266 16
 6171 01d8 0023     		movs	r3, #0
 6172 01da FB60     		str	r3, [r7, #12]
 6173              		.loc 2 1266 2
 6174 01dc 3BE0     		b	.L250
 6175              	.L255:
 6176 01de 00BF     		.align	2
 6177              	.L254:
 6178 01e0 00000000 		.word	p_MotorStatePublic
 6179 01e4 00000000 		.word	MS
 6180 01e8 00000000 		.word	PI_id
 6181 01ec 00000000 		.word	PI_iq
 6182 01f0 00000000 		.word	hadc1
 6183 01f4 00000000 		.word	.LC0
 6184 01f8 00000000 		.word	hadc2
 6185 01fc 00240140 		.word	1073816576
 6186 0200 00280140 		.word	1073817600
 6187 0204 00000000 		.word	htim1
 6188 0208 002C0140 		.word	1073818624
 6189 020c 00000000 		.word	htim2
 6190 0210 00000000 		.word	htim3
 6191              	.L251:
1267:Core/Src/motor.c **** 	  HAL_Delay(5);
 6192              		.loc 2 1267 4 discriminator 3
 6193 0214 0520     		movs	r0, #5
 6194 0216 FFF7FEFF 		bl	HAL_Delay
1268:Core/Src/motor.c **** 		ui16_ph1_offset += p_MotorStatePublic->adcData[ADC_CHANA];
 6195              		.loc 2 1268 40 discriminator 3
 6196 021a 4C4B     		ldr	r3, .L256
 6197 021c 1B68     		ldr	r3, [r3]
 6198              		.loc 2 1268 49 discriminator 3
 6199 021e 9A8B     		ldrh	r2, [r3, #28]
 6200              		.loc 2 1268 19 discriminator 3
 6201 0220 4B4B     		ldr	r3, .L256+4
 6202 0222 1B88     		ldrh	r3, [r3]
 6203 0224 1344     		add	r3, r3, r2
 6204 0226 9AB2     		uxth	r2, r3
 6205 0228 494B     		ldr	r3, .L256+4
 6206 022a 1A80     		strh	r2, [r3]	@ movhi
1269:Core/Src/motor.c **** 		ui16_ph2_offset += p_MotorStatePublic->adcData[ADC_CHANB];
 6207              		.loc 2 1269 40 discriminator 3
 6208 022c 474B     		ldr	r3, .L256
 6209 022e 1B68     		ldr	r3, [r3]
 6210              		.loc 2 1269 49 discriminator 3
 6211 0230 DA8B     		ldrh	r2, [r3, #30]
 6212              		.loc 2 1269 19 discriminator 3
 6213 0232 484B     		ldr	r3, .L256+8
ARM GAS  /tmp/ccpEjOub.s 			page 227


 6214 0234 1B88     		ldrh	r3, [r3]
 6215 0236 1344     		add	r3, r3, r2
 6216 0238 9AB2     		uxth	r2, r3
 6217 023a 464B     		ldr	r3, .L256+8
 6218 023c 1A80     		strh	r2, [r3]	@ movhi
1270:Core/Src/motor.c **** 		ui16_ph3_offset += p_MotorStatePublic->adcData[ADC_CHANC];
 6219              		.loc 2 1270 40 discriminator 3
 6220 023e 434B     		ldr	r3, .L256
 6221 0240 1B68     		ldr	r3, [r3]
 6222              		.loc 2 1270 49 discriminator 3
 6223 0242 1A8C     		ldrh	r2, [r3, #32]
 6224              		.loc 2 1270 19 discriminator 3
 6225 0244 444B     		ldr	r3, .L256+12
 6226 0246 1B88     		ldrh	r3, [r3]
 6227 0248 1344     		add	r3, r3, r2
 6228 024a 9AB2     		uxth	r2, r3
 6229 024c 424B     		ldr	r3, .L256+12
 6230 024e 1A80     		strh	r2, [r3]	@ movhi
1266:Core/Src/motor.c **** 	  HAL_Delay(5);
 6231              		.loc 2 1266 32 discriminator 3
 6232 0250 FB68     		ldr	r3, [r7, #12]
 6233 0252 0133     		adds	r3, r3, #1
 6234 0254 FB60     		str	r3, [r7, #12]
 6235              	.L250:
1266:Core/Src/motor.c **** 	  HAL_Delay(5);
 6236              		.loc 2 1266 2 discriminator 1
 6237 0256 FB68     		ldr	r3, [r7, #12]
 6238 0258 0F2B     		cmp	r3, #15
 6239 025a DBD9     		bls	.L251
 6240              	.LBE19:
1271:Core/Src/motor.c **** 	}
1272:Core/Src/motor.c **** 	ui16_ph1_offset = ui16_ph1_offset >> 4;
 6241              		.loc 2 1272 18
 6242 025c 3C4B     		ldr	r3, .L256+4
 6243 025e 1B88     		ldrh	r3, [r3]
 6244 0260 1B09     		lsrs	r3, r3, #4
 6245 0262 9AB2     		uxth	r2, r3
 6246 0264 3A4B     		ldr	r3, .L256+4
 6247 0266 1A80     		strh	r2, [r3]	@ movhi
1273:Core/Src/motor.c **** 	ui16_ph2_offset = ui16_ph2_offset >> 4;
 6248              		.loc 2 1273 18
 6249 0268 3A4B     		ldr	r3, .L256+8
 6250 026a 1B88     		ldrh	r3, [r3]
 6251 026c 1B09     		lsrs	r3, r3, #4
 6252 026e 9AB2     		uxth	r2, r3
 6253 0270 384B     		ldr	r3, .L256+8
 6254 0272 1A80     		strh	r2, [r3]	@ movhi
1274:Core/Src/motor.c **** 	ui16_ph3_offset = ui16_ph3_offset >> 4;
 6255              		.loc 2 1274 18
 6256 0274 384B     		ldr	r3, .L256+12
 6257 0276 1B88     		ldrh	r3, [r3]
 6258 0278 1B09     		lsrs	r3, r3, #4
 6259 027a 9AB2     		uxth	r2, r3
 6260 027c 364B     		ldr	r3, .L256+12
 6261 027e 1A80     		strh	r2, [r3]	@ movhi
1275:Core/Src/motor.c **** 
1276:Core/Src/motor.c ****   ADC1->JSQR = JSQR_PHASE_A; //ADC1 injected reads phase A JL = 0b00, JSQ4 = 0b00100 (decimal 4 = c
ARM GAS  /tmp/ccpEjOub.s 			page 228


 6262              		.loc 2 1276 7
 6263 0280 364B     		ldr	r3, .L256+16
 6264              		.loc 2 1276 14
 6265 0282 4FF4C032 		mov	r2, #98304
 6266 0286 9A63     		str	r2, [r3, #56]
1277:Core/Src/motor.c ****   ADC1->JOFR1 = ui16_ph1_offset;
 6267              		.loc 2 1277 15
 6268 0288 314B     		ldr	r3, .L256+4
 6269 028a 1A88     		ldrh	r2, [r3]
 6270              		.loc 2 1277 7
 6271 028c 334B     		ldr	r3, .L256+16
 6272              		.loc 2 1277 15
 6273 028e 5A61     		str	r2, [r3, #20]
1278:Core/Src/motor.c **** 
1279:Core/Src/motor.c ****   EE_ReadVariable(EEPROM_POS_HALL_ORDER, &i16_hall_order);
 6274              		.loc 2 1279 3
 6275 0290 3349     		ldr	r1, .L256+20
 6276 0292 0020     		movs	r0, #0
 6277 0294 FFF7FEFF 		bl	EE_ReadVariable
 6278              	.LBB20:
1280:Core/Src/motor.c ****   // set variables to value from emulated EEPROM only if valid
1281:Core/Src/motor.c ****   if (i16_hall_order != 0xFFFF) {
1282:Core/Src/motor.c ****     int16_t temp;
1283:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_HALL_45, &temp);
 6279              		.loc 2 1283 5
 6280 0298 07F10A03 		add	r3, r7, #10
 6281 029c 1946     		mov	r1, r3
 6282 029e 0120     		movs	r0, #1
 6283 02a0 FFF7FEFF 		bl	EE_ReadVariable
1284:Core/Src/motor.c ****     Hall_45 = temp << 16;
 6284              		.loc 2 1284 20
 6285 02a4 B7F90A30 		ldrsh	r3, [r7, #10]
 6286 02a8 1B04     		lsls	r3, r3, #16
 6287              		.loc 2 1284 13
 6288 02aa 2E4A     		ldr	r2, .L256+24
 6289 02ac 1360     		str	r3, [r2]
1285:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_HALL_51, &temp);
 6290              		.loc 2 1285 5
 6291 02ae 07F10A03 		add	r3, r7, #10
 6292 02b2 1946     		mov	r1, r3
 6293 02b4 0220     		movs	r0, #2
 6294 02b6 FFF7FEFF 		bl	EE_ReadVariable
1286:Core/Src/motor.c ****     Hall_51 = temp << 16;
 6295              		.loc 2 1286 20
 6296 02ba B7F90A30 		ldrsh	r3, [r7, #10]
 6297 02be 1B04     		lsls	r3, r3, #16
 6298              		.loc 2 1286 13
 6299 02c0 294A     		ldr	r2, .L256+28
 6300 02c2 1360     		str	r3, [r2]
1287:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_HALL_13, &temp);
 6301              		.loc 2 1287 5
 6302 02c4 07F10A03 		add	r3, r7, #10
 6303 02c8 1946     		mov	r1, r3
 6304 02ca 0320     		movs	r0, #3
 6305 02cc FFF7FEFF 		bl	EE_ReadVariable
1288:Core/Src/motor.c ****     Hall_13 = temp << 16;
 6306              		.loc 2 1288 20
ARM GAS  /tmp/ccpEjOub.s 			page 229


 6307 02d0 B7F90A30 		ldrsh	r3, [r7, #10]
 6308 02d4 1B04     		lsls	r3, r3, #16
 6309              		.loc 2 1288 13
 6310 02d6 254A     		ldr	r2, .L256+32
 6311 02d8 1360     		str	r3, [r2]
1289:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_HALL_32, &temp);
 6312              		.loc 2 1289 5
 6313 02da 07F10A03 		add	r3, r7, #10
 6314 02de 1946     		mov	r1, r3
 6315 02e0 0420     		movs	r0, #4
 6316 02e2 FFF7FEFF 		bl	EE_ReadVariable
1290:Core/Src/motor.c ****     Hall_32 = temp << 16;
 6317              		.loc 2 1290 20
 6318 02e6 B7F90A30 		ldrsh	r3, [r7, #10]
 6319 02ea 1B04     		lsls	r3, r3, #16
 6320              		.loc 2 1290 13
 6321 02ec 204A     		ldr	r2, .L256+36
 6322 02ee 1360     		str	r3, [r2]
1291:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_HALL_26, &temp);
 6323              		.loc 2 1291 5
 6324 02f0 07F10A03 		add	r3, r7, #10
 6325 02f4 1946     		mov	r1, r3
 6326 02f6 0520     		movs	r0, #5
 6327 02f8 FFF7FEFF 		bl	EE_ReadVariable
1292:Core/Src/motor.c ****     Hall_26 = temp << 16;
 6328              		.loc 2 1292 20
 6329 02fc B7F90A30 		ldrsh	r3, [r7, #10]
 6330 0300 1B04     		lsls	r3, r3, #16
 6331              		.loc 2 1292 13
 6332 0302 1C4A     		ldr	r2, .L256+40
 6333 0304 1360     		str	r3, [r2]
1293:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_HALL_64, &temp);
 6334              		.loc 2 1293 5
 6335 0306 07F10A03 		add	r3, r7, #10
 6336 030a 1946     		mov	r1, r3
 6337 030c 0620     		movs	r0, #6
 6338 030e FFF7FEFF 		bl	EE_ReadVariable
1294:Core/Src/motor.c ****     Hall_64 = temp << 16;
 6339              		.loc 2 1294 20
 6340 0312 B7F90A30 		ldrsh	r3, [r7, #10]
 6341 0316 1B04     		lsls	r3, r3, #16
 6342              		.loc 2 1294 13
 6343 0318 174A     		ldr	r2, .L256+44
 6344 031a 1360     		str	r3, [r2]
1295:Core/Src/motor.c ****     EE_ReadVariable(EEPROM_POS_KV, &ui32_KV);
 6345              		.loc 2 1295 5
 6346 031c 1749     		ldr	r1, .L256+48
 6347 031e 0720     		movs	r0, #7
 6348 0320 FFF7FEFF 		bl	EE_ReadVariable
1296:Core/Src/motor.c ****     if (ui32_KV == 0) {
 6349              		.loc 2 1296 17
 6350 0324 154B     		ldr	r3, .L256+48
 6351 0326 B3F90030 		ldrsh	r3, [r3]
 6352              		.loc 2 1296 8
 6353 032a 002B     		cmp	r3, #0
 6354 032c 02D1     		bne	.L253
1297:Core/Src/motor.c ****       ui32_KV = 111;
ARM GAS  /tmp/ccpEjOub.s 			page 230


 6355              		.loc 2 1297 15
 6356 032e 134B     		ldr	r3, .L256+48
 6357 0330 6F22     		movs	r2, #111
 6358 0332 1A80     		strh	r2, [r3]	@ movhi
 6359              	.L253:
 6360              	.LBE20:
1298:Core/Src/motor.c ****     }
1299:Core/Src/motor.c ****   } else {
1300:Core/Src/motor.c ****     motor_autodetect();
1301:Core/Src/motor.c ****   }
1302:Core/Src/motor.c **** 
1303:Core/Src/motor.c **** 	HAL_Delay(5);
 6361              		.loc 2 1303 2
 6362 0334 0520     		movs	r0, #5
 6363 0336 FFF7FEFF 		bl	HAL_Delay
1304:Core/Src/motor.c **** 
1305:Core/Src/motor.c ****   disable_pwm();
 6364              		.loc 2 1305 3
 6365 033a FFF7FEFF 		bl	disable_pwm
1306:Core/Src/motor.c **** 
1307:Core/Src/motor.c **** 	get_standstill_position();
 6366              		.loc 2 1307 2
 6367 033e FFF7FEFF 		bl	get_standstill_position
1308:Core/Src/motor.c **** }
 6368              		.loc 2 1308 1
 6369 0342 00BF     		nop
 6370 0344 1037     		adds	r7, r7, #16
 6371              	.LCFI174:
 6372              		.cfi_def_cfa_offset 8
 6373 0346 BD46     		mov	sp, r7
 6374              	.LCFI175:
 6375              		.cfi_def_cfa_register 13
 6376              		@ sp needed
 6377 0348 80BD     		pop	{r7, pc}
 6378              	.L257:
 6379 034a 00BF     		.align	2
 6380              	.L256:
 6381 034c 00000000 		.word	p_MotorStatePublic
 6382 0350 00000000 		.word	ui16_ph1_offset
 6383 0354 00000000 		.word	ui16_ph2_offset
 6384 0358 00000000 		.word	ui16_ph3_offset
 6385 035c 00240140 		.word	1073816576
 6386 0360 00000000 		.word	i16_hall_order
 6387 0364 00000000 		.word	Hall_45
 6388 0368 00000000 		.word	Hall_51
 6389 036c 00000000 		.word	Hall_13
 6390 0370 00000000 		.word	Hall_32
 6391 0374 00000000 		.word	Hall_26
 6392 0378 00000000 		.word	Hall_64
 6393 037c 00000000 		.word	ui32_KV
 6394              		.cfi_endproc
 6395              	.LFE148:
 6397              		.section	.text.svpwm,"ax",%progbits
 6398              		.align	1
 6399              		.global	svpwm
 6400              		.syntax unified
 6401              		.thumb
ARM GAS  /tmp/ccpEjOub.s 			page 231


 6402              		.thumb_func
 6403              		.fpu softvfp
 6405              	svpwm:
 6406              	.LFB149:
1309:Core/Src/motor.c **** 
1310:Core/Src/motor.c **** void svpwm(q31_t q31_u_alpha, q31_t q31_u_beta) {
 6407              		.loc 2 1310 49
 6408              		.cfi_startproc
 6409              		@ args = 0, pretend = 0, frame = 32
 6410              		@ frame_needed = 1, uses_anonymous_args = 0
 6411              		@ link register save eliminated.
 6412 0000 80B4     		push	{r7}
 6413              	.LCFI176:
 6414              		.cfi_def_cfa_offset 4
 6415              		.cfi_offset 7, -4
 6416 0002 89B0     		sub	sp, sp, #36
 6417              	.LCFI177:
 6418              		.cfi_def_cfa_offset 40
 6419 0004 00AF     		add	r7, sp, #0
 6420              	.LCFI178:
 6421              		.cfi_def_cfa_register 7
 6422 0006 7860     		str	r0, [r7, #4]
 6423 0008 3960     		str	r1, [r7]
1311:Core/Src/motor.c **** 
1312:Core/Src/motor.c **** //SVPWM according to chapter 4.9 of UM1052
1313:Core/Src/motor.c **** 
1314:Core/Src/motor.c **** 	q31_t q31_U_alpha = (_SQRT3 * _T * q31_u_alpha) >> 4;
 6424              		.loc 2 1314 35
 6425 000a 7B68     		ldr	r3, [r7, #4]
 6426 000c 4DF6D052 		movw	r2, #56784
 6427 0010 02FB03F3 		mul	r3, r2, r3
 6428              		.loc 2 1314 8
 6429 0014 1B11     		asrs	r3, r3, #4
 6430 0016 FB61     		str	r3, [r7, #28]
1315:Core/Src/motor.c **** 	q31_t q31_U_beta = -_T * q31_u_beta;
 6431              		.loc 2 1315 8
 6432 0018 3B68     		ldr	r3, [r7]
 6433 001a 464A     		ldr	r2, .L269
 6434 001c 02FB03F3 		mul	r3, r2, r3
 6435 0020 BB61     		str	r3, [r7, #24]
1316:Core/Src/motor.c **** 	q31_t X = q31_U_beta;
 6436              		.loc 2 1316 8
 6437 0022 BB69     		ldr	r3, [r7, #24]
 6438 0024 7B61     		str	r3, [r7, #20]
1317:Core/Src/motor.c **** 	q31_t Y = (q31_U_alpha + q31_U_beta) >> 1;
 6439              		.loc 2 1317 25
 6440 0026 FA69     		ldr	r2, [r7, #28]
 6441 0028 BB69     		ldr	r3, [r7, #24]
 6442 002a 1344     		add	r3, r3, r2
 6443              		.loc 2 1317 8
 6444 002c 5B10     		asrs	r3, r3, #1
 6445 002e 3B61     		str	r3, [r7, #16]
1318:Core/Src/motor.c **** 	q31_t Z = (q31_U_beta - q31_U_alpha) >> 1;
 6446              		.loc 2 1318 24
 6447 0030 BA69     		ldr	r2, [r7, #24]
 6448 0032 FB69     		ldr	r3, [r7, #28]
 6449 0034 D31A     		subs	r3, r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 232


 6450              		.loc 2 1318 8
 6451 0036 5B10     		asrs	r3, r3, #1
 6452 0038 FB60     		str	r3, [r7, #12]
1319:Core/Src/motor.c **** 
1320:Core/Src/motor.c **** 	//Sector 1 & 4
1321:Core/Src/motor.c **** 	if ((Y >= 0 && Z < 0 && X > 0) || (Y < 0 && Z >= 0 && X <= 0)) {
 6453              		.loc 2 1321 5
 6454 003a 3B69     		ldr	r3, [r7, #16]
 6455 003c 002B     		cmp	r3, #0
 6456 003e 05DB     		blt	.L259
 6457              		.loc 2 1321 14 discriminator 1
 6458 0040 FB68     		ldr	r3, [r7, #12]
 6459 0042 002B     		cmp	r3, #0
 6460 0044 02DA     		bge	.L259
 6461              		.loc 2 1321 23 discriminator 3
 6462 0046 7B69     		ldr	r3, [r7, #20]
 6463 0048 002B     		cmp	r3, #0
 6464 004a 08DC     		bgt	.L260
 6465              	.L259:
 6466              		.loc 2 1321 33 discriminator 5
 6467 004c 3B69     		ldr	r3, [r7, #16]
 6468 004e 002B     		cmp	r3, #0
 6469 0050 1DDA     		bge	.L261
 6470              		.loc 2 1321 43 discriminator 6
 6471 0052 FB68     		ldr	r3, [r7, #12]
 6472 0054 002B     		cmp	r3, #0
 6473 0056 1ADB     		blt	.L261
 6474              		.loc 2 1321 53 discriminator 7
 6475 0058 7B69     		ldr	r3, [r7, #20]
 6476 005a 002B     		cmp	r3, #0
 6477 005c 17DC     		bgt	.L261
 6478              	.L260:
1322:Core/Src/motor.c **** 		switchtime[0] = ((_T + X - Z) >> 12) + (_T >> 1); // right shift 11 for dividing by peroid (=2^11
 6479              		.loc 2 1322 24
 6480 005e 7B69     		ldr	r3, [r7, #20]
 6481 0060 03F2EC72 		addw	r2, r3, #2028
 6482              		.loc 2 1322 28
 6483 0064 FB68     		ldr	r3, [r7, #12]
 6484 0066 D31A     		subs	r3, r2, r3
 6485              		.loc 2 1322 33
 6486 0068 1B13     		asrs	r3, r3, #12
 6487              		.loc 2 1322 40
 6488 006a 03F2F633 		addw	r3, r3, #1014
 6489              		.loc 2 1322 17
 6490 006e 324A     		ldr	r2, .L269+4
 6491 0070 1360     		str	r3, [r2]
1323:Core/Src/motor.c **** 		switchtime[1] = switchtime[0] + (Z >> 11);
 6492              		.loc 2 1323 29
 6493 0072 314B     		ldr	r3, .L269+4
 6494 0074 1A68     		ldr	r2, [r3]
 6495              		.loc 2 1323 38
 6496 0076 FB68     		ldr	r3, [r7, #12]
 6497 0078 DB12     		asrs	r3, r3, #11
 6498              		.loc 2 1323 33
 6499 007a 1344     		add	r3, r3, r2
 6500              		.loc 2 1323 17
 6501 007c 2E4A     		ldr	r2, .L269+4
ARM GAS  /tmp/ccpEjOub.s 			page 233


 6502 007e 5360     		str	r3, [r2, #4]
1324:Core/Src/motor.c **** 		switchtime[2] = switchtime[1] - (X >> 11);
 6503              		.loc 2 1324 29
 6504 0080 2D4B     		ldr	r3, .L269+4
 6505 0082 5A68     		ldr	r2, [r3, #4]
 6506              		.loc 2 1324 38
 6507 0084 7B69     		ldr	r3, [r7, #20]
 6508 0086 DB12     		asrs	r3, r3, #11
 6509              		.loc 2 1324 33
 6510 0088 D31A     		subs	r3, r2, r3
 6511              		.loc 2 1324 17
 6512 008a 2B4A     		ldr	r2, .L269+4
 6513 008c 9360     		str	r3, [r2, #8]
 6514              	.L261:
1325:Core/Src/motor.c **** 	}
1326:Core/Src/motor.c **** 
1327:Core/Src/motor.c **** 	//Sector 2 & 5
1328:Core/Src/motor.c **** 	if ((Y >= 0 && Z >= 0) || (Y < 0 && Z < 0)) {
 6515              		.loc 2 1328 5
 6516 008e 3B69     		ldr	r3, [r7, #16]
 6517 0090 002B     		cmp	r3, #0
 6518 0092 02DB     		blt	.L262
 6519              		.loc 2 1328 14 discriminator 1
 6520 0094 FB68     		ldr	r3, [r7, #12]
 6521 0096 002B     		cmp	r3, #0
 6522 0098 05DA     		bge	.L263
 6523              	.L262:
 6524              		.loc 2 1328 25 discriminator 3
 6525 009a 3B69     		ldr	r3, [r7, #16]
 6526 009c 002B     		cmp	r3, #0
 6527 009e 1ADA     		bge	.L264
 6528              		.loc 2 1328 35 discriminator 4
 6529 00a0 FB68     		ldr	r3, [r7, #12]
 6530 00a2 002B     		cmp	r3, #0
 6531 00a4 17DA     		bge	.L264
 6532              	.L263:
1329:Core/Src/motor.c **** 		switchtime[0] = ((_T + Y - Z) >> 12) + (_T >> 1);
 6533              		.loc 2 1329 24
 6534 00a6 3B69     		ldr	r3, [r7, #16]
 6535 00a8 03F2EC72 		addw	r2, r3, #2028
 6536              		.loc 2 1329 28
 6537 00ac FB68     		ldr	r3, [r7, #12]
 6538 00ae D31A     		subs	r3, r2, r3
 6539              		.loc 2 1329 33
 6540 00b0 1B13     		asrs	r3, r3, #12
 6541              		.loc 2 1329 40
 6542 00b2 03F2F633 		addw	r3, r3, #1014
 6543              		.loc 2 1329 17
 6544 00b6 204A     		ldr	r2, .L269+4
 6545 00b8 1360     		str	r3, [r2]
1330:Core/Src/motor.c **** 		switchtime[1] = switchtime[0] + (Z >> 11);
 6546              		.loc 2 1330 29
 6547 00ba 1F4B     		ldr	r3, .L269+4
 6548 00bc 1A68     		ldr	r2, [r3]
 6549              		.loc 2 1330 38
 6550 00be FB68     		ldr	r3, [r7, #12]
 6551 00c0 DB12     		asrs	r3, r3, #11
ARM GAS  /tmp/ccpEjOub.s 			page 234


 6552              		.loc 2 1330 33
 6553 00c2 1344     		add	r3, r3, r2
 6554              		.loc 2 1330 17
 6555 00c4 1C4A     		ldr	r2, .L269+4
 6556 00c6 5360     		str	r3, [r2, #4]
1331:Core/Src/motor.c **** 		switchtime[2] = switchtime[0] - (Y >> 11);
 6557              		.loc 2 1331 29
 6558 00c8 1B4B     		ldr	r3, .L269+4
 6559 00ca 1A68     		ldr	r2, [r3]
 6560              		.loc 2 1331 38
 6561 00cc 3B69     		ldr	r3, [r7, #16]
 6562 00ce DB12     		asrs	r3, r3, #11
 6563              		.loc 2 1331 33
 6564 00d0 D31A     		subs	r3, r2, r3
 6565              		.loc 2 1331 17
 6566 00d2 194A     		ldr	r2, .L269+4
 6567 00d4 9360     		str	r3, [r2, #8]
 6568              	.L264:
1332:Core/Src/motor.c **** 	}
1333:Core/Src/motor.c **** 
1334:Core/Src/motor.c **** 	//Sector 3 & 6
1335:Core/Src/motor.c **** 	if ((Y < 0 && Z >= 0 && X > 0) || (Y >= 0 && Z < 0 && X <= 0)) {
 6569              		.loc 2 1335 5
 6570 00d6 3B69     		ldr	r3, [r7, #16]
 6571 00d8 002B     		cmp	r3, #0
 6572 00da 05DA     		bge	.L265
 6573              		.loc 2 1335 13 discriminator 1
 6574 00dc FB68     		ldr	r3, [r7, #12]
 6575 00de 002B     		cmp	r3, #0
 6576 00e0 02DB     		blt	.L265
 6577              		.loc 2 1335 23 discriminator 3
 6578 00e2 7B69     		ldr	r3, [r7, #20]
 6579 00e4 002B     		cmp	r3, #0
 6580 00e6 08DC     		bgt	.L266
 6581              	.L265:
 6582              		.loc 2 1335 33 discriminator 5
 6583 00e8 3B69     		ldr	r3, [r7, #16]
 6584 00ea 002B     		cmp	r3, #0
 6585 00ec 1DDB     		blt	.L268
 6586              		.loc 2 1335 44 discriminator 6
 6587 00ee FB68     		ldr	r3, [r7, #12]
 6588 00f0 002B     		cmp	r3, #0
 6589 00f2 1ADA     		bge	.L268
 6590              		.loc 2 1335 53 discriminator 7
 6591 00f4 7B69     		ldr	r3, [r7, #20]
 6592 00f6 002B     		cmp	r3, #0
 6593 00f8 17DC     		bgt	.L268
 6594              	.L266:
1336:Core/Src/motor.c **** 		switchtime[0] = ((_T + Y - X) >> 12) + (_T >> 1);
 6595              		.loc 2 1336 24
 6596 00fa 3B69     		ldr	r3, [r7, #16]
 6597 00fc 03F2EC72 		addw	r2, r3, #2028
 6598              		.loc 2 1336 28
 6599 0100 7B69     		ldr	r3, [r7, #20]
 6600 0102 D31A     		subs	r3, r2, r3
 6601              		.loc 2 1336 33
 6602 0104 1B13     		asrs	r3, r3, #12
ARM GAS  /tmp/ccpEjOub.s 			page 235


 6603              		.loc 2 1336 40
 6604 0106 03F2F633 		addw	r3, r3, #1014
 6605              		.loc 2 1336 17
 6606 010a 0B4A     		ldr	r2, .L269+4
 6607 010c 1360     		str	r3, [r2]
1337:Core/Src/motor.c **** 		switchtime[2] = switchtime[0] - (Y >> 11);
 6608              		.loc 2 1337 29
 6609 010e 0A4B     		ldr	r3, .L269+4
 6610 0110 1A68     		ldr	r2, [r3]
 6611              		.loc 2 1337 38
 6612 0112 3B69     		ldr	r3, [r7, #16]
 6613 0114 DB12     		asrs	r3, r3, #11
 6614              		.loc 2 1337 33
 6615 0116 D31A     		subs	r3, r2, r3
 6616              		.loc 2 1337 17
 6617 0118 074A     		ldr	r2, .L269+4
 6618 011a 9360     		str	r3, [r2, #8]
1338:Core/Src/motor.c **** 		switchtime[1] = switchtime[2] + (X >> 11);
 6619              		.loc 2 1338 29
 6620 011c 064B     		ldr	r3, .L269+4
 6621 011e 9A68     		ldr	r2, [r3, #8]
 6622              		.loc 2 1338 38
 6623 0120 7B69     		ldr	r3, [r7, #20]
 6624 0122 DB12     		asrs	r3, r3, #11
 6625              		.loc 2 1338 33
 6626 0124 1344     		add	r3, r3, r2
 6627              		.loc 2 1338 17
 6628 0126 044A     		ldr	r2, .L269+4
 6629 0128 5360     		str	r3, [r2, #4]
 6630              	.L268:
1339:Core/Src/motor.c **** 	}
1340:Core/Src/motor.c **** }
 6631              		.loc 2 1340 1
 6632 012a 00BF     		nop
 6633 012c 2437     		adds	r7, r7, #36
 6634              	.LCFI179:
 6635              		.cfi_def_cfa_offset 4
 6636 012e BD46     		mov	sp, r7
 6637              	.LCFI180:
 6638              		.cfi_def_cfa_register 13
 6639              		@ sp needed
 6640 0130 80BC     		pop	{r7}
 6641              	.LCFI181:
 6642              		.cfi_restore 7
 6643              		.cfi_def_cfa_offset 0
 6644 0132 7047     		bx	lr
 6645              	.L270:
 6646              		.align	2
 6647              	.L269:
 6648 0134 14F8FFFF 		.word	-2028
 6649 0138 00000000 		.word	switchtime
 6650              		.cfi_endproc
 6651              	.LFE149:
 6653              		.section	.text.FOC_calculation,"ax",%progbits
 6654              		.align	1
 6655              		.global	FOC_calculation
 6656              		.syntax unified
ARM GAS  /tmp/ccpEjOub.s 			page 236


 6657              		.thumb
 6658              		.thumb_func
 6659              		.fpu softvfp
 6661              	FOC_calculation:
 6662              	.LFB150:
1341:Core/Src/motor.c **** 
1342:Core/Src/motor.c **** void FOC_calculation(int16_t int16_i_as, int16_t int16_i_bs, q31_t q31_teta, MotorState_t *MS) {
 6663              		.loc 2 1342 96
 6664              		.cfi_startproc
 6665              		@ args = 0, pretend = 0, frame = 48
 6666              		@ frame_needed = 1, uses_anonymous_args = 0
 6667 0000 B0B5     		push	{r4, r5, r7, lr}
 6668              	.LCFI182:
 6669              		.cfi_def_cfa_offset 16
 6670              		.cfi_offset 4, -16
 6671              		.cfi_offset 5, -12
 6672              		.cfi_offset 7, -8
 6673              		.cfi_offset 14, -4
 6674 0002 8EB0     		sub	sp, sp, #56
 6675              	.LCFI183:
 6676              		.cfi_def_cfa_offset 72
 6677 0004 02AF     		add	r7, sp, #8
 6678              	.LCFI184:
 6679              		.cfi_def_cfa 7, 64
 6680 0006 BA60     		str	r2, [r7, #8]
 6681 0008 7B60     		str	r3, [r7, #4]
 6682 000a 0346     		mov	r3, r0	@ movhi
 6683 000c FB81     		strh	r3, [r7, #14]	@ movhi
 6684 000e 0B46     		mov	r3, r1	@ movhi
 6685 0010 BB81     		strh	r3, [r7, #12]	@ movhi
1343:Core/Src/motor.c **** 
1344:Core/Src/motor.c ****   q31_t q31_i_alpha = 0;
 6686              		.loc 2 1344 9
 6687 0012 0023     		movs	r3, #0
 6688 0014 FB62     		str	r3, [r7, #44]
1345:Core/Src/motor.c **** 	q31_t q31_i_beta = 0;
 6689              		.loc 2 1345 8
 6690 0016 0023     		movs	r3, #0
 6691 0018 BB62     		str	r3, [r7, #40]
1346:Core/Src/motor.c **** 	q31_t q31_u_alpha = 0;
 6692              		.loc 2 1346 8
 6693 001a 0023     		movs	r3, #0
 6694 001c 7B62     		str	r3, [r7, #36]
1347:Core/Src/motor.c **** 	q31_t q31_u_beta = 0;
 6695              		.loc 2 1347 8
 6696 001e 0023     		movs	r3, #0
 6697 0020 3B62     		str	r3, [r7, #32]
1348:Core/Src/motor.c **** 	q31_t q31_i_d = 0;
 6698              		.loc 2 1348 8
 6699 0022 0023     		movs	r3, #0
 6700 0024 FB61     		str	r3, [r7, #28]
1349:Core/Src/motor.c **** 	q31_t q31_i_q = 0;
 6701              		.loc 2 1349 8
 6702 0026 0023     		movs	r3, #0
 6703 0028 BB61     		str	r3, [r7, #24]
1350:Core/Src/motor.c **** 
1351:Core/Src/motor.c **** 	q31_t sinevalue = 0, cosinevalue = 0;
ARM GAS  /tmp/ccpEjOub.s 			page 237


 6704              		.loc 2 1351 8
 6705 002a 0023     		movs	r3, #0
 6706 002c 7B61     		str	r3, [r7, #20]
 6707              		.loc 2 1351 23
 6708 002e 0023     		movs	r3, #0
 6709 0030 3B61     		str	r3, [r7, #16]
1352:Core/Src/motor.c **** 
1353:Core/Src/motor.c **** 		// Clark transformation
1354:Core/Src/motor.c **** 	arm_clarke_q31((q31_t) int16_i_as, (q31_t) int16_i_bs, &q31_i_alpha, &q31_i_beta);
 6710              		.loc 2 1354 2
 6711 0032 B7F90E00 		ldrsh	r0, [r7, #14]
 6712 0036 B7F90C10 		ldrsh	r1, [r7, #12]
 6713 003a 07F12803 		add	r3, r7, #40
 6714 003e 07F12C02 		add	r2, r7, #44
 6715 0042 FFF7FEFF 		bl	arm_clarke_q31
1355:Core/Src/motor.c **** 
1356:Core/Src/motor.c **** 	arm_sin_cos_q31(q31_teta, &sinevalue, &cosinevalue);
 6716              		.loc 2 1356 2
 6717 0046 07F11002 		add	r2, r7, #16
 6718 004a 07F11403 		add	r3, r7, #20
 6719 004e 1946     		mov	r1, r3
 6720 0050 B868     		ldr	r0, [r7, #8]
 6721 0052 FFF7FEFF 		bl	arm_sin_cos_q31
1357:Core/Src/motor.c ****   // limit output valyes of arm_sin_cos_q31() as some seem wrong
1358:Core/Src/motor.c **** 	if (sinevalue == -2147483648) sinevalue = -2147483647;
 6722              		.loc 2 1358 16
 6723 0056 7B69     		ldr	r3, [r7, #20]
 6724              		.loc 2 1358 5
 6725 0058 B3F1004F 		cmp	r3, #-2147483648
 6726 005c 01D1     		bne	.L272
 6727              		.loc 2 1358 42 discriminator 1
 6728 005e 314B     		ldr	r3, .L275
 6729 0060 7B61     		str	r3, [r7, #20]
 6730              	.L272:
1359:Core/Src/motor.c **** 	if (cosinevalue == 2147483648) cosinevalue = 2147483647;
1360:Core/Src/motor.c **** 
1361:Core/Src/motor.c **** 	// Park transformation
1362:Core/Src/motor.c **** 	arm_park_q31(q31_i_alpha, q31_i_beta, &q31_i_d, &q31_i_q, sinevalue, cosinevalue);
 6731              		.loc 2 1362 2
 6732 0062 F86A     		ldr	r0, [r7, #44]
 6733 0064 B96A     		ldr	r1, [r7, #40]
 6734 0066 7B69     		ldr	r3, [r7, #20]
 6735 0068 3A69     		ldr	r2, [r7, #16]
 6736 006a 07F11805 		add	r5, r7, #24
 6737 006e 07F11C04 		add	r4, r7, #28
 6738 0072 0192     		str	r2, [sp, #4]
 6739 0074 0093     		str	r3, [sp]
 6740 0076 2B46     		mov	r3, r5
 6741 0078 2246     		mov	r2, r4
 6742 007a FFF7FEFF 		bl	arm_park_q31
1363:Core/Src/motor.c **** 
1364:Core/Src/motor.c **** 	q31_i_q_fil -= q31_i_q_fil >> 4;
 6743              		.loc 2 1364 14
 6744 007e 2A4B     		ldr	r3, .L275+4
 6745 0080 1A68     		ldr	r2, [r3]
 6746              		.loc 2 1364 29
 6747 0082 294B     		ldr	r3, .L275+4
ARM GAS  /tmp/ccpEjOub.s 			page 238


 6748 0084 1B68     		ldr	r3, [r3]
 6749 0086 1B11     		asrs	r3, r3, #4
 6750              		.loc 2 1364 14
 6751 0088 D31A     		subs	r3, r2, r3
 6752 008a 274A     		ldr	r2, .L275+4
 6753 008c 1360     		str	r3, [r2]
1365:Core/Src/motor.c **** 	q31_i_q_fil += q31_i_q;
 6754              		.loc 2 1365 14
 6755 008e 264B     		ldr	r3, .L275+4
 6756 0090 1A68     		ldr	r2, [r3]
 6757 0092 BB69     		ldr	r3, [r7, #24]
 6758 0094 1344     		add	r3, r3, r2
 6759 0096 244A     		ldr	r2, .L275+4
 6760 0098 1360     		str	r3, [r2]
1366:Core/Src/motor.c **** 	MS->i_q = q31_i_q_fil >> 4;
 6761              		.loc 2 1366 24
 6762 009a 234B     		ldr	r3, .L275+4
 6763 009c 1B68     		ldr	r3, [r3]
 6764 009e 1A11     		asrs	r2, r3, #4
 6765              		.loc 2 1366 10
 6766 00a0 7B68     		ldr	r3, [r7, #4]
 6767 00a2 5A60     		str	r2, [r3, #4]
1367:Core/Src/motor.c **** 
1368:Core/Src/motor.c **** 	q31_i_d_fil -= q31_i_d_fil >> 4;
 6768              		.loc 2 1368 14
 6769 00a4 214B     		ldr	r3, .L275+8
 6770 00a6 1A68     		ldr	r2, [r3]
 6771              		.loc 2 1368 29
 6772 00a8 204B     		ldr	r3, .L275+8
 6773 00aa 1B68     		ldr	r3, [r3]
 6774 00ac 1B11     		asrs	r3, r3, #4
 6775              		.loc 2 1368 14
 6776 00ae D31A     		subs	r3, r2, r3
 6777 00b0 1E4A     		ldr	r2, .L275+8
 6778 00b2 1360     		str	r3, [r2]
1369:Core/Src/motor.c **** 	q31_i_d_fil += q31_i_d;
 6779              		.loc 2 1369 14
 6780 00b4 1D4B     		ldr	r3, .L275+8
 6781 00b6 1A68     		ldr	r2, [r3]
 6782 00b8 FB69     		ldr	r3, [r7, #28]
 6783 00ba 1344     		add	r3, r3, r2
 6784 00bc 1B4A     		ldr	r2, .L275+8
 6785 00be 1360     		str	r3, [r2]
1370:Core/Src/motor.c **** 	MS->i_d = q31_i_d_fil >> 4;
 6786              		.loc 2 1370 24
 6787 00c0 1A4B     		ldr	r3, .L275+8
 6788 00c2 1B68     		ldr	r3, [r3]
 6789 00c4 1A11     		asrs	r2, r3, #4
 6790              		.loc 2 1370 10
 6791 00c6 7B68     		ldr	r3, [r7, #4]
 6792 00c8 1A60     		str	r2, [r3]
1371:Core/Src/motor.c **** 
1372:Core/Src/motor.c **** 	// Control iq
1373:Core/Src/motor.c ****   
1374:Core/Src/motor.c ****   //set static volatage for hall angle detection
1375:Core/Src/motor.c **** 	if (MS->KV_detect_flag) {  
 6793              		.loc 2 1375 8
ARM GAS  /tmp/ccpEjOub.s 			page 239


 6794 00ca 7B68     		ldr	r3, [r7, #4]
 6795 00cc B3F93430 		ldrsh	r3, [r3, #52]
 6796              		.loc 2 1375 5
 6797 00d0 002B     		cmp	r3, #0
 6798 00d2 09D0     		beq	.L273
1376:Core/Src/motor.c ****     MS->u_q = MS->KV_detect_flag;
 6799              		.loc 2 1376 17
 6800 00d4 7B68     		ldr	r3, [r7, #4]
 6801 00d6 B3F93430 		ldrsh	r3, [r3, #52]
 6802 00da 1A46     		mov	r2, r3
 6803              		.loc 2 1376 13
 6804 00dc 7B68     		ldr	r3, [r7, #4]
 6805 00de 1A62     		str	r2, [r3, #32]
1377:Core/Src/motor.c ****     MS->u_d = 0;
 6806              		.loc 2 1377 13
 6807 00e0 7B68     		ldr	r3, [r7, #4]
 6808 00e2 0022     		movs	r2, #0
 6809 00e4 DA61     		str	r2, [r3, #28]
 6810 00e6 01E0     		b	.L274
 6811              	.L273:
1378:Core/Src/motor.c ****   } else {
1379:Core/Src/motor.c ****     runPIcontrol();
 6812              		.loc 2 1379 5
 6813 00e8 FFF7FEFF 		bl	runPIcontrol
 6814              	.L274:
1380:Core/Src/motor.c ****   }
1381:Core/Src/motor.c **** 
1382:Core/Src/motor.c **** 	// inverse Park transformation
1383:Core/Src/motor.c **** 	arm_inv_park_q31(MS->u_d, MS->u_q, &q31_u_alpha, &q31_u_beta, -sinevalue, cosinevalue);
 6815              		.loc 2 1383 2
 6816 00ec 7B68     		ldr	r3, [r7, #4]
 6817 00ee D869     		ldr	r0, [r3, #28]
 6818 00f0 7B68     		ldr	r3, [r7, #4]
 6819 00f2 196A     		ldr	r1, [r3, #32]
 6820 00f4 7B69     		ldr	r3, [r7, #20]
 6821 00f6 5B42     		rsbs	r3, r3, #0
 6822 00f8 3A69     		ldr	r2, [r7, #16]
 6823 00fa 07F12005 		add	r5, r7, #32
 6824 00fe 07F12404 		add	r4, r7, #36
 6825 0102 0192     		str	r2, [sp, #4]
 6826 0104 0093     		str	r3, [sp]
 6827 0106 2B46     		mov	r3, r5
 6828 0108 2246     		mov	r2, r4
 6829 010a FFF7FEFF 		bl	arm_inv_park_q31
1384:Core/Src/motor.c **** 
1385:Core/Src/motor.c **** 	// call SVPWM calculation
1386:Core/Src/motor.c **** 	svpwm(q31_u_alpha, q31_u_beta);
 6830              		.loc 2 1386 2
 6831 010e 7B6A     		ldr	r3, [r7, #36]
 6832 0110 3A6A     		ldr	r2, [r7, #32]
 6833 0112 1146     		mov	r1, r2
 6834 0114 1846     		mov	r0, r3
 6835 0116 FFF7FEFF 		bl	svpwm
1387:Core/Src/motor.c **** }
 6836              		.loc 2 1387 1
 6837 011a 00BF     		nop
 6838 011c 3037     		adds	r7, r7, #48
ARM GAS  /tmp/ccpEjOub.s 			page 240


 6839              	.LCFI185:
 6840              		.cfi_def_cfa_offset 16
 6841 011e BD46     		mov	sp, r7
 6842              	.LCFI186:
 6843              		.cfi_def_cfa_register 13
 6844              		@ sp needed
 6845 0120 B0BD     		pop	{r4, r5, r7, pc}
 6846              	.L276:
 6847 0122 00BF     		.align	2
 6848              	.L275:
 6849 0124 01000080 		.word	-2147483647
 6850 0128 00000000 		.word	q31_i_q_fil
 6851 012c 00000000 		.word	q31_i_d_fil
 6852              		.cfi_endproc
 6853              	.LFE150:
 6855              		.section	.text.HAL_ADCEx_InjectedConvCpltCallback,"ax",%progbits
 6856              		.align	1
 6857              		.global	HAL_ADCEx_InjectedConvCpltCallback
 6858              		.syntax unified
 6859              		.thumb
 6860              		.thumb_func
 6861              		.fpu softvfp
 6863              	HAL_ADCEx_InjectedConvCpltCallback:
 6864              	.LFB151:
1388:Core/Src/motor.c **** 
1389:Core/Src/motor.c **** // injected ADC
1390:Core/Src/motor.c **** void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc) {
 6865              		.loc 2 1390 66
 6866              		.cfi_startproc
 6867              		@ args = 0, pretend = 0, frame = 16
 6868              		@ frame_needed = 1, uses_anonymous_args = 0
 6869 0000 80B5     		push	{r7, lr}
 6870              	.LCFI187:
 6871              		.cfi_def_cfa_offset 8
 6872              		.cfi_offset 7, -8
 6873              		.cfi_offset 14, -4
 6874 0002 84B0     		sub	sp, sp, #16
 6875              	.LCFI188:
 6876              		.cfi_def_cfa_offset 24
 6877 0004 00AF     		add	r7, sp, #0
 6878              	.LCFI189:
 6879              		.cfi_def_cfa_register 7
 6880 0006 7860     		str	r0, [r7, #4]
1391:Core/Src/motor.c **** 
1392:Core/Src/motor.c ****   // read phase currents
1393:Core/Src/motor.c ****   switch (MS.char_dyn_adc_state) //read in according to state
 6881              		.loc 2 1393 13
 6882 0008 7E4B     		ldr	r3, .L295
 6883 000a 93F82C30 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 6884 000e 032B     		cmp	r3, #3
 6885 0010 6DD8     		bhi	.L278
 6886 0012 01A2     		adr	r2, .L280
 6887 0014 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 6888              		.p2align 2
 6889              	.L280:
 6890 0018 EF000000 		.word	.L278+1
 6891 001c 29000000 		.word	.L282+1
ARM GAS  /tmp/ccpEjOub.s 			page 241


 6892 0020 5F000000 		.word	.L281+1
 6893 0024 A7000000 		.word	.L279+1
 6894              		.p2align 1
 6895              	.L282:
1394:Core/Src/motor.c ****   {
1395:Core/Src/motor.c ****     case 1: //Phase C at high dutycycles, read from A+B directly
1396:Core/Src/motor.c ****       raw_inj1 = (q31_t) HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_1);
 6896              		.loc 2 1396 26
 6897 0028 0121     		movs	r1, #1
 6898 002a 7748     		ldr	r0, .L295+4
 6899 002c FFF7FEFF 		bl	HAL_ADCEx_InjectedGetValue
 6900 0030 0346     		mov	r3, r0
 6901              		.loc 2 1396 18
 6902 0032 1A46     		mov	r2, r3
 6903              		.loc 2 1396 16
 6904 0034 754B     		ldr	r3, .L295+8
 6905 0036 1A60     		str	r2, [r3]
1397:Core/Src/motor.c ****       i16_ph1_current = raw_inj1;
 6906              		.loc 2 1397 23
 6907 0038 744B     		ldr	r3, .L295+8
 6908 003a 1B68     		ldr	r3, [r3]
 6909 003c 1AB2     		sxth	r2, r3
 6910 003e 744B     		ldr	r3, .L295+12
 6911 0040 1A80     		strh	r2, [r3]	@ movhi
1398:Core/Src/motor.c **** 
1399:Core/Src/motor.c ****       raw_inj2 = (q31_t) HAL_ADCEx_InjectedGetValue(&hadc2, ADC_INJECTED_RANK_1);
 6912              		.loc 2 1399 26
 6913 0042 0121     		movs	r1, #1
 6914 0044 7348     		ldr	r0, .L295+16
 6915 0046 FFF7FEFF 		bl	HAL_ADCEx_InjectedGetValue
 6916 004a 0346     		mov	r3, r0
 6917              		.loc 2 1399 18
 6918 004c 1A46     		mov	r2, r3
 6919              		.loc 2 1399 16
 6920 004e 724B     		ldr	r3, .L295+20
 6921 0050 1A60     		str	r2, [r3]
1400:Core/Src/motor.c ****       i16_ph2_current = raw_inj2;
 6922              		.loc 2 1400 23
 6923 0052 714B     		ldr	r3, .L295+20
 6924 0054 1B68     		ldr	r3, [r3]
 6925 0056 1AB2     		sxth	r2, r3
 6926 0058 704B     		ldr	r3, .L295+24
 6927 005a 1A80     		strh	r2, [r3]	@ movhi
1401:Core/Src/motor.c ****       break;
 6928              		.loc 2 1401 7
 6929 005c 47E0     		b	.L278
 6930              	.L281:
1402:Core/Src/motor.c **** 
1403:Core/Src/motor.c ****     case 2: //Phase A at high dutycycles, read from B+C (A = -B -C)
1404:Core/Src/motor.c ****       raw_inj2 = (q31_t) HAL_ADCEx_InjectedGetValue(&hadc2, ADC_INJECTED_RANK_1);
 6931              		.loc 2 1404 26
 6932 005e 0121     		movs	r1, #1
 6933 0060 6C48     		ldr	r0, .L295+16
 6934 0062 FFF7FEFF 		bl	HAL_ADCEx_InjectedGetValue
 6935 0066 0346     		mov	r3, r0
 6936              		.loc 2 1404 18
 6937 0068 1A46     		mov	r2, r3
ARM GAS  /tmp/ccpEjOub.s 			page 242


 6938              		.loc 2 1404 16
 6939 006a 6B4B     		ldr	r3, .L295+20
 6940 006c 1A60     		str	r2, [r3]
1405:Core/Src/motor.c ****       i16_ph2_current = raw_inj2;
 6941              		.loc 2 1405 23
 6942 006e 6A4B     		ldr	r3, .L295+20
 6943 0070 1B68     		ldr	r3, [r3]
 6944 0072 1AB2     		sxth	r2, r3
 6945 0074 694B     		ldr	r3, .L295+24
 6946 0076 1A80     		strh	r2, [r3]	@ movhi
1406:Core/Src/motor.c **** 
1407:Core/Src/motor.c ****       raw_inj1 = (q31_t) HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_1);
 6947              		.loc 2 1407 26
 6948 0078 0121     		movs	r1, #1
 6949 007a 6348     		ldr	r0, .L295+4
 6950 007c FFF7FEFF 		bl	HAL_ADCEx_InjectedGetValue
 6951 0080 0346     		mov	r3, r0
 6952              		.loc 2 1407 18
 6953 0082 1A46     		mov	r2, r3
 6954              		.loc 2 1407 16
 6955 0084 614B     		ldr	r3, .L295+8
 6956 0086 1A60     		str	r2, [r3]
1408:Core/Src/motor.c ****       i16_ph1_current = -i16_ph2_current - raw_inj1;
 6957              		.loc 2 1408 42
 6958 0088 644B     		ldr	r3, .L295+24
 6959 008a B3F90030 		ldrsh	r3, [r3]
 6960 008e 9BB2     		uxth	r3, r3
 6961 0090 5B42     		rsbs	r3, r3, #0
 6962 0092 9AB2     		uxth	r2, r3
 6963 0094 5D4B     		ldr	r3, .L295+8
 6964 0096 1B68     		ldr	r3, [r3]
 6965 0098 9BB2     		uxth	r3, r3
 6966 009a D31A     		subs	r3, r2, r3
 6967 009c 9BB2     		uxth	r3, r3
 6968 009e 1AB2     		sxth	r2, r3
 6969              		.loc 2 1408 23
 6970 00a0 5B4B     		ldr	r3, .L295+12
 6971 00a2 1A80     		strh	r2, [r3]	@ movhi
1409:Core/Src/motor.c ****       break;
 6972              		.loc 2 1409 7
 6973 00a4 23E0     		b	.L278
 6974              	.L279:
1410:Core/Src/motor.c **** 
1411:Core/Src/motor.c ****     case 3: //Phase B at high dutycycles, read from A+C (B=-A-C)
1412:Core/Src/motor.c ****       raw_inj1 = (q31_t) HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_1);
 6975              		.loc 2 1412 26
 6976 00a6 0121     		movs	r1, #1
 6977 00a8 5748     		ldr	r0, .L295+4
 6978 00aa FFF7FEFF 		bl	HAL_ADCEx_InjectedGetValue
 6979 00ae 0346     		mov	r3, r0
 6980              		.loc 2 1412 18
 6981 00b0 1A46     		mov	r2, r3
 6982              		.loc 2 1412 16
 6983 00b2 564B     		ldr	r3, .L295+8
 6984 00b4 1A60     		str	r2, [r3]
1413:Core/Src/motor.c ****       i16_ph1_current = raw_inj1;
 6985              		.loc 2 1413 23
ARM GAS  /tmp/ccpEjOub.s 			page 243


 6986 00b6 554B     		ldr	r3, .L295+8
 6987 00b8 1B68     		ldr	r3, [r3]
 6988 00ba 1AB2     		sxth	r2, r3
 6989 00bc 544B     		ldr	r3, .L295+12
 6990 00be 1A80     		strh	r2, [r3]	@ movhi
1414:Core/Src/motor.c ****       raw_inj2 = (q31_t) HAL_ADCEx_InjectedGetValue(&hadc2, ADC_INJECTED_RANK_1);
 6991              		.loc 2 1414 26
 6992 00c0 0121     		movs	r1, #1
 6993 00c2 5448     		ldr	r0, .L295+16
 6994 00c4 FFF7FEFF 		bl	HAL_ADCEx_InjectedGetValue
 6995 00c8 0346     		mov	r3, r0
 6996              		.loc 2 1414 18
 6997 00ca 1A46     		mov	r2, r3
 6998              		.loc 2 1414 16
 6999 00cc 524B     		ldr	r3, .L295+20
 7000 00ce 1A60     		str	r2, [r3]
1415:Core/Src/motor.c ****       i16_ph2_current = -i16_ph1_current - raw_inj2;
 7001              		.loc 2 1415 42
 7002 00d0 4F4B     		ldr	r3, .L295+12
 7003 00d2 B3F90030 		ldrsh	r3, [r3]
 7004 00d6 9BB2     		uxth	r3, r3
 7005 00d8 5B42     		rsbs	r3, r3, #0
 7006 00da 9AB2     		uxth	r2, r3
 7007 00dc 4E4B     		ldr	r3, .L295+20
 7008 00de 1B68     		ldr	r3, [r3]
 7009 00e0 9BB2     		uxth	r3, r3
 7010 00e2 D31A     		subs	r3, r2, r3
 7011 00e4 9BB2     		uxth	r3, r3
 7012 00e6 1AB2     		sxth	r2, r3
 7013              		.loc 2 1415 23
 7014 00e8 4C4B     		ldr	r3, .L295+24
 7015 00ea 1A80     		strh	r2, [r3]	@ movhi
1416:Core/Src/motor.c ****       break;
 7016              		.loc 2 1416 7
 7017 00ec 00BF     		nop
 7018              	.L278:
 7019              	.LBB21:
 7020              	.LBB22:
 142:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 7021              		.loc 3 142 3
 7022              		.syntax unified
 7023              	@ 142 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 7024 00ee 72B6     		cpsid i
 7025              	@ 0 "" 2
 7026              		.loc 3 143 1
 7027              		.thumb
 7028              		.syntax unified
 7029 00f0 00BF     		nop
 7030              	.LBE22:
 7031              	.LBE21:
1417:Core/Src/motor.c **** 
1418:Core/Src/motor.c ****     case 0: //timeslot too small for ADC
1419:Core/Src/motor.c ****       //do nothing
1420:Core/Src/motor.c ****       break;
1421:Core/Src/motor.c ****   } // end case
1422:Core/Src/motor.c **** 
1423:Core/Src/motor.c ****   __disable_irq(); // ENTER CRITICAL SECTION!!!!!!!!!!!!!
ARM GAS  /tmp/ccpEjOub.s 			page 244


1424:Core/Src/motor.c **** 
1425:Core/Src/motor.c ****   if (MS.hall_angle_detect_flag == false) {
 7032              		.loc 2 1425 9
 7033 00f2 444B     		ldr	r3, .L295
 7034 00f4 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 7035              		.loc 2 1425 33
 7036 00f8 83F00103 		eor	r3, r3, #1
 7037 00fc DBB2     		uxtb	r3, r3
 7038              		.loc 2 1425 6
 7039 00fe 002B     		cmp	r3, #0
 7040 0100 00F0B680 		beq	.L284
 7041              	.LBB23:
1426:Core/Src/motor.c ****     
1427:Core/Src/motor.c ****     // extrapolate recent rotor position
1428:Core/Src/motor.c ****     uint16_t ui16_tim2_ticks = __HAL_TIM_GET_COUNTER(&htim2); // read in timertics since last event
 7042              		.loc 2 1428 32
 7043 0104 464B     		ldr	r3, .L295+28
 7044 0106 1B68     		ldr	r3, [r3]
 7045 0108 5B6A     		ldr	r3, [r3, #36]
 7046              		.loc 2 1428 14
 7047 010a FB81     		strh	r3, [r7, #14]	@ movhi
1429:Core/Src/motor.c **** 
1430:Core/Src/motor.c ****     if (ui16_halls_tim2tics < SIXSTEPTHRESHOLD && ui16_tim2_ticks < 200) {
 7048              		.loc 2 1430 29
 7049 010c 454B     		ldr	r3, .L295+32
 7050 010e 1B88     		ldrh	r3, [r3]
 7051              		.loc 2 1430 8
 7052 0110 44F24F62 		movw	r2, #17999
 7053 0114 9342     		cmp	r3, r2
 7054 0116 05D8     		bhi	.L285
 7055              		.loc 2 1430 48 discriminator 1
 7056 0118 FB89     		ldrh	r3, [r7, #14]
 7057 011a C72B     		cmp	r3, #199
 7058 011c 02D8     		bhi	.L285
1431:Core/Src/motor.c ****       ui8_6step_flag = false; 
 7059              		.loc 2 1431 22
 7060 011e 424B     		ldr	r3, .L295+36
 7061 0120 0022     		movs	r2, #0
 7062 0122 1A70     		strb	r2, [r3]
 7063              	.L285:
1432:Core/Src/motor.c ****     }
1433:Core/Src/motor.c ****     
1434:Core/Src/motor.c ****     if (ui16_halls_tim2tics > (SIXSTEPTHRESHOLD * 6) >> 2) { 
 7064              		.loc 2 1434 29
 7065 0124 3F4B     		ldr	r3, .L295+32
 7066 0126 1B88     		ldrh	r3, [r3]
 7067              		.loc 2 1434 8
 7068 0128 46F67812 		movw	r2, #27000
 7069 012c 9342     		cmp	r3, r2
 7070 012e 02D9     		bls	.L286
1435:Core/Src/motor.c ****       ui8_6step_flag = true;
 7071              		.loc 2 1435 22
 7072 0130 3D4B     		ldr	r3, .L295+36
 7073 0132 0122     		movs	r2, #1
 7074 0134 1A70     		strb	r2, [r3]
 7075              	.L286:
1436:Core/Src/motor.c ****     }
ARM GAS  /tmp/ccpEjOub.s 			page 245


1437:Core/Src/motor.c **** 
1438:Core/Src/motor.c ****     // DEBUG
1439:Core/Src/motor.c ****     p_MotorStatePublic->debug[2] = ui8_6step_flag;
 7076              		.loc 2 1439 34
 7077 0136 3C4B     		ldr	r3, .L295+36
 7078 0138 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 7079              		.loc 2 1439 23
 7080 013a 3C4B     		ldr	r3, .L295+40
 7081 013c 1B68     		ldr	r3, [r3]
 7082              		.loc 2 1439 34
 7083 013e 5A63     		str	r2, [r3, #52]
1440:Core/Src/motor.c **** 
1441:Core/Src/motor.c ****     if (MS.angle_estimation == SPEED_PLL) {
 7084              		.loc 2 1441 11
 7085 0140 304B     		ldr	r3, .L295
 7086 0142 93F83330 		ldrb	r3, [r3, #51]	@ zero_extendqisi2
 7087              		.loc 2 1441 8
 7088 0146 012B     		cmp	r3, #1
 7089 0148 06D1     		bne	.L287
1442:Core/Src/motor.c ****       q31_rotorposition_PLL += q31_angle_per_tic;
 7090              		.loc 2 1442 29
 7091 014a 394B     		ldr	r3, .L295+44
 7092 014c 1A68     		ldr	r2, [r3]
 7093 014e 394B     		ldr	r3, .L295+48
 7094 0150 1B68     		ldr	r3, [r3]
 7095 0152 1344     		add	r3, r3, r2
 7096 0154 364A     		ldr	r2, .L295+44
 7097 0156 1360     		str	r3, [r2]
 7098              	.L287:
1443:Core/Src/motor.c ****     }
1444:Core/Src/motor.c **** 
1445:Core/Src/motor.c ****     if (ui16_tim2_ticks < (ui16_halls_tim2tics + (ui16_halls_tim2tics >> 2)) // if ui16_tim2_ticks 
 7099              		.loc 2 1445 25
 7100 0158 FA89     		ldrh	r2, [r7, #14]
 7101              		.loc 2 1445 48
 7102 015a 324B     		ldr	r3, .L295+32
 7103 015c 1B88     		ldrh	r3, [r3]
 7104 015e 1946     		mov	r1, r3
 7105              		.loc 2 1445 71
 7106 0160 304B     		ldr	r3, .L295+32
 7107 0162 1B88     		ldrh	r3, [r3]
 7108 0164 9B08     		lsrs	r3, r3, #2
 7109 0166 9BB2     		uxth	r3, r3
 7110              		.loc 2 1445 48
 7111 0168 0B44     		add	r3, r3, r1
 7112              		.loc 2 1445 8
 7113 016a 9A42     		cmp	r2, r3
 7114 016c 3DDA     		bge	.L288
1446:Core/Src/motor.c ****         && ui8_overflow_flag == false
 7115              		.loc 2 1446 30
 7116 016e 324B     		ldr	r3, .L295+52
 7117 0170 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 7118 0172 83F00103 		eor	r3, r3, #1
 7119 0176 DBB2     		uxtb	r3, r3
 7120              		.loc 2 1446 9
 7121 0178 002B     		cmp	r3, #0
 7122 017a 36D0     		beq	.L288
ARM GAS  /tmp/ccpEjOub.s 			page 246


1447:Core/Src/motor.c ****         && ui8_6step_flag == false) { // prevent angle running away at standstill
 7123              		.loc 2 1447 27
 7124 017c 2A4B     		ldr	r3, .L295+36
 7125 017e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 7126 0180 83F00103 		eor	r3, r3, #1
 7127 0184 DBB2     		uxtb	r3, r3
 7128              		.loc 2 1447 9
 7129 0186 002B     		cmp	r3, #0
 7130 0188 2FD0     		beq	.L288
1448:Core/Src/motor.c ****       if ((MS.angle_estimation == SPEED_PLL) &&
 7131              		.loc 2 1448 14
 7132 018a 1E4B     		ldr	r3, .L295
 7133 018c 93F83330 		ldrb	r3, [r3, #51]	@ zero_extendqisi2
 7134              		.loc 2 1448 10
 7135 0190 012B     		cmp	r3, #1
 7136 0192 10D1     		bne	.L289
1449:Core/Src/motor.c ****           abs(q31_PLL_error) < deg_30) {
 7137              		.loc 2 1449 11 discriminator 1
 7138 0194 294B     		ldr	r3, .L295+56
 7139 0196 1B68     		ldr	r3, [r3]
 7140 0198 002B     		cmp	r3, #0
 7141 019a B8BF     		it	lt
 7142 019c 5B42     		rsblt	r3, r3, #0
 7143              		.loc 2 1449 30 discriminator 1
 7144 019e 284A     		ldr	r2, .L295+60
1448:Core/Src/motor.c ****       if ((MS.angle_estimation == SPEED_PLL) &&
 7145              		.loc 2 1448 46 discriminator 1
 7146 01a0 9342     		cmp	r3, r2
 7147 01a2 08DA     		bge	.L289
1450:Core/Src/motor.c ****         q31_rotorposition_absolute = q31_rotorposition_PLL;
 7148              		.loc 2 1450 36
 7149 01a4 224B     		ldr	r3, .L295+44
 7150 01a6 1B68     		ldr	r3, [r3]
 7151 01a8 264A     		ldr	r2, .L295+64
 7152 01aa 1360     		str	r3, [r2]
1451:Core/Src/motor.c ****         MS.system_state = PLL;
 7153              		.loc 2 1451 25
 7154 01ac 154B     		ldr	r3, .L295
 7155 01ae 0322     		movs	r2, #3
 7156 01b0 83F82D20 		strb	r2, [r3, #45]
1448:Core/Src/motor.c ****           abs(q31_PLL_error) < deg_30) {
 7157              		.loc 2 1448 10
 7158 01b4 5CE0     		b	.L284
 7159              	.L289:
1452:Core/Src/motor.c ****       } else {
1453:Core/Src/motor.c ****         q31_rotorposition_absolute = q31_rotorposition_hall +
1454:Core/Src/motor.c ****           (q31_t) (i8_recent_rotor_direction * ((10923 * ui16_tim2_ticks) / ui16_halls_tim2tics)
 7160              		.loc 2 1454 46
 7161 01b6 244B     		ldr	r3, .L295+68
 7162 01b8 93F90030 		ldrsb	r3, [r3]
 7163 01bc 1946     		mov	r1, r3
 7164              		.loc 2 1454 56
 7165 01be FB89     		ldrh	r3, [r7, #14]
 7166 01c0 42F6AB22 		movw	r2, #10923
 7167 01c4 02FB03F3 		mul	r3, r2, r3
 7168              		.loc 2 1454 75
 7169 01c8 164A     		ldr	r2, .L295+32
ARM GAS  /tmp/ccpEjOub.s 			page 247


 7170 01ca 1288     		ldrh	r2, [r2]
 7171 01cc 93FBF2F3 		sdiv	r3, r3, r2
 7172              		.loc 2 1454 46
 7173 01d0 03FB01F3 		mul	r3, r3, r1
1455:Core/Src/motor.c ****           << 16); //interpolate angle between two hallevents by scaling timer2 tics, 10923<<16 is 7
 7174              		.loc 2 1455 11
 7175 01d4 1A04     		lsls	r2, r3, #16
1453:Core/Src/motor.c ****           (q31_t) (i8_recent_rotor_direction * ((10923 * ui16_tim2_ticks) / ui16_halls_tim2tics)
 7176              		.loc 2 1453 61
 7177 01d6 1D4B     		ldr	r3, .L295+72
 7178 01d8 1B68     		ldr	r3, [r3]
 7179 01da 1344     		add	r3, r3, r2
1453:Core/Src/motor.c ****           (q31_t) (i8_recent_rotor_direction * ((10923 * ui16_tim2_ticks) / ui16_halls_tim2tics)
 7180              		.loc 2 1453 36
 7181 01dc 194A     		ldr	r2, .L295+64
 7182 01de 1360     		str	r3, [r2]
1456:Core/Src/motor.c ****         
1457:Core/Src/motor.c ****         MS.system_state = Interpolation;
 7183              		.loc 2 1457 25
 7184 01e0 084B     		ldr	r3, .L295
 7185 01e2 0222     		movs	r2, #2
 7186 01e4 83F82D20 		strb	r2, [r3, #45]
1448:Core/Src/motor.c ****           abs(q31_PLL_error) < deg_30) {
 7187              		.loc 2 1448 10
 7188 01e8 42E0     		b	.L284
 7189              	.L288:
1458:Core/Src/motor.c ****       }
1459:Core/Src/motor.c ****     } else {
1460:Core/Src/motor.c ****       ui8_overflow_flag = true;
 7190              		.loc 2 1460 25
 7191 01ea 134B     		ldr	r3, .L295+52
 7192 01ec 0122     		movs	r2, #1
 7193 01ee 1A70     		strb	r2, [r3]
1461:Core/Src/motor.c **** 
1462:Core/Src/motor.c ****       if (MS.KV_detect_flag) {
 7194              		.loc 2 1462 13
 7195 01f0 044B     		ldr	r3, .L295
 7196 01f2 B3F93430 		ldrsh	r3, [r3, #52]
 7197              		.loc 2 1462 10
 7198 01f6 002B     		cmp	r3, #0
 7199 01f8 2AD0     		beq	.L291
1463:Core/Src/motor.c ****         q31_rotorposition_absolute = q31_rotorposition_hall;
 7200              		.loc 2 1463 36
 7201 01fa 144B     		ldr	r3, .L295+72
 7202 01fc 1B68     		ldr	r3, [r3]
 7203 01fe 114A     		ldr	r2, .L295+64
 7204 0200 1360     		str	r3, [r2]
 7205 0202 31E0     		b	.L292
 7206              	.L296:
 7207              		.align	2
 7208              	.L295:
 7209 0204 00000000 		.word	MS
 7210 0208 00000000 		.word	hadc1
 7211 020c 00000000 		.word	raw_inj1
 7212 0210 00000000 		.word	i16_ph1_current
 7213 0214 00000000 		.word	hadc2
 7214 0218 00000000 		.word	raw_inj2
ARM GAS  /tmp/ccpEjOub.s 			page 248


 7215 021c 00000000 		.word	i16_ph2_current
 7216 0220 00000000 		.word	htim2
 7217 0224 00000000 		.word	ui16_halls_tim2tics
 7218 0228 00000000 		.word	ui8_6step_flag
 7219 022c 00000000 		.word	p_MotorStatePublic
 7220 0230 00000000 		.word	q31_rotorposition_PLL
 7221 0234 00000000 		.word	q31_angle_per_tic
 7222 0238 00000000 		.word	ui8_overflow_flag
 7223 023c 00000000 		.word	q31_PLL_error
 7224 0240 55555515 		.word	357913941
 7225 0244 00000000 		.word	q31_rotorposition_absolute
 7226 0248 00000000 		.word	i8_recent_rotor_direction
 7227 024c 00000000 		.word	q31_rotorposition_hall
 7228              	.L291:
1464:Core/Src/motor.c ****       } else {
1465:Core/Src/motor.c ****         q31_rotorposition_absolute = q31_rotorposition_hall + i8_direction * deg_30; // offset of 3
 7229              		.loc 2 1465 76
 7230 0250 254B     		ldr	r3, .L297
 7231 0252 93F90030 		ldrsb	r3, [r3]
 7232 0256 1A46     		mov	r2, r3
 7233 0258 244B     		ldr	r3, .L297+4
 7234 025a 03FB02F2 		mul	r2, r3, r2
 7235              		.loc 2 1465 61
 7236 025e 244B     		ldr	r3, .L297+8
 7237 0260 1B68     		ldr	r3, [r3]
 7238 0262 1344     		add	r3, r3, r2
 7239              		.loc 2 1465 36
 7240 0264 234A     		ldr	r2, .L297+12
 7241 0266 1360     		str	r3, [r2]
 7242              	.L292:
1466:Core/Src/motor.c ****       }
1467:Core/Src/motor.c **** 
1468:Core/Src/motor.c ****       MS.system_state = SixStep;
 7243              		.loc 2 1468 23
 7244 0268 234B     		ldr	r3, .L297+16
 7245 026a 0122     		movs	r2, #1
 7246 026c 83F82D20 		strb	r2, [r3, #45]
 7247              	.L284:
 7248              	.LBE23:
 7249              	.LBB24:
 7250              	.LBB25:
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 7251              		.loc 3 131 3
 7252              		.syntax unified
 7253              	@ 131 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 7254 0270 62B6     		cpsie i
 7255              	@ 0 "" 2
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 7256              		.loc 3 132 1
 7257              		.thumb
 7258              		.syntax unified
 7259 0272 00BF     		nop
 7260              	.LBE25:
 7261              	.LBE24:
1469:Core/Src/motor.c ****     }
1470:Core/Src/motor.c ****   }
1471:Core/Src/motor.c **** 
ARM GAS  /tmp/ccpEjOub.s 			page 249


1472:Core/Src/motor.c ****   __enable_irq(); //EXIT CRITICAL SECTION!!!!!!!!!!!!!!
1473:Core/Src/motor.c **** 
1474:Core/Src/motor.c ****   //get the Phase with highest duty cycle for dynamic phase current reading
1475:Core/Src/motor.c ****   dyn_adc_state(q31_rotorposition_absolute);
 7262              		.loc 2 1475 3
 7263 0274 1F4B     		ldr	r3, .L297+12
 7264 0276 1B68     		ldr	r3, [r3]
 7265 0278 1846     		mov	r0, r3
 7266 027a FFF7FEFF 		bl	dyn_adc_state
1476:Core/Src/motor.c **** 
1477:Core/Src/motor.c ****   //set the according injected channels to read current at Low-Side active time
1478:Core/Src/motor.c ****   if (MS.char_dyn_adc_state != char_dyn_adc_state_old) {
 7267              		.loc 2 1478 9
 7268 027e 1E4B     		ldr	r3, .L297+16
 7269 0280 93F82C20 		ldrb	r2, [r3, #44]	@ zero_extendqisi2
 7270              		.loc 2 1478 29
 7271 0284 1D4B     		ldr	r3, .L297+20
 7272 0286 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 7273              		.loc 2 1478 6
 7274 0288 9A42     		cmp	r2, r3
 7275 028a 0AD0     		beq	.L293
1479:Core/Src/motor.c ****     set_inj_channel(MS.char_dyn_adc_state);
 7276              		.loc 2 1479 23
 7277 028c 1A4B     		ldr	r3, .L297+16
 7278 028e 93F82C30 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 7279              		.loc 2 1479 5
 7280 0292 1846     		mov	r0, r3
 7281 0294 FFF7FEFF 		bl	set_inj_channel
1480:Core/Src/motor.c ****     char_dyn_adc_state_old = MS.char_dyn_adc_state;
 7282              		.loc 2 1480 32
 7283 0298 174B     		ldr	r3, .L297+16
 7284 029a 93F82C20 		ldrb	r2, [r3, #44]	@ zero_extendqisi2
 7285              		.loc 2 1480 28
 7286 029e 174B     		ldr	r3, .L297+20
 7287 02a0 1A70     		strb	r2, [r3]
 7288              	.L293:
1481:Core/Src/motor.c ****   }
1482:Core/Src/motor.c **** 
1483:Core/Src/motor.c ****   // call FOC procedure if PWM is enabled
1484:Core/Src/motor.c ****   if (pwm_is_enabled()) {
 7289              		.loc 2 1484 7
 7290 02a2 FFF7FEFF 		bl	pwm_is_enabled
 7291 02a6 0346     		mov	r3, r0
 7292              		.loc 2 1484 6
 7293 02a8 002B     		cmp	r3, #0
 7294 02aa 0AD0     		beq	.L294
1485:Core/Src/motor.c ****     FOC_calculation(i16_ph1_current, i16_ph2_current, q31_rotorposition_absolute, &MS);
 7295              		.loc 2 1485 5
 7296 02ac 144B     		ldr	r3, .L297+24
 7297 02ae B3F90000 		ldrsh	r0, [r3]
 7298 02b2 144B     		ldr	r3, .L297+28
 7299 02b4 B3F90010 		ldrsh	r1, [r3]
 7300 02b8 0E4B     		ldr	r3, .L297+12
 7301 02ba 1A68     		ldr	r2, [r3]
 7302 02bc 0E4B     		ldr	r3, .L297+16
 7303 02be FFF7FEFF 		bl	FOC_calculation
 7304              	.L294:
ARM GAS  /tmp/ccpEjOub.s 			page 250


1486:Core/Src/motor.c ****   }
1487:Core/Src/motor.c **** 
1488:Core/Src/motor.c ****   // apply PWM values that are calculated inside FOC_calculation()
1489:Core/Src/motor.c ****   TIM1->CCR1 = (uint16_t) switchtime[0];
 7305              		.loc 2 1489 37
 7306 02c2 114B     		ldr	r3, .L297+32
 7307 02c4 1B68     		ldr	r3, [r3]
 7308              		.loc 2 1489 16
 7309 02c6 9AB2     		uxth	r2, r3
 7310              		.loc 2 1489 7
 7311 02c8 104B     		ldr	r3, .L297+36
 7312              		.loc 2 1489 14
 7313 02ca 5A63     		str	r2, [r3, #52]
1490:Core/Src/motor.c ****   TIM1->CCR2 = (uint16_t) switchtime[1];
 7314              		.loc 2 1490 37
 7315 02cc 0E4B     		ldr	r3, .L297+32
 7316 02ce 5B68     		ldr	r3, [r3, #4]
 7317              		.loc 2 1490 16
 7318 02d0 9AB2     		uxth	r2, r3
 7319              		.loc 2 1490 7
 7320 02d2 0E4B     		ldr	r3, .L297+36
 7321              		.loc 2 1490 14
 7322 02d4 9A63     		str	r2, [r3, #56]
1491:Core/Src/motor.c ****   TIM1->CCR3 = (uint16_t) switchtime[2];
 7323              		.loc 2 1491 37
 7324 02d6 0C4B     		ldr	r3, .L297+32
 7325 02d8 9B68     		ldr	r3, [r3, #8]
 7326              		.loc 2 1491 16
 7327 02da 9AB2     		uxth	r2, r3
 7328              		.loc 2 1491 7
 7329 02dc 0B4B     		ldr	r3, .L297+36
 7330              		.loc 2 1491 14
 7331 02de DA63     		str	r2, [r3, #60]
1492:Core/Src/motor.c **** }
 7332              		.loc 2 1492 1
 7333 02e0 00BF     		nop
 7334 02e2 1037     		adds	r7, r7, #16
 7335              	.LCFI190:
 7336              		.cfi_def_cfa_offset 8
 7337 02e4 BD46     		mov	sp, r7
 7338              	.LCFI191:
 7339              		.cfi_def_cfa_register 13
 7340              		@ sp needed
 7341 02e6 80BD     		pop	{r7, pc}
 7342              	.L298:
 7343              		.align	2
 7344              	.L297:
 7345 02e8 00000000 		.word	i8_direction
 7346 02ec 55555515 		.word	357913941
 7347 02f0 00000000 		.word	q31_rotorposition_hall
 7348 02f4 00000000 		.word	q31_rotorposition_absolute
 7349 02f8 00000000 		.word	MS
 7350 02fc 00000000 		.word	char_dyn_adc_state_old
 7351 0300 00000000 		.word	i16_ph1_current
 7352 0304 00000000 		.word	i16_ph2_current
 7353 0308 00000000 		.word	switchtime
 7354 030c 002C0140 		.word	1073818624
ARM GAS  /tmp/ccpEjOub.s 			page 251


 7355              		.cfi_endproc
 7356              	.LFE151:
 7358              		.section	.bss.q31_d_i.10001,"aw",%nobits
 7359              		.align	2
 7362              	q31_d_i.10001:
 7363 0000 00000000 		.space	4
 7364              		.section	.data.ui16_halls_tim2tics_acc.10010,"aw"
 7365              		.align	2
 7368              	ui16_halls_tim2tics_acc.10010:
 7369 0000 00F40100 		.word	128000
 7370              		.section	.data.dir.10077,"aw"
 7373              	dir.10077:
 7374 0000 01       		.byte	1
 7375              		.section	.bss.KVtemp.10078,"aw",%nobits
 7376              		.align	1
 7379              	KVtemp.10078:
 7380 0000 0000     		.space	2
 7381              		.section	.bss.iq_cum.10079,"aw",%nobits
 7382              		.align	2
 7385              	iq_cum.10079:
 7386 0000 00000000 		.space	4
 7387              		.section	.bss.id_cum.10080,"aw",%nobits
 7388              		.align	2
 7391              	id_cum.10080:
 7392 0000 00000000 		.space	4
 7393              		.section	.bss.uq_cum.10081,"aw",%nobits
 7394              		.align	2
 7397              	uq_cum.10081:
 7398 0000 00000000 		.space	4
 7399              		.section	.bss.ud_cum.10082,"aw",%nobits
 7400              		.align	2
 7403              	ud_cum.10082:
 7404 0000 00000000 		.space	4
 7405              		.text
 7406              	.Letext0:
 7407              		.file 4 "/usr/lib/gcc/arm-none-eabi/9.2.1/include/stddef.h"
 7408              		.file 5 "/usr/include/newlib/sys/_types.h"
 7409              		.file 6 "/usr/include/newlib/sys/reent.h"
 7410              		.file 7 "/usr/include/newlib/sys/lock.h"
 7411              		.file 8 "/usr/include/newlib/stdlib.h"
 7412              		.file 9 "/usr/lib/gcc/arm-none-eabi/9.2.1/include/stdint.h"
 7413              		.file 10 "/usr/include/newlib/math.h"
 7414              		.file 11 "Drivers/CMSIS/Include/core_cm3.h"
 7415              		.file 12 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 7416              		.file 13 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 7417              		.file 14 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
 7418              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 7419              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 7420              		.file 17 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 7421              		.file 18 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_adc.h"
 7422              		.file 19 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_adc_ex.h"
 7423              		.file 20 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_tim.h"
 7424              		.file 21 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 7425              		.file 22 "Core/Inc/motor.h"
ARM GAS  /tmp/ccpEjOub.s 			page 252


DEFINED SYMBOLS
                            *ABS*:0000000000000000 motor.c
     /tmp/ccpEjOub.s:16     .text.clip_q63_to_q31:0000000000000000 $t
     /tmp/ccpEjOub.s:23     .text.clip_q63_to_q31:0000000000000000 clip_q63_to_q31
     /tmp/ccpEjOub.s:89     .text.__QADD:0000000000000000 $t
     /tmp/ccpEjOub.s:95     .text.__QADD:0000000000000000 __QADD
     /tmp/ccpEjOub.s:145    .text.__QSUB:0000000000000000 $t
     /tmp/ccpEjOub.s:151    .text.__QSUB:0000000000000000 __QSUB
     /tmp/ccpEjOub.s:201    .text.arm_clarke_q31:0000000000000000 $t
     /tmp/ccpEjOub.s:207    .text.arm_clarke_q31:0000000000000000 arm_clarke_q31
     /tmp/ccpEjOub.s:299    .text.arm_clarke_q31:0000000000000094 $d
     /tmp/ccpEjOub.s:305    .text.arm_park_q31:0000000000000000 $t
     /tmp/ccpEjOub.s:311    .text.arm_park_q31:0000000000000000 arm_park_q31
     /tmp/ccpEjOub.s:456    .text.arm_inv_park_q31:0000000000000000 $t
     /tmp/ccpEjOub.s:462    .text.arm_inv_park_q31:0000000000000000 arm_inv_park_q31
     /tmp/ccpEjOub.s:611    .data.VirtAddVarTab:0000000000000000 VirtAddVarTab
     /tmp/ccpEjOub.s:608    .data.VirtAddVarTab:0000000000000000 $d
                            *COM*:0000000000000030 hadc1
                            *COM*:0000000000000030 hadc2
                            *COM*:0000000000000044 hdma_adc1
                            *COM*:0000000000000048 htim1
                            *COM*:0000000000000048 htim2
                            *COM*:0000000000000048 htim3
                            *COM*:0000000000000048 htim4
                            *COM*:0000000000000030 adcData1
                            *COM*:0000000000000038 MS
     /tmp/ccpEjOub.s:630    .bss.i16_ph1_current:0000000000000000 i16_ph1_current
     /tmp/ccpEjOub.s:627    .bss.i16_ph1_current:0000000000000000 $d
     /tmp/ccpEjOub.s:637    .bss.i16_ph2_current:0000000000000000 i16_ph2_current
     /tmp/ccpEjOub.s:634    .bss.i16_ph2_current:0000000000000000 $d
     /tmp/ccpEjOub.s:644    .bss.i16_ph2_current_filter:0000000000000000 i16_ph2_current_filter
     /tmp/ccpEjOub.s:641    .bss.i16_ph2_current_filter:0000000000000000 $d
     /tmp/ccpEjOub.s:650    .bss.ui8_adc_inj_flag:0000000000000000 ui8_adc_inj_flag
     /tmp/ccpEjOub.s:651    .bss.ui8_adc_inj_flag:0000000000000000 $d
                            *COM*:0000000000000004 raw_inj1
                            *COM*:0000000000000004 raw_inj2
     /tmp/ccpEjOub.s:658    .bss.ui8_hall_state:0000000000000000 ui8_hall_state
     /tmp/ccpEjOub.s:659    .bss.ui8_hall_state:0000000000000000 $d
     /tmp/ccpEjOub.s:664    .bss.ui8_hall_state_old:0000000000000000 ui8_hall_state_old
     /tmp/ccpEjOub.s:665    .bss.ui8_hall_state_old:0000000000000000 $d
     /tmp/ccpEjOub.s:670    .bss.ui8_hall_case:0000000000000000 ui8_hall_case
     /tmp/ccpEjOub.s:671    .bss.ui8_hall_case:0000000000000000 $d
     /tmp/ccpEjOub.s:676    .bss.ui8_BC_limit_flag:0000000000000000 ui8_BC_limit_flag
     /tmp/ccpEjOub.s:677    .bss.ui8_BC_limit_flag:0000000000000000 $d
                            *COM*:0000000000000002 ui16_halls_tim2tics
     /tmp/ccpEjOub.s:684    .data.ui16_halls_tim2tics_filtered:0000000000000000 ui16_halls_tim2tics_filtered
     /tmp/ccpEjOub.s:681    .data.ui16_halls_tim2tics_filtered:0000000000000000 $d
     /tmp/ccpEjOub.s:690    .bss.ui8_6step_flag:0000000000000000 ui8_6step_flag
     /tmp/ccpEjOub.s:691    .bss.ui8_6step_flag:0000000000000000 $d
                            *COM*:0000000000000004 q31_rotorposition_absolute
                            *COM*:0000000000000004 q31_rotorposition_hall
     /tmp/ccpEjOub.s:699    .data.q31_rotorposition_motor_specific:0000000000000000 q31_rotorposition_motor_specific
     /tmp/ccpEjOub.s:696    .data.q31_rotorposition_motor_specific:0000000000000000 $d
     /tmp/ccpEjOub.s:706    .bss.q31_rotorposition_PLL:0000000000000000 q31_rotorposition_PLL
     /tmp/ccpEjOub.s:703    .bss.q31_rotorposition_PLL:0000000000000000 $d
     /tmp/ccpEjOub.s:713    .bss.q31_angle_per_tic:0000000000000000 q31_angle_per_tic
     /tmp/ccpEjOub.s:710    .bss.q31_angle_per_tic:0000000000000000 $d
ARM GAS  /tmp/ccpEjOub.s 			page 253


     /tmp/ccpEjOub.s:720    .bss.q31_PLL_error:0000000000000000 q31_PLL_error
     /tmp/ccpEjOub.s:717    .bss.q31_PLL_error:0000000000000000 $d
     /tmp/ccpEjOub.s:726    .data.i8_recent_rotor_direction:0000000000000000 i8_recent_rotor_direction
     /tmp/ccpEjOub.s:733    .data.i16_hall_order:0000000000000000 i16_hall_order
     /tmp/ccpEjOub.s:730    .data.i16_hall_order:0000000000000000 $d
     /tmp/ccpEjOub.s:740    .bss.Hall_13:0000000000000000 Hall_13
     /tmp/ccpEjOub.s:737    .bss.Hall_13:0000000000000000 $d
     /tmp/ccpEjOub.s:747    .bss.Hall_32:0000000000000000 Hall_32
     /tmp/ccpEjOub.s:744    .bss.Hall_32:0000000000000000 $d
     /tmp/ccpEjOub.s:754    .bss.Hall_26:0000000000000000 Hall_26
     /tmp/ccpEjOub.s:751    .bss.Hall_26:0000000000000000 $d
     /tmp/ccpEjOub.s:761    .bss.Hall_64:0000000000000000 Hall_64
     /tmp/ccpEjOub.s:758    .bss.Hall_64:0000000000000000 $d
     /tmp/ccpEjOub.s:768    .bss.Hall_51:0000000000000000 Hall_51
     /tmp/ccpEjOub.s:765    .bss.Hall_51:0000000000000000 $d
     /tmp/ccpEjOub.s:775    .bss.Hall_45:0000000000000000 Hall_45
     /tmp/ccpEjOub.s:772    .bss.Hall_45:0000000000000000 $d
     /tmp/ccpEjOub.s:782    .rodata.deg_30:0000000000000000 deg_30
     /tmp/ccpEjOub.s:779    .rodata.deg_30:0000000000000000 $d
                            *COM*:000000000000000c switchtime
     /tmp/ccpEjOub.s:789    .bss.ui8_overflow_flag:0000000000000000 ui8_overflow_flag
     /tmp/ccpEjOub.s:790    .bss.ui8_overflow_flag:0000000000000000 $d
     /tmp/ccpEjOub.s:795    .data.char_dyn_adc_state_old:0000000000000000 char_dyn_adc_state_old
     /tmp/ccpEjOub.s:802    .data.q31_tics_filtered:0000000000000000 q31_tics_filtered
     /tmp/ccpEjOub.s:799    .data.q31_tics_filtered:0000000000000000 $d
     /tmp/ccpEjOub.s:809    .bss.q31_t_Battery_Current_accumulated:0000000000000000 q31_t_Battery_Current_accumulated
     /tmp/ccpEjOub.s:806    .bss.q31_t_Battery_Current_accumulated:0000000000000000 $d
     /tmp/ccpEjOub.s:815    .data.i8_direction:0000000000000000 i8_direction
     /tmp/ccpEjOub.s:821    .data.i8_reverse_flag:0000000000000000 i8_reverse_flag
     /tmp/ccpEjOub.s:828    .bss.q31_u_d_temp:0000000000000000 q31_u_d_temp
     /tmp/ccpEjOub.s:825    .bss.q31_u_d_temp:0000000000000000 $d
     /tmp/ccpEjOub.s:835    .bss.q31_u_q_temp:0000000000000000 q31_u_q_temp
     /tmp/ccpEjOub.s:832    .bss.q31_u_q_temp:0000000000000000 $d
     /tmp/ccpEjOub.s:842    .bss.i16_sinus:0000000000000000 i16_sinus
     /tmp/ccpEjOub.s:839    .bss.i16_sinus:0000000000000000 $d
     /tmp/ccpEjOub.s:849    .bss.i16_cosinus:0000000000000000 i16_cosinus
     /tmp/ccpEjOub.s:846    .bss.i16_cosinus:0000000000000000 $d
     /tmp/ccpEjOub.s:856    .bss.uint16_half_rotation_counter:0000000000000000 uint16_half_rotation_counter
     /tmp/ccpEjOub.s:853    .bss.uint16_half_rotation_counter:0000000000000000 $d
     /tmp/ccpEjOub.s:863    .bss.uint16_full_rotation_counter:0000000000000000 uint16_full_rotation_counter
     /tmp/ccpEjOub.s:860    .bss.uint16_full_rotation_counter:0000000000000000 $d
     /tmp/ccpEjOub.s:866    .bss.tics_lower_limit:0000000000000000 $d
     /tmp/ccpEjOub.s:869    .bss.tics_lower_limit:0000000000000000 tics_lower_limit
     /tmp/ccpEjOub.s:872    .bss.tics_higher_limit:0000000000000000 $d
     /tmp/ccpEjOub.s:875    .bss.tics_higher_limit:0000000000000000 tics_higher_limit
     /tmp/ccpEjOub.s:882    .rodata.DEG_0:0000000000000000 DEG_0
     /tmp/ccpEjOub.s:879    .rodata.DEG_0:0000000000000000 $d
     /tmp/ccpEjOub.s:889    .rodata.DEG_plus60:0000000000000000 DEG_plus60
     /tmp/ccpEjOub.s:886    .rodata.DEG_plus60:0000000000000000 $d
     /tmp/ccpEjOub.s:896    .rodata.DEG_plus120:0000000000000000 DEG_plus120
     /tmp/ccpEjOub.s:893    .rodata.DEG_plus120:0000000000000000 $d
     /tmp/ccpEjOub.s:903    .rodata.DEG_plus180:0000000000000000 DEG_plus180
     /tmp/ccpEjOub.s:900    .rodata.DEG_plus180:0000000000000000 $d
     /tmp/ccpEjOub.s:910    .rodata.DEG_minus60:0000000000000000 DEG_minus60
     /tmp/ccpEjOub.s:907    .rodata.DEG_minus60:0000000000000000 $d
     /tmp/ccpEjOub.s:917    .rodata.DEG_minus120:0000000000000000 DEG_minus120
     /tmp/ccpEjOub.s:914    .rodata.DEG_minus120:0000000000000000 $d
ARM GAS  /tmp/ccpEjOub.s 			page 254


                            *COM*:0000000000000002 ui16_reg_adc_value
                            *COM*:0000000000000004 ui32_reg_adc_value_filter
     /tmp/ccpEjOub.s:925    .bss.ui8_adc_regular_flag:0000000000000000 ui8_adc_regular_flag
     /tmp/ccpEjOub.s:926    .bss.ui8_adc_regular_flag:0000000000000000 $d
     /tmp/ccpEjOub.s:932    .bss.ui16_ph1_offset:0000000000000000 ui16_ph1_offset
     /tmp/ccpEjOub.s:929    .bss.ui16_ph1_offset:0000000000000000 $d
     /tmp/ccpEjOub.s:939    .bss.ui16_ph2_offset:0000000000000000 ui16_ph2_offset
     /tmp/ccpEjOub.s:936    .bss.ui16_ph2_offset:0000000000000000 $d
     /tmp/ccpEjOub.s:946    .bss.ui16_ph3_offset:0000000000000000 ui16_ph3_offset
     /tmp/ccpEjOub.s:943    .bss.ui16_ph3_offset:0000000000000000 $d
     /tmp/ccpEjOub.s:953    .bss.ui16_KV_detect_counter:0000000000000000 ui16_KV_detect_counter
     /tmp/ccpEjOub.s:950    .bss.ui16_KV_detect_counter:0000000000000000 $d
     /tmp/ccpEjOub.s:956    .bss.ui32_KV:0000000000000000 $d
     /tmp/ccpEjOub.s:959    .bss.ui32_KV:0000000000000000 ui32_KV
     /tmp/ccpEjOub.s:966    .bss.uint32_SPEEDx100_cumulated:0000000000000000 uint32_SPEEDx100_cumulated
     /tmp/ccpEjOub.s:963    .bss.uint32_SPEEDx100_cumulated:0000000000000000 $d
                            *COM*:0000000000000020 PI_iq
                            *COM*:0000000000000020 PI_id
                            *COM*:0000000000000004 iq_filtered
                            *COM*:0000000000000004 id_filtered
                            *COM*:0000000000000004 uq_filtered
                            *COM*:0000000000000004 ud_filtered
     /tmp/ccpEjOub.s:979    .bss.q31_i_q_fil:0000000000000000 q31_i_q_fil
     /tmp/ccpEjOub.s:976    .bss.q31_i_q_fil:0000000000000000 $d
     /tmp/ccpEjOub.s:986    .bss.q31_i_d_fil:0000000000000000 q31_i_d_fil
     /tmp/ccpEjOub.s:983    .bss.q31_i_d_fil:0000000000000000 $d
                            *COM*:0000000000000004 p_MotorStatePublic
     /tmp/ccpEjOub.s:990    .text._motor_error_handler:0000000000000000 $t
     /tmp/ccpEjOub.s:997    .text._motor_error_handler:0000000000000000 _motor_error_handler
     /tmp/ccpEjOub.s:1097   .text.motor_disable_pwm:0000000000000000 motor_disable_pwm
     /tmp/ccpEjOub.s:1039   .text.HAL_ADC_ConvCpltCallback:0000000000000000 $t
     /tmp/ccpEjOub.s:1046   .text.HAL_ADC_ConvCpltCallback:0000000000000000 HAL_ADC_ConvCpltCallback
     /tmp/ccpEjOub.s:1085   .text.HAL_ADC_ConvCpltCallback:0000000000000018 $d
     /tmp/ccpEjOub.s:1090   .text.motor_disable_pwm:0000000000000000 $t
     /tmp/ccpEjOub.s:1131   .text.motor_disable_pwm:0000000000000018 $d
     /tmp/ccpEjOub.s:1136   .text.disable_pwm:0000000000000000 $t
     /tmp/ccpEjOub.s:1142   .text.disable_pwm:0000000000000000 disable_pwm
     /tmp/ccpEjOub.s:1176   .text.disable_pwm:0000000000000018 $d
     /tmp/ccpEjOub.s:1181   .text.enable_pwm:0000000000000000 $t
     /tmp/ccpEjOub.s:1187   .text.enable_pwm:0000000000000000 enable_pwm
     /tmp/ccpEjOub.s:1221   .text.enable_pwm:0000000000000018 $d
     /tmp/ccpEjOub.s:1226   .text.pwm_is_enabled:0000000000000000 $t
     /tmp/ccpEjOub.s:1232   .text.pwm_is_enabled:0000000000000000 pwm_is_enabled
     /tmp/ccpEjOub.s:1269   .text.pwm_is_enabled:0000000000000020 $d
     /tmp/ccpEjOub.s:1274   .text.speed_PLL:0000000000000000 $t
     /tmp/ccpEjOub.s:1281   .text.speed_PLL:0000000000000000 speed_PLL
     /tmp/ccpEjOub.s:1422   .text.speed_PLL:00000000000000b8 $d
     /tmp/ccpEjOub.s:7362   .bss.q31_d_i.10001:0000000000000000 q31_d_i.10001
     /tmp/ccpEjOub.s:1429   .text.HAL_GPIO_EXTI_Callback:0000000000000000 $t
     /tmp/ccpEjOub.s:1436   .text.HAL_GPIO_EXTI_Callback:0000000000000000 HAL_GPIO_EXTI_Callback
     /tmp/ccpEjOub.s:1595   .text.HAL_GPIO_EXTI_Callback:00000000000000e4 $d
     /tmp/ccpEjOub.s:1647   .text.HAL_GPIO_EXTI_Callback:00000000000001b4 $t
     /tmp/ccpEjOub.s:1821   .text.HAL_GPIO_EXTI_Callback:00000000000002c8 $d
     /tmp/ccpEjOub.s:7368   .data.ui16_halls_tim2tics_acc.10010:0000000000000000 ui16_halls_tim2tics_acc.10010
     /tmp/ccpEjOub.s:1844   .text.HAL_GPIO_EXTI_Callback:000000000000031c $t
     /tmp/ccpEjOub.s:1920   .text.HAL_GPIO_EXTI_Callback:0000000000000388 $d
     /tmp/ccpEjOub.s:1934   .text.get_standstill_position:0000000000000000 $t
ARM GAS  /tmp/ccpEjOub.s 			page 255


     /tmp/ccpEjOub.s:1941   .text.get_standstill_position:0000000000000000 get_standstill_position
     /tmp/ccpEjOub.s:1968   .text.get_standstill_position:000000000000001c $d
     /tmp/ccpEjOub.s:1974   .text.get_standstill_position:0000000000000034 $t
     /tmp/ccpEjOub.s:2035   .text.get_standstill_position:000000000000007c $d
     /tmp/ccpEjOub.s:2048   .text.speed_to_tics:0000000000000000 $t
     /tmp/ccpEjOub.s:2055   .text.speed_to_tics:0000000000000000 speed_to_tics
     /tmp/ccpEjOub.s:2098   .text.speed_to_tics:0000000000000024 $d
     /tmp/ccpEjOub.s:2103   .text.tics_to_speed:0000000000000000 $t
     /tmp/ccpEjOub.s:2110   .text.tics_to_speed:0000000000000000 tics_to_speed
     /tmp/ccpEjOub.s:2153   .text.tics_to_speed:0000000000000024 $d
     /tmp/ccpEjOub.s:2158   .text.motor_autodetect:0000000000000000 $t
     /tmp/ccpEjOub.s:2165   .text.motor_autodetect:0000000000000000 motor_autodetect
     /tmp/ccpEjOub.s:2242   .text.motor_autodetect:0000000000000070 $d
     /tmp/ccpEjOub.s:2294   .text.motor_autodetect:0000000000000140 $t
     /tmp/ccpEjOub.s:2560   .text.motor_autodetect:00000000000002c8 $d
     /tmp/ccpEjOub.s:2581   .text.internal_tics_to_speedx100:0000000000000000 $t
     /tmp/ccpEjOub.s:2588   .text.internal_tics_to_speedx100:0000000000000000 internal_tics_to_speedx100
     /tmp/ccpEjOub.s:2631   .text.internal_tics_to_speedx100:0000000000000024 $d
     /tmp/ccpEjOub.s:2636   .text.calculate_tic_limits:0000000000000000 $t
     /tmp/ccpEjOub.s:2643   .text.calculate_tic_limits:0000000000000000 calculate_tic_limits
     /tmp/ccpEjOub.s:2701   .text.calculate_tic_limits:0000000000000044 $d
     /tmp/ccpEjOub.s:2708   .text.get_battery_current:0000000000000000 $t
     /tmp/ccpEjOub.s:2715   .text.get_battery_current:0000000000000000 get_battery_current
     /tmp/ccpEjOub.s:2785   .text.motor_slow_loop:0000000000000000 $t
     /tmp/ccpEjOub.s:2792   .text.motor_slow_loop:0000000000000000 motor_slow_loop
     /tmp/ccpEjOub.s:3088   .text.motor_slow_loop:00000000000001d0 $d
     /tmp/ccpEjOub.s:3099   .text.motor_slow_loop:00000000000001f4 $t
     /tmp/ccpEjOub.s:3458   .text.motor_slow_loop:0000000000000434 $d
     /tmp/ccpEjOub.s:7373   .data.dir.10077:0000000000000000 dir.10077
     /tmp/ccpEjOub.s:7379   .bss.KVtemp.10078:0000000000000000 KVtemp.10078
     /tmp/ccpEjOub.s:7385   .bss.iq_cum.10079:0000000000000000 iq_cum.10079
     /tmp/ccpEjOub.s:7391   .bss.id_cum.10080:0000000000000000 id_cum.10080
     /tmp/ccpEjOub.s:7397   .bss.uq_cum.10081:0000000000000000 uq_cum.10081
     /tmp/ccpEjOub.s:7403   .bss.ud_cum.10082:0000000000000000 ud_cum.10082
     /tmp/ccpEjOub.s:3476   .text.motor_slow_loop:0000000000000474 $t
     /tmp/ccpEjOub.s:3685   .text.motor_slow_loop:00000000000005cc $d
     /tmp/ccpEjOub.s:3702   .text.DMA_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:3708   .text.DMA_Init:0000000000000000 DMA_Init
     /tmp/ccpEjOub.s:3759   .text.DMA_Init:0000000000000038 $d
     /tmp/ccpEjOub.s:3764   .rodata:0000000000000000 $d
     /tmp/ccpEjOub.s:3768   .text.ADC1_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:3774   .text.ADC1_Init:0000000000000000 ADC1_Init
     /tmp/ccpEjOub.s:4044   .text.ADC1_Init:00000000000001a8 $d
     /tmp/ccpEjOub.s:4051   .text.ADC2_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:4057   .text.ADC2_Init:0000000000000000 ADC2_Init
     /tmp/ccpEjOub.s:4165   .text.ADC2_Init:0000000000000090 $d
     /tmp/ccpEjOub.s:4172   .text.TIM1_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:4178   .text.TIM1_Init:0000000000000000 TIM1_Init
     /tmp/ccpEjOub.s:4434   .text.TIM1_Init:00000000000001a0 $d
     /tmp/ccpEjOub.s:4441   .text.TIM2_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:4447   .text.TIM2_Init:0000000000000000 TIM2_Init
     /tmp/ccpEjOub.s:4550   .text.TIM2_Init:0000000000000090 $d
     /tmp/ccpEjOub.s:4556   .text.GPIO_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:4562   .text.GPIO_Init:0000000000000000 GPIO_Init
     /tmp/ccpEjOub.s:4665   .text.GPIO_Init:0000000000000094 $d
     /tmp/ccpEjOub.s:4673   .text.HAL_TIM_PeriodElapsedCallback:0000000000000000 $t
     /tmp/ccpEjOub.s:4680   .text.HAL_TIM_PeriodElapsedCallback:0000000000000000 HAL_TIM_PeriodElapsedCallback
ARM GAS  /tmp/ccpEjOub.s 			page 256


     /tmp/ccpEjOub.s:4784   .text.HAL_TIM_PeriodElapsedCallback:0000000000000084 $d
     /tmp/ccpEjOub.s:4795   .text.dyn_adc_state:0000000000000000 $t
     /tmp/ccpEjOub.s:4802   .text.dyn_adc_state:0000000000000000 dyn_adc_state
     /tmp/ccpEjOub.s:4976   .text.dyn_adc_state:00000000000000d8 $d
     /tmp/ccpEjOub.s:4983   .text.set_inj_channel:0000000000000000 $t
     /tmp/ccpEjOub.s:4989   .text.set_inj_channel:0000000000000000 set_inj_channel
     /tmp/ccpEjOub.s:5120   .text.set_inj_channel:0000000000000090 $d
     /tmp/ccpEjOub.s:5129   .text.PI_control:0000000000000000 $t
     /tmp/ccpEjOub.s:5136   .text.PI_control:0000000000000000 PI_control
     /tmp/ccpEjOub.s:5426   .text.runPIcontrol:0000000000000000 $t
     /tmp/ccpEjOub.s:5433   .text.runPIcontrol:0000000000000000 runPIcontrol
     /tmp/ccpEjOub.s:5754   .text.runPIcontrol:0000000000000208 $d
     /tmp/ccpEjOub.s:5771   .text.TIM3_Init:0000000000000000 $t
     /tmp/ccpEjOub.s:5777   .text.TIM3_Init:0000000000000000 TIM3_Init
     /tmp/ccpEjOub.s:5883   .text.TIM3_Init:0000000000000094 $d
     /tmp/ccpEjOub.s:5890   .text.motor_init:0000000000000000 $t
     /tmp/ccpEjOub.s:5897   .text.motor_init:0000000000000000 motor_init
     /tmp/ccpEjOub.s:6178   .text.motor_init:00000000000001e0 $d
     /tmp/ccpEjOub.s:6193   .text.motor_init:0000000000000214 $t
     /tmp/ccpEjOub.s:6381   .text.motor_init:000000000000034c $d
     /tmp/ccpEjOub.s:6398   .text.svpwm:0000000000000000 $t
     /tmp/ccpEjOub.s:6405   .text.svpwm:0000000000000000 svpwm
     /tmp/ccpEjOub.s:6648   .text.svpwm:0000000000000134 $d
     /tmp/ccpEjOub.s:6654   .text.FOC_calculation:0000000000000000 $t
     /tmp/ccpEjOub.s:6661   .text.FOC_calculation:0000000000000000 FOC_calculation
     /tmp/ccpEjOub.s:6849   .text.FOC_calculation:0000000000000124 $d
     /tmp/ccpEjOub.s:6856   .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000000 $t
     /tmp/ccpEjOub.s:6863   .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000000 HAL_ADCEx_InjectedConvCpltCallback
     /tmp/ccpEjOub.s:6890   .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000018 $d
     /tmp/ccpEjOub.s:6894   .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000028 $t
     /tmp/ccpEjOub.s:7209   .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000204 $d
     /tmp/ccpEjOub.s:7230   .text.HAL_ADCEx_InjectedConvCpltCallback:0000000000000250 $t
     /tmp/ccpEjOub.s:7345   .text.HAL_ADCEx_InjectedConvCpltCallback:00000000000002e8 $d
     /tmp/ccpEjOub.s:7359   .bss.q31_d_i.10001:0000000000000000 $d
     /tmp/ccpEjOub.s:7365   .data.ui16_halls_tim2tics_acc.10010:0000000000000000 $d
     /tmp/ccpEjOub.s:7376   .bss.KVtemp.10078:0000000000000000 $d
     /tmp/ccpEjOub.s:7382   .bss.iq_cum.10079:0000000000000000 $d
     /tmp/ccpEjOub.s:7388   .bss.id_cum.10080:0000000000000000 $d
     /tmp/ccpEjOub.s:7394   .bss.uq_cum.10081:0000000000000000 $d
     /tmp/ccpEjOub.s:7400   .bss.ud_cum.10082:0000000000000000 $d

UNDEFINED SYMBOLS
HAL_Delay
HAL_FLASH_Unlock
EE_WriteVariable
HAL_FLASH_Lock
HAL_GetTick
map
arm_sqrt_q31
HAL_NVIC_SetPriority
HAL_NVIC_EnableIRQ
HAL_ADC_Init
HAL_ADCEx_MultiModeConfigChannel
HAL_ADC_Stop
HAL_ADCEx_InjectedConfigChannel
HAL_ADC_ConfigChannel
HAL_TIM_Base_Init
ARM GAS  /tmp/ccpEjOub.s 			page 257


HAL_TIM_ConfigClockSource
HAL_TIM_PWM_Init
HAL_TIM_OC_Init
HAL_TIMEx_MasterConfigSynchronization
HAL_TIM_PWM_ConfigChannel
HAL_TIMEx_ConfigBreakDeadTime
HAL_TIM_MspPostInit
HAL_GPIO_Init
EE_Init
HAL_ADCEx_Calibration_Start
HAL_ADCEx_MultiModeStart_DMA
HAL_ADC_Start_IT
HAL_TIM_Base_Start_IT
HAL_TIM_PWM_Start
HAL_TIMEx_PWMN_Start
HAL_TIM_PWM_Start_IT
EE_ReadVariable
arm_sin_cos_q31
HAL_ADCEx_InjectedGetValue
